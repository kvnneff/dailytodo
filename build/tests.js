(function outer(modules, cache, entries){

  /**
   * Global
   */

  var global = (function(){ return this; })();

  /**
   * Require `name`.
   *
   * @param {String} name
   * @param {Boolean} jumped
   * @api public
   */

  function require(name, jumped){
    if (cache[name]) return cache[name].exports;
    if (modules[name]) return call(name, require);
    throw new Error('cannot find module "' + name + '"');
  }

  /**
   * Call module `id` and cache it.
   *
   * @param {Number} id
   * @param {Function} require
   * @return {Function}
   * @api private
   */

  function call(id, require){
    var m = cache[id] = { exports: {} };
    var mod = modules[id];
    var name = mod[2];
    var fn = mod[0];

    fn.call(m.exports, function(req){
      var dep = modules[id][1][req];
      return require(dep ? dep : req);
    }, m, m.exports, outer, modules, cache, entries);

    // expose as `name`.
    if (name) cache[name] = cache[id];

    return cache[id].exports;
  }

  /**
   * Require all entries exposing them on global if needed.
   */

  for (var id in entries) {
    if (entries[id]) {
      global[entries[id]] = require(id);
    } else {
      require(id);
    }
  }

  /**
   * Duo flag.
   */

  require.duo = true;

  /**
   * Expose cache.
   */

  require.cache = cache;

  /**
   * Expose modules
   */

  require.modules = modules;

  /**
   * Return newest require.
   */

   return require;
})({
1: [function(require, module, exports) {
require('./list.js');
require('./todo.js');
require('./list-view.js');
require('./todo-view.js');
}, {"./list.js":2,"./todo.js":3,"./list-view.js":4,"./todo-view.js":5}],
2: [function(require, module, exports) {
var assert = require('component/assert');
var List = require('/lib/list');

describe('List', function () {
    it('returns a new list', function () {
        var list = List();
        assert(list !== List());
    });
});

describe('List#createTodo', function () {
    it('creates a new todo', function () {
        var list = List();
        list.createTodo({title: 'Foo'});
        assert(list.todos[0].title === 'Foo');
    });
});

describe('List#removeTodo', function () {
    it('removes a todo', function () {
        var list = List();
        list.createTodo({title: 'Foo'});
        assert(list.todos[0].title === 'Foo');
        list.removeTodo(list.todos[0]._id);
        assert(list.todos.length === 0);
    });
});

describe('List#attrs', function () {
    it('returns the list\'s attributes', function () {
        var list = List();
        list.createTodo({title: 'Foo'});
        assert(list.attrs()._id === list._id);
    });
});

describe('List.today()', function () {
    it('returns today\'s list', function () {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate()-1);
        var list1 = List();
        var list2 = List();
        list1.createTodo({title: 'Foo'});
        list2.createTodo({title: 'Bar'});
        list1.save();
        list2.timestamp = yesterday;
        list2.save();
        List.today(function (err, list) {
            assert(err === null);
            assert(list.todos.length === 1);
            assert(list.todos[0].title === 'Foo');
        });
    });
});

describe('List.yesterday()', function () {
    it('returns yesterday\'s list', function () {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate()-1);
        var list1 = List();
        var list2 = List();
        list1.createTodo({title: 'Foo'});
        list2.createTodo({title: 'Bar'});
        list1.save();
        list2.timestamp = yesterday;
        list2.save();
        List.yesterday(function (err, list) {
            assert(err === null);
            assert(list.todos.length === 1);
            assert(list.todos[0].title === 'Bar');
        });
    });
});
}, {"component/assert":6,"/lib/list":7}],
6: [function(require, module, exports) {

/**
 * Module dependencies.
 */

var equals = require('equals');
var fmt = require('fmt');
var stack = require('stack');

/**
 * Assert `expr` with optional failure `msg`.
 *
 * @param {Mixed} expr
 * @param {String} [msg]
 * @api public
 */

module.exports = exports = function (expr, msg) {
  if (expr) return;
  throw error(msg || message());
};

/**
 * Assert `actual` is weak equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

exports.equal = function (actual, expected, msg) {
  if (actual == expected) return;
  throw error(msg || fmt('Expected %o to equal %o.', actual, expected), actual, expected);
};

/**
 * Assert `actual` is not weak equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

exports.notEqual = function (actual, expected, msg) {
  if (actual != expected) return;
  throw error(msg || fmt('Expected %o not to equal %o.', actual, expected));
};

/**
 * Assert `actual` is deep equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

exports.deepEqual = function (actual, expected, msg) {
  if (equals(actual, expected)) return;
  throw error(msg || fmt('Expected %o to deeply equal %o.', actual, expected), actual, expected);
};

/**
 * Assert `actual` is not deep equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

exports.notDeepEqual = function (actual, expected, msg) {
  if (!equals(actual, expected)) return;
  throw error(msg || fmt('Expected %o not to deeply equal %o.', actual, expected));
};

/**
 * Assert `actual` is strict equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

exports.strictEqual = function (actual, expected, msg) {
  if (actual === expected) return;
  throw error(msg || fmt('Expected %o to strictly equal %o.', actual, expected), actual, expected);
};

/**
 * Assert `actual` is not strict equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

exports.notStrictEqual = function (actual, expected, msg) {
  if (actual !== expected) return;
  throw error(msg || fmt('Expected %o not to strictly equal %o.', actual, expected));
};

/**
 * Assert `block` throws an `error`.
 *
 * @param {Function} block
 * @param {Function} [error]
 * @param {String} [msg]
 * @api public
 */

exports.throws = function (block, err, msg) {
  var threw;
  try {
    block();
  } catch (e) {
    threw = e;
  }

  if (!threw) throw error(msg || fmt('Expected %s to throw an error.', block.toString()));
  if (err && !(threw instanceof err)) {
    throw error(msg || fmt('Expected %s to throw an %o.', block.toString(), err));
  }
};

/**
 * Assert `block` doesn't throw an `error`.
 *
 * @param {Function} block
 * @param {Function} [error]
 * @param {String} [msg]
 * @api public
 */

exports.doesNotThrow = function (block, err, msg) {
  var threw;
  try {
    block();
  } catch (e) {
    threw = e;
  }

  if (threw) throw error(msg || fmt('Expected %s not to throw an error.', block.toString()));
  if (err && (threw instanceof err)) {
    throw error(msg || fmt('Expected %s not to throw an %o.', block.toString(), err));
  }
};

/**
 * Create a message from the call stack.
 *
 * @return {String}
 * @api private
 */

function message() {
  if (!Error.captureStackTrace) return 'assertion failed';
  var callsite = stack()[2];
  var fn = callsite.getFunctionName();
  var file = callsite.getFileName();
  var line = callsite.getLineNumber() - 1;
  var col = callsite.getColumnNumber() - 1;
  var src = get(file);
  line = src.split('\n')[line].slice(col);
  var m = line.match(/assert\((.*)\)/);
  return m && m[1].trim();
}

/**
 * Load contents of `script`.
 *
 * @param {String} script
 * @return {String}
 * @api private
 */

function get(script) {
  var xhr = new XMLHttpRequest;
  xhr.open('GET', script, false);
  xhr.send(null);
  return xhr.responseText;
}

/**
 * Error with `msg`, `actual` and `expected`.
 *
 * @param {String} msg
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @return {Error}
 */

function error(msg, actual, expected){
  var err = new Error(msg);
  err.showDiff = 3 == arguments.length;
  err.actual = actual;
  err.expected = expected;
  return err;
}

}, {"equals":8,"fmt":9,"stack":10}],
8: [function(require, module, exports) {
var type = require('type')

// (any, any, [array]) -> boolean
function equal(a, b, memos){
  // All identical values are equivalent
  if (a === b) return true
  var fnA = types[type(a)]
  var fnB = types[type(b)]
  return fnA && fnA === fnB
    ? fnA(a, b, memos)
    : false
}

var types = {}

// (Number) -> boolean
types.number = function(a, b){
  return a !== a && b !== b/*Nan check*/
}

// (function, function, array) -> boolean
types['function'] = function(a, b, memos){
  return a.toString() === b.toString()
    // Functions can act as objects
    && types.object(a, b, memos)
    && equal(a.prototype, b.prototype)
}

// (date, date) -> boolean
types.date = function(a, b){
  return +a === +b
}

// (regexp, regexp) -> boolean
types.regexp = function(a, b){
  return a.toString() === b.toString()
}

// (DOMElement, DOMElement) -> boolean
types.element = function(a, b){
  return a.outerHTML === b.outerHTML
}

// (textnode, textnode) -> boolean
types.textnode = function(a, b){
  return a.textContent === b.textContent
}

// decorate `fn` to prevent it re-checking objects
// (function) -> function
function memoGaurd(fn){
  return function(a, b, memos){
    if (!memos) return fn(a, b, [])
    var i = memos.length, memo
    while (memo = memos[--i]) {
      if (memo[0] === a && memo[1] === b) return true
    }
    return fn(a, b, memos)
  }
}

types['arguments'] =
types.array = memoGaurd(arrayEqual)

// (array, array, array) -> boolean
function arrayEqual(a, b, memos){
  var i = a.length
  if (i !== b.length) return false
  memos.push([a, b])
  while (i--) {
    if (!equal(a[i], b[i], memos)) return false
  }
  return true
}

types.object = memoGaurd(objectEqual)

// (object, object, array) -> boolean
function objectEqual(a, b, memos) {
  if (typeof a.equal == 'function') {
    memos.push([a, b])
    return a.equal(b, memos)
  }
  var ka = getEnumerableProperties(a)
  var kb = getEnumerableProperties(b)
  var i = ka.length

  // same number of properties
  if (i !== kb.length) return false

  // although not necessarily the same order
  ka.sort()
  kb.sort()

  // cheap key test
  while (i--) if (ka[i] !== kb[i]) return false

  // remember
  memos.push([a, b])

  // iterate again this time doing a thorough check
  i = ka.length
  while (i--) {
    var key = ka[i]
    if (!equal(a[key], b[key], memos)) return false
  }

  return true
}

// (object) -> array
function getEnumerableProperties (object) {
  var result = []
  for (var k in object) if (k !== 'constructor') {
    result.push(k)
  }
  return result
}

module.exports = equal

}, {"type":11}],
11: [function(require, module, exports) {

var toString = {}.toString
var DomNode = typeof window != 'undefined'
  ? window.Node
  : Function

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = exports = function(x){
  var type = typeof x
  if (type != 'object') return type
  type = types[toString.call(x)]
  if (type) return type
  if (x instanceof DomNode) switch (x.nodeType) {
    case 1:  return 'element'
    case 3:  return 'text-node'
    case 9:  return 'document'
    case 11: return 'document-fragment'
    default: return 'dom-node'
  }
}

var types = exports.types = {
  '[object Function]': 'function',
  '[object Date]': 'date',
  '[object RegExp]': 'regexp',
  '[object Arguments]': 'arguments',
  '[object Array]': 'array',
  '[object String]': 'string',
  '[object Null]': 'null',
  '[object Undefined]': 'undefined',
  '[object Number]': 'number',
  '[object Boolean]': 'boolean',
  '[object Object]': 'object',
  '[object Text]': 'text-node',
  '[object Uint8Array]': 'bit-array',
  '[object Uint16Array]': 'bit-array',
  '[object Uint32Array]': 'bit-array',
  '[object Uint8ClampedArray]': 'bit-array',
  '[object Error]': 'error',
  '[object FormData]': 'form-data',
  '[object File]': 'file',
  '[object Blob]': 'blob'
}

}, {}],
9: [function(require, module, exports) {

/**
 * Export `fmt`
 */

module.exports = fmt;

/**
 * Formatters
 */

fmt.o = JSON.stringify;
fmt.s = String;
fmt.d = parseInt;

/**
 * Format the given `str`.
 *
 * @param {String} str
 * @param {...} args
 * @return {String}
 * @api public
 */

function fmt(str){
  var args = [].slice.call(arguments, 1);
  var j = 0;

  return str.replace(/%([a-z])/gi, function(_, f){
    return fmt[f]
      ? fmt[f](args[j++])
      : _ + f;
  });
}

}, {}],
10: [function(require, module, exports) {

/**
 * Expose `stack()`.
 */

module.exports = stack;

/**
 * Return the stack.
 *
 * @return {Array}
 * @api public
 */

function stack() {
  var orig = Error.prepareStackTrace;
  Error.prepareStackTrace = function(_, stack){ return stack; };
  var err = new Error;
  Error.captureStackTrace(err, arguments.callee);
  var stack = err.stack;
  Error.prepareStackTrace = orig;
  return stack;
}
}, {}],
7: [function(require, module, exports) {
'use strict';
var PouchDB = require('pouchdb/pouchdb@3.1.0');
var Emitter = require('component/emitter');
var uid = require('matthewmueller/uid');
var Todo = require('./lib/todo');
var List;
var db;

db = new PouchDB('daily_todo_lists');

function isToday(td) {
    var d = new Date();
    if (isNaN(td.getTime())) return false;
    return td.getDate() == d.getDate() && td.getMonth() == d.getMonth() && td.getFullYear() == d.getFullYear();
};

function isYesterday(yd) {
    var y = new Date();
    y.setDate(y.getDate()-1);
    return yd.getDate() == y.getDate() && yd.getMonth() == y.getMonth() && yd.getFullYear() == y.getFullYear();
};

List = function List(attrs) {
    if (!(this instanceof List)) return new List(attrs);
    attrs = attrs || {};
    var self = this;
    var tmpTodos = attrs.todos || [];
    this._id = attrs._id || uid();
    this._rev = attrs._rev || -1;
    this.timestamp = attrs.timestamp ? new Date(attrs.timestamp) : new Date();
    this.todos = [];
    tmpTodos.forEach(function (todo, index) {
        self.createTodo(todo);
    });
};

Emitter(List.prototype);

List.all = function all() {
    var self = this;
    var collection = [];
    db.allDocs({include_docs: true}, function (err, res) {
        if (err) return cb(err);
        if (res.rows.length) {
            res.rows.forEach(function (row) {
                collection.push(new List(row));
            });
        }
        return cb(collection);
    });
};

List.today = function today(cb) {
    db.query(function (doc, emit) {
        if (isToday(new Date(doc.timestamp))) {
            emit(doc);
        }
    }, function (err, res) {
        if (err) return cb(err);
        if (res.rows.length <= 0) return cb(null, List());
        return cb(null, List(res.rows[0].key));
    });
};

List.yesterday = function yesterday(cb) {
    db.query(function (doc, emit) {
        if (isYesterday(new Date(doc.timestamp))) {
            emit(doc);
        }
    }, function (err, res) {
        if (err) return cb(err);
        if (res.rows.length <= 0) {
            var date = new Date();
            date.setDate(date.getDate()-1);
            return cb(null, new List({timestamp: date}));
        }
        return cb(null, new List(res.rows[0].key));
    });
};

List.prototype.attrs = function attrs() {
    var props = {};
    if (this._id) props._id = this._id;
    if (this._rev !== -1) props._rev = this._rev;
    props.timestamp = this.timestamp;
    props.todos = [];
    this.todos.forEach(function (todo) {
        props.todos.push(todo.attrs());
    });
    return props;
};

List.prototype.save = function save(cb) {
    var self = this;
    db.put(this.attrs(), function (err, doc) {
        if (err && cb) return cb(err);
        if (err) throw err;
        self._rev = doc.rev;
        if (cb) return cb();
    });
};

List.prototype.remove = function remove(cb) {
    db.remove(this.attrs(), function (err, res) {
        if (err) throw err;
        if (cb) return cb(null, res);
    });
};


List.prototype.createTodo = function createTodo(attrs) {
    var self = this;
    var todo = new Todo(attrs);
    todo.on('change', function (prop, val) {
        self.emit('change todo', todo, prop, val);
    });

    todo.on('destroy', function () {
        var todo = this;
        var index = self.todos.indexOf(todo);
        self.todos.splice(index, 1);
        self.save();
    });
    this.todos.push(todo);
    this.emit('create todo', todo);
};

List.prototype.removeTodo = function removeTodo(_id) {
    var self = this;
    this.todos.forEach(function (todo, index) {
        if (todo._id === _id) {
            self.todos.splice(index, 1);
            self.emit('remove todo', todo);
        }
    });
};

module.exports = List;
}, {"pouchdb/pouchdb@3.1.0":12,"component/emitter":13,"matthewmueller/uid":14,"./lib/todo":15}],
12: [function(require, module, exports) {
//    PouchDB 3.1.0
//    
//    (c) 2012-2014 Dale Harvey and the PouchDB team
//    PouchDB may be freely distributed under the Apache license, version 2.0.
//    For all details and documentation:
//    http://pouchdb.com
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.PouchDB=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";

var utils = _dereq_('./utils');
var merge = _dereq_('./merge');
var errors = _dereq_('./deps/errors');
var EventEmitter = _dereq_('events').EventEmitter;
var upsert = _dereq_('./deps/upsert');
var Changes = _dereq_('./changes');
var Promise = utils.Promise;

/*
 * A generic pouch adapter
 */

// returns first element of arr satisfying callback predicate
function arrayFirst(arr, callback) {
  for (var i = 0; i < arr.length; i++) {
    if (callback(arr[i], i) === true) {
      return arr[i];
    }
  }
  return false;
}

// Wrapper for functions that call the bulkdocs api with a single doc,
// if the first result is an error, return an error
function yankError(callback) {
  return function (err, results) {
    if (err || (results[0] && results[0].error)) {
      callback(err || results[0]);
    } else {
      callback(null, results.length ? results[0]  : results);
    }
  };
}

// for every node in a revision tree computes its distance from the closest
// leaf
function computeHeight(revs) {
  var height = {};
  var edges = [];
  merge.traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
    var rev = pos + "-" + id;
    if (isLeaf) {
      height[rev] = 0;
    }
    if (prnt !== undefined) {
      edges.push({from: prnt, to: rev});
    }
    return rev;
  });

  edges.reverse();
  edges.forEach(function (edge) {
    if (height[edge.from] === undefined) {
      height[edge.from] = 1 + height[edge.to];
    } else {
      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
    }
  });
  return height;
}

function allDocsKeysQuery(api, opts, callback) {
  var keys =  ('limit' in opts) ?
      opts.keys.slice(opts.skip, opts.limit + opts.skip) :
      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;
  if (opts.descending) {
    keys.reverse();
  }
  if (!keys.length) {
    return api._allDocs({limit: 0}, callback);
  }
  var finalResults = {
    offset: opts.skip
  };
  return Promise.all(keys.map(function (key, i) {
    var subOpts = utils.extend(true, {key: key, deleted: 'ok'}, opts);
    ['limit', 'skip', 'keys'].forEach(function (optKey) {
      delete subOpts[optKey];
    });
    return new Promise(function (resolve, reject) {
      api._allDocs(subOpts, function (err, res) {
        if (err) {
          return reject(err);
        }
        finalResults.total_rows = res.total_rows;
        resolve(res.rows[0] || {key: key, error: 'not_found'});
      });
    });
  })).then(function (results) {
    finalResults.rows = results;
    return finalResults;
  });
}

utils.inherits(AbstractPouchDB, EventEmitter);
module.exports = AbstractPouchDB;

function AbstractPouchDB() {
  var self = this;
  EventEmitter.call(this);
  self.autoCompact = function (callback) {
    // http doesn't have auto-compaction
    if (!self.auto_compaction || self.type() === 'http') {
      return callback;
    }
    return function (err, res) {
      if (err) {
        callback(err);
      } else {
        var count = res.length;
        var decCount = function () {
          count--;
          if (!count) {
            callback(null, res);
          }
        };
        if (!res.length) {
          return callback(null, res);
        }
        res.forEach(function (doc) {
          if (doc.ok && doc.id) { // if no id, then it was a local doc
            // TODO: we need better error handling
            self.compactDocument(doc.id, 0, decCount);
          } else {
            decCount();
          }
        });
      }
    };
  };

  var listeners = 0, changes;
  var eventNames = ['change', 'delete', 'create', 'update'];
  this.on('newListener', function (eventName) {
    if (~eventNames.indexOf(eventName)) {
      if (listeners) {
        listeners++;
        return;
      } else {
        listeners++;
      }
    } else {
      return;
    }
    var lastChange = 0;
    changes = this.changes({
      conflicts: true,
      include_docs: true,
      continuous: true,
      since: 'now',
      onChange: function (change) {
        if (change.seq <= lastChange) {
          return;
        }
        lastChange = change.seq;
        self.emit('change', change);
        if (change.doc._deleted) {
          self.emit('delete', change);
        } else if (change.doc._rev.split('-')[0] === '1') {
          self.emit('create', change);
        } else {
          self.emit('update', change);
        }
      }
    });
  });
  this.on('removeListener', function (eventName) {
    if (~eventNames.indexOf(eventName)) {
      listeners--;
      if (listeners) {
        return;
      }
    } else {
      return;
    }
    changes.cancel();
  });
}

AbstractPouchDB.prototype.post =
  utils.adapterFun('post', function (doc, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return callback(errors.NOT_AN_OBJECT);
  }
  this.bulkDocs({docs: [doc]}, opts,
      this.autoCompact(yankError(callback)));
});

AbstractPouchDB.prototype.put =
  utils.adapterFun('put', utils.getArguments(function (args) {
  var temp, temptype, opts, callback;
  var doc = args.shift();
  var id = '_id' in doc;
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    callback = args.pop();
    return callback(errors.NOT_AN_OBJECT);
  }
  doc = utils.clone(doc);
  while (true) {
    temp = args.shift();
    temptype = typeof temp;
    if (temptype === "string" && !id) {
      doc._id = temp;
      id = true;
    } else if (temptype === "string" && id && !('_rev' in doc)) {
      doc._rev = temp;
    } else if (temptype === "object") {
      opts = temp;
    } else if (temptype === "function") {
      callback = temp;
    }
    if (!args.length) {
      break;
    }
  }
  opts = opts || {};
  var error = utils.invalidIdError(doc._id);
  if (error) {
    return callback(error);
  }
  if (utils.isLocalId(doc._id) && typeof this._putLocal === 'function') {
    if (doc._deleted) {
      return this._removeLocal(doc, callback);
    } else {
      return this._putLocal(doc, callback);
    }
  }
  this.bulkDocs({docs: [doc]}, opts,
      this.autoCompact(yankError(callback)));
}));

AbstractPouchDB.prototype.putAttachment =
  utils.adapterFun('putAttachment', function (docId, attachmentId, rev,
                                              blob, type, callback) {
  var api = this;
  if (typeof type === 'function') {
    callback = type;
    type = blob;
    blob = rev;
    rev = null;
  }
  if (typeof type === 'undefined') {
    type = blob;
    blob = rev;
    rev = null;
  }

  function createAttachment(doc) {
    doc._attachments = doc._attachments || {};
    doc._attachments[attachmentId] = {
      content_type: type,
      data: blob
    };
    return api.put(doc);
  }

  return api.get(docId).then(function (doc) {
    if (doc._rev !== rev) {
      throw errors.REV_CONFLICT;
    }

    return createAttachment(doc);
  }, function (err) {
     // create new doc
    if (err.error === errors.MISSING_DOC.error) {
      return createAttachment({_id: docId});
    } else {
      throw err;
    }
  });
});

AbstractPouchDB.prototype.removeAttachment =
  utils.adapterFun('removeAttachment', function (docId, attachmentId, rev,
                                                 callback) {
  var self = this;
  self.get(docId, function (err, obj) {
    if (err) {
      callback(err);
      return;
    }
    if (obj._rev !== rev) {
      callback(errors.REV_CONFLICT);
      return;
    }
    if (!obj._attachments) {
      return callback();
    }
    delete obj._attachments[attachmentId];
    if (Object.keys(obj._attachments).length === 0) {
      delete obj._attachments;
    }
    self.put(obj, callback);
  });
});

AbstractPouchDB.prototype.remove =
  utils.adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
  var doc;
  if (typeof optsOrRev === 'string') {
    // id, rev, opts, callback style
    doc = {
      _id: docOrId,
      _rev: optsOrRev
    };
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
  } else {
    // doc, opts, callback style
    doc = docOrId;
    if (typeof optsOrRev === 'function') {
      callback = optsOrRev;
      opts = {};
    } else {
      callback = opts;
      opts = optsOrRev;
    }
  }
  opts = utils.clone(opts || {});
  opts.was_delete = true;
  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};
  newDoc._deleted = true;
  if (utils.isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
    return this._removeLocal(doc, callback);
  }
  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));
});

AbstractPouchDB.prototype.revsDiff =
  utils.adapterFun('revsDiff', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts = utils.clone(opts);
  var ids = Object.keys(req);

  if (!ids.length) {
    return callback(null, {});
  }

  var count = 0;
  var missing = new utils.Map();

  function addToMissing(id, revId) {
    if (!missing.has(id)) {
      missing.set(id, {missing: []});
    }
    missing.get(id).missing.push(revId);
  }

  function processDoc(id, rev_tree) {
    // Is this fast enough? Maybe we should switch to a set simulated by a map
    var missingForId = req[id].slice(0);
    merge.traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,
      opts) {
        var rev = pos + '-' + revHash;
        var idx = missingForId.indexOf(rev);
        if (idx === -1) {
          return;
        }

        missingForId.splice(idx, 1);
        if (opts.status !== 'available') {
          addToMissing(id, rev);
        }
      });

    // Traversing the tree is synchronous, so now `missingForId` contains
    // revisions that were not found in the tree
    missingForId.forEach(function (rev) {
      addToMissing(id, rev);
    });
  }

  ids.map(function (id) {
    this._getRevisionTree(id, function (err, rev_tree) {
      if (err && err.status === 404 && err.message === 'missing') {
        missing.set(id, {missing: req[id]});
      } else if (err) {
        return callback(err);
      } else {
        processDoc(id, rev_tree);
      }

      if (++count === ids.length) {
        // convert LazyMap to object
        var missingObj = {};
        missing.forEach(function (value, key) {
          missingObj[key] = value;
        });
        return callback(null, missingObj);
      }
    });
  }, this);
});

// compact one document and fire callback
// by compacting we mean removing all revisions which
// are further from the leaf in revision tree than max_height
AbstractPouchDB.prototype.compactDocument =
  utils.adapterFun('compactDocument', function (docId, maxHeight, callback) {
  var self = this;
  this._getRevisionTree(docId, function (err, revTree) {
    if (err) {
      return callback(err);
    }
    var height = computeHeight(revTree);
    var candidates = [];
    var revs = [];
    Object.keys(height).forEach(function (rev) {
      if (height[rev] > maxHeight) {
        candidates.push(rev);
      }
    });

    merge.traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
      var rev = pos + '-' + revHash;
      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {
        revs.push(rev);
      }
    });
    self._doCompaction(docId, revs, callback);
  });
});

// compact the whole database using single document
// compaction
AbstractPouchDB.prototype.compact =
  utils.adapterFun('compact', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  var self = this;

  opts = utils.clone(opts || {});

  self.get('_local/compaction')["catch"](function () {
    return false;
  }).then(function (doc) {
    if (typeof self._compact === 'function') {
      if (doc && doc.last_seq) {
        opts.last_seq = doc.last_seq;
      }
      return self._compact(opts, callback);
    }

  });
});
AbstractPouchDB.prototype._compact = function (opts, callback) {
  var done = false;
  var started = 0;
  var copts = {
    returnDocs: false
  };
  var self = this;
  var lastSeq;
  function finish() {
    upsert(self, '_local/compaction', function (doc) {
      if (!doc.last_seq || doc.last_seq < lastSeq) {
        doc.last_seq = lastSeq;
        return doc;
      }
      return false; // somebody else got here first, don't update
    }, callback);
  }
  if (opts.last_seq) {
    copts.since = opts.last_seq;
  }
  function afterCompact() {
    started--;
    if (!started && done) {
      finish();
    }
  }
  function onChange(row) {
    started++;
    self.compactDocument(row.id, 0).then(afterCompact, callback);
  }
  self.changes(copts).on('change', onChange).on('complete', function (resp) {
    done = true;
    lastSeq = resp.last_seq;
    if (!started) {
      finish();
    }
  }).on('error', callback);
};
/* Begin api wrappers. Specific functionality to storage belongs in the 
   _[method] */
AbstractPouchDB.prototype.get =
  utils.adapterFun('get', function (id, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof id !== 'string') {
    return callback(errors.INVALID_ID);
  }
  if (utils.isLocalId(id) && typeof this._getLocal === 'function') {
    return this._getLocal(id, callback);
  }
  var leaves = [], self = this;
  function finishOpenRevs() {
    var result = [];
    var count = leaves.length;
    if (!count) {
      return callback(null, result);
    }
    // order with open_revs is unspecified
    leaves.forEach(function (leaf) {
      self.get(id,
               {rev: leaf, revs: opts.revs, attachments: opts.attachments},
               function (err, doc) {
        if (!err) {
          result.push({ok: doc});
        } else {
          result.push({missing: leaf});
        }
        count--;
        if (!count) {
          callback(null, result);
        }
      });
    });
  }

  if (opts.open_revs) {
    if (opts.open_revs === "all") {
      this._getRevisionTree(id, function (err, rev_tree) {
        if (err) {
          // if there's no such document we should treat this
          // situation the same way as if revision tree was empty
          rev_tree = [];
        }
        leaves = merge.collectLeaves(rev_tree).map(function (leaf) {
          return leaf.rev;
        });
        finishOpenRevs();
      });
    } else {
      if (Array.isArray(opts.open_revs)) {
        leaves = opts.open_revs;
        for (var i = 0; i < leaves.length; i++) {
          var l = leaves[i];
          // looks like it's the only thing couchdb checks
          if (!(typeof(l) === "string" && /^\d+-/.test(l))) {
            return callback(errors.error(errors.BAD_REQUEST,
              "Invalid rev format"));
          }
        }
        finishOpenRevs();
      } else {
        return callback(errors.error(errors.UNKNOWN_ERROR,
          'function_clause'));
      }
    }
    return; // open_revs does not like other options
  }

  return this._get(id, opts, function (err, result) {
    opts = utils.clone(opts);
    if (err) {
      return callback(err);
    }

    var doc = result.doc;
    if (!doc) {
      // a smoke test for something being very wrong
      return callback(new Error('no doc!'));
    }
    var metadata = result.metadata;
    var ctx = result.ctx;

    if (opts.conflicts) {
      var conflicts = merge.collectConflicts(metadata);
      if (conflicts.length) {
        doc._conflicts = conflicts;
      }
    }

    if (opts.revs || opts.revs_info) {
      var paths = merge.rootToLeaf(metadata.rev_tree);
      var path = arrayFirst(paths, function (arr) {
        return arr.ids.map(function (x) { return x.id; })
          .indexOf(doc._rev.split('-')[1]) !== -1;
      });

      var indexOfRev = path.ids.map(function (x) {return x.id; })
        .indexOf(doc._rev.split('-')[1]) + 1;
      var howMany = path.ids.length - indexOfRev;
      path.ids.splice(indexOfRev, howMany);
      path.ids.reverse();

      if (opts.revs) {
        doc._revisions = {
          start: (path.pos + path.ids.length) - 1,
          ids: path.ids.map(function (rev) {
            return rev.id;
          })
        };
      }
      if (opts.revs_info) {
        var pos =  path.pos + path.ids.length;
        doc._revs_info = path.ids.map(function (rev) {
          pos--;
          return {
            rev: pos + '-' + rev.id,
            status: rev.opts.status
          };
        });
      }
    }

    if (opts.local_seq) {
      doc._local_seq = result.metadata.seq;
    }

    if (opts.attachments && doc._attachments) {
      var attachments = doc._attachments;
      var count = Object.keys(attachments).length;
      if (count === 0) {
        return callback(null, doc);
      }
      Object.keys(attachments).forEach(function (key) {
        this._getAttachment(attachments[key],
                            {encode: true, ctx: ctx}, function (err, data) {
          var att = doc._attachments[key];
          att.data = data;
          delete att.stub;
          delete att.length;
          if (!--count) {
            callback(null, doc);
          }
        });
      }, self);
    } else {
      if (doc._attachments) {
        for (var key in doc._attachments) {
          if (doc._attachments.hasOwnProperty(key)) {
            doc._attachments[key].stub = true;
          }
        }
      }
      callback(null, doc);
    }
  });
});

AbstractPouchDB.prototype.getAttachment =
  utils.adapterFun('getAttachment', function (docId, attachmentId, opts,
                                              callback) {
  var self = this;
  if (opts instanceof Function) {
    callback = opts;
    opts = {};
  }
  opts = utils.clone(opts);
  this._get(docId, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (res.doc._attachments && res.doc._attachments[attachmentId]) {
      opts.ctx = res.ctx;
      self._getAttachment(res.doc._attachments[attachmentId], opts, callback);
    } else {
      return callback(errors.MISSING_DOC);
    }
  });
});

AbstractPouchDB.prototype.allDocs =
  utils.adapterFun('allDocs', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts = utils.clone(opts);
  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
  if ('keys' in opts) {
    if (!Array.isArray(opts.keys)) {
      return callback(new TypeError('options.keys must be an array'));
    }
    var incompatibleOpt =
      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
      return incompatibleOpt in opts;
    })[0];
    if (incompatibleOpt) {
      callback(errors.error(errors.QUERY_PARSE_ERROR,
        'Query parameter `' + incompatibleOpt +
        '` is not compatible with multi-get'
      ));
      return;
    }
    if (this.type() !== 'http') {
      return allDocsKeysQuery(this, opts, callback);
    }
  }

  return this._allDocs(opts, callback);
});

AbstractPouchDB.prototype.changes = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return new Changes(this, opts, callback);
};

AbstractPouchDB.prototype.close =
  utils.adapterFun('close', function (callback) {
  this._closed = true;
  return this._close(callback);
});

AbstractPouchDB.prototype.info = utils.adapterFun('info', function (callback) {
  var self = this;
  this._info(function (err, info) {
    if (err) {
      return callback(err);
    }
    // assume we know better than the adapter, unless it informs us
    info.db_name = info.db_name || self._db_name;
    info.auto_compaction = !!(self._auto_compaction && self.type() !== 'http');
    callback(null, info);
  });
});

AbstractPouchDB.prototype.id = utils.adapterFun('id', function (callback) {
  return this._id(callback);
});

AbstractPouchDB.prototype.type = function () {
  return (typeof this._type === 'function') ? this._type() : this.adapter;
};

AbstractPouchDB.prototype.bulkDocs =
  utils.adapterFun('bulkDocs', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = utils.clone(opts);

  if (Array.isArray(req)) {
    req = {
      docs: req
    };
  }

  if (!req || !req.docs || !Array.isArray(req.docs)) {
    return callback(errors.MISSING_BULK_DOCS);
  }

  for (var i = 0; i < req.docs.length; ++i) {
    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
      return callback(errors.NOT_AN_OBJECT);
    }
  }

  req = utils.clone(req);
  if (!('new_edits' in opts)) {
    if ('new_edits' in req) {
      opts.new_edits = req.new_edits;
    } else {
      opts.new_edits = true;
    }
  }

  if (!opts.new_edits && this.type() !== 'http') {
    // ensure revisions of the same doc are sorted, so that
    // the local adapter processes them correctly (#2935)
    req.docs.sort(function (a, b) {
      var idCompare = utils.compare(a._id, b._id);
      if (idCompare !== 0) {
        return idCompare;
      }
      var aStart = a._revisions ? a._revisions.start : 0;
      var bStart = b._revisions ? b._revisions.start : 0;
      return utils.compare(aStart, bStart);
    });
  }

  return this._bulkDocs(req, opts, this.autoCompact(function (err, res) {
    if (err) {
      return callback(err);
    }
    if (!opts.new_edits) {
      // this is what couch does when new_edits is false
      res = res.filter(function (x) {
        return x.error;
      });
    }
    callback(null, res);
  }));
});

AbstractPouchDB.prototype.registerDependentDatabase =
  utils.adapterFun('registerDependentDatabase', function (dependentDb,
                                                          callback) {
  var opts = {};
  if (this.__opts.db) {
    opts.db = this.__opts.db;
  }
  if (this._adapter) {
    opts.adapter = this._adapter;
  }

  var depDB = new this.constructor(dependentDb, opts);

  function diffFun(doc) {
    doc.dependentDbs = doc.dependentDbs || {};
    if (doc.dependentDbs[dependentDb]) {
      return false; // no update required
    }
    doc.dependentDbs[dependentDb] = true;
    return doc;
  }
  upsert(this, '_local/_pouch_dependentDbs', diffFun, function (err) {
    if (err) {
      return callback(err);
    }
    return callback(null, {db: depDB});
  });
});

},{"./changes":6,"./deps/errors":12,"./deps/upsert":16,"./merge":21,"./utils":26,"events":30}],2:[function(_dereq_,module,exports){
(function (process){
"use strict";

var CHANGES_BATCH_SIZE = 25;

var utils = _dereq_('../utils');
var errors = _dereq_('../deps/errors');

function encodeDocId(id) {
  if (/^_(design|local)/.test(id)) {
    return id;
  }
  return encodeURIComponent(id);
}

function preprocessAttachments(doc) {
  if (!doc._attachments || !Object.keys(doc._attachments)) {
    return utils.Promise.resolve();
  }

  return utils.Promise.all(Object.keys(doc._attachments).map(function (key) {
    var attachment = doc._attachments[key];
    if (attachment.data && typeof attachment.data !== 'string') {
      if (typeof process === undefined || process.browser) {
        return new utils.Promise(function (resolve) {
          utils.readAsBinaryString(attachment.data, function (binary) {
            attachment.data = utils.btoa(binary);
            resolve();
          });
        });
      } else {
        attachment.data = attachment.data.toString('base64');
      }
    }
  }));
}

// Get all the information you possibly can about the URI given by name and
// return it as a suitable object.
function getHost(name, opts) {
  // If the given name contains "http:"
  if (/http(s?):/.test(name)) {
    // Prase the URI into all its little bits
    var uri = utils.parseUri(name);

    // Store the fact that it is a remote URI
    uri.remote = true;

    // Store the user and password as a separate auth object
    if (uri.user || uri.password) {
      uri.auth = {username: uri.user, password: uri.password};
    }

    // Split the path part of the URI into parts using '/' as the delimiter
    // after removing any leading '/' and any trailing '/'
    var parts = uri.path.replace(/(^\/|\/$)/g, '').split('/');

    // Store the first part as the database name and remove it from the parts
    // array
    uri.db = parts.pop();

    // Restore the path by joining all the remaining parts (all the parts
    // except for the database name) with '/'s
    uri.path = parts.join('/');
    opts = opts || {};
    opts = utils.clone(opts);
    uri.headers = opts.headers || {};

    if (opts.auth || uri.auth) {
      var nAuth = opts.auth || uri.auth;
      var token = utils.btoa(nAuth.username + ':' + nAuth.password);
      uri.headers.Authorization = 'Basic ' + token;
    }

    if (opts.headers) {
      uri.headers = opts.headers;
    }

    return uri;
  }

  // If the given name does not contain 'http:' then return a very basic object
  // with no host, the current path, the given name as the database name and no
  // username/password
  return {host: '', path: '/', db: name, auth: false};
}

// Generate a URL with the host data given by opts and the given path
function genDBUrl(opts, path) {
  return genUrl(opts, opts.db + '/' + path);
}

// Generate a URL with the host data given by opts and the given path
function genUrl(opts, path) {
  if (opts.remote) {
    // If the host already has a path, then we need to have a path delimiter
    // Otherwise, the path delimiter is the empty string
    var pathDel = !opts.path ? '' : '/';

    // If the host already has a path, then we need to have a path delimiter
    // Otherwise, the path delimiter is the empty string
    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' +
           opts.path + pathDel + path;
  }

  return '/' + path;
}
// Implements the PouchDB API for dealing with CouchDB instances over HTTP
function HttpPouch(opts, callback) {
  // The functions that will be publicly available for HttpPouch
  var api = this;
  api.getHost = opts.getHost ? opts.getHost : getHost;

  // Parse the URI given by opts.name into an easy-to-use object
  var host = api.getHost(opts.name, opts);

  // Generate the database URL based on the host
  var dbUrl = genDBUrl(host, '');

  api.getUrl = function () {return dbUrl; };
  api.getHeaders = function () {return utils.clone(host.headers); };

  var ajaxOpts = opts.ajax || {};
  opts = utils.clone(opts);
  function ajax(options, callback) {
    return utils.ajax(utils.extend({}, ajaxOpts, options), callback);
  }

  // Create a new CouchDB database based on the given opts
  var createDB = function () {
    ajax({headers: host.headers, method: 'PUT', url: dbUrl},
         function (err, ret) {
      // If we get an "Unauthorized" error
      if (err && err.status === 401) {
        // Test if the database already exists
        ajax({headers: host.headers, method: 'HEAD', url: dbUrl},
             function (err, ret) {
          // If there is still an error
          if (err) {
            // Give the error to the callback to deal with
            callback(err);
          } else {
            // Continue as if there had been no errors
            callback(null, api);
          }
        });
        // If there were no errros or if the only error is "Precondition Failed"
        // (note: "Precondition Failed" occurs when we try to create a database
        // that already exists)
      } else if (!err || err.status === 412) {
        // Continue as if there had been no errors
        callback(null, api);
      } else {
        callback(err);
      }
    });
  };
  if (!opts.skipSetup) {
    ajax({headers: host.headers, method: 'GET', url: dbUrl},
         function (err, ret) {
      //check if the db exists
      if (err) {
        if (err.status === 404) {
          utils.explain404(
            'PouchDB is just detecting if the remote DB exists.');
          //if it doesn't, create it
          createDB();
        } else {
          callback(err);
        }
      } else {
        //go do stuff with the db
        callback(null, api);
      }
    });
  }

  api.type = function () {
    return 'http';
  };

  api.id = utils.adapterFun('id', function (callback) {
    ajax({
      headers: host.headers,
      method: 'GET',
      url: genUrl(host, '')
    }, function (err, result) {
      var uuid = (result && result.uuid) ?
        result.uuid + host.db : genDBUrl(host, '');
      callback(null, uuid);
    });
  });

  api.request = utils.adapterFun('request', function (options, callback) {
    options.headers = host.headers;
    options.url = genDBUrl(host, options.url);
    ajax(options, callback);
  });

  // Sends a POST request to the host calling the couchdb _compact function
  //    version: The version of CouchDB it is running
  api.compact = utils.adapterFun('compact', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = utils.clone(opts);
    ajax({
      headers: host.headers,
      url: genDBUrl(host, '_compact'),
      method: 'POST'
    }, function () {
      function ping() {
        api.info(function (err, res) {
          if (!res.compact_running) {
            callback();
          } else {
            setTimeout(ping, opts.interval || 200);
          }
        });
      }
      // Ping the http if it's finished compaction
      if (typeof callback === "function") {
        ping();
      }
    });
  });

  // Calls GET on the host, which gets back a JSON string containing
  //    couchdb: A welcome string
  //    version: The version of CouchDB it is running
  api._info = function (callback) {
    ajax({
      headers: host.headers,
      method: 'GET',
      url: genDBUrl(host, '')
    }, function (err, res) {
      if (err) {
        callback(err);
      } else {
        res.host = genDBUrl(host, '');
        callback(null, res);
      }
    });
  };

  // Get the document with the given id from the database given by host.
  // The id could be solely the _id in the database, or it may be a
  // _design/ID or _local/ID path
  api.get = utils.adapterFun('get', function (id, opts, callback) {
    // If no options were given, set the callback to the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = utils.clone(opts);
    if (opts.auto_encode === undefined) {
      opts.auto_encode = true;
    }

    // List of parameters to add to the GET request
    var params = [];

    // If it exists, add the opts.revs value to the list of parameters.
    // If revs=true then the resulting JSON will include a field
    // _revisions containing an array of the revision IDs.
    if (opts.revs) {
      params.push('revs=true');
    }

    // If it exists, add the opts.revs_info value to the list of parameters.
    // If revs_info=true then the resulting JSON will include the field
    // _revs_info containing an array of objects in which each object
    // representing an available revision.
    if (opts.revs_info) {
      params.push('revs_info=true');
    }

    if (opts.local_seq) {
      params.push('local_seq=true');
    }
    // If it exists, add the opts.open_revs value to the list of parameters.
    // If open_revs=all then the resulting JSON will include all the leaf
    // revisions. If open_revs=["rev1", "rev2",...] then the resulting JSON
    // will contain an array of objects containing data of all revisions
    if (opts.open_revs) {
      if (opts.open_revs !== "all") {
        opts.open_revs = JSON.stringify(opts.open_revs);
      }
      params.push('open_revs=' + opts.open_revs);
    }

    // If it exists, add the opts.attachments value to the list of parameters.
    // If attachments=true the resulting JSON will include the base64-encoded
    // contents in the "data" property of each attachment.
    if (opts.attachments) {
      params.push('attachments=true');
    }

    // If it exists, add the opts.rev value to the list of parameters.
    // If rev is given a revision number then get the specified revision.
    if (opts.rev) {
      params.push('rev=' + opts.rev);
    }

    // If it exists, add the opts.conflicts value to the list of parameters.
    // If conflicts=true then the resulting JSON will include the field
    // _conflicts containing all the conflicting revisions.
    if (opts.conflicts) {
      params.push('conflicts=' + opts.conflicts);
    }

    // Format the list of parameters into a valid URI query string
    params = params.join('&');
    params = params === '' ? '' : '?' + params;

    if (opts.auto_encode) {
      id = encodeDocId(id);
    }

    // Set the options for the ajax call
    var options = {
      headers: host.headers,
      method: 'GET',
      url: genDBUrl(host, id + params)
    };

    // If the given id contains at least one '/' and the part before the '/'
    // is NOT "_design" and is NOT "_local"
    // OR
    // If the given id contains at least two '/' and the part before the first
    // '/' is "_design".
    // TODO This second condition seems strange since if parts[0] === '_design'
    // then we already know that parts[0] !== '_local'.
    var parts = id.split('/');
    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||
        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {
      // Binary is expected back from the server
      options.binary = true;
    }

    // Get the document
    ajax(options, function (err, doc, xhr) {
      // If the document does not exist, send an error to the callback
      if (err) {
        return callback(err);
      }

      // Send the document to the callback
      callback(null, doc, xhr);
    });
  });

  // Delete the document given by doc from the database given by host.
  api.remove = utils.adapterFun('remove',
      function (docOrId, optsOrRev, opts, callback) {
    var doc;
    if (typeof optsOrRev === 'string') {
      // id, rev, opts, callback style
      doc = {
        _id: docOrId,
        _rev: optsOrRev
      };
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
    } else {
      // doc, opts, callback style
      doc = docOrId;
      if (typeof optsOrRev === 'function') {
        callback = optsOrRev;
        opts = {};
      } else {
        callback = opts;
        opts = optsOrRev;
      }
    }

    var rev = (doc._rev || opts.rev);

    // Delete the document
    ajax({
      headers: host.headers,
      method: 'DELETE',
      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev
    }, callback);
  });

  function encodeAttachmentId(attachmentId) {
    return attachmentId.split("/").map(encodeURIComponent).join("/");
  }

  // Get the attachment
  api.getAttachment =
    utils.adapterFun('getAttachment', function (docId, attachmentId, opts,
                                                callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = utils.clone(opts);
    if (opts.auto_encode === undefined) {
      opts.auto_encode = true;
    }
    if (opts.auto_encode) {
      docId = encodeDocId(docId);
    }
    opts.auto_encode = false;
    api.get(docId + '/' + encodeAttachmentId(attachmentId), opts, callback);
  });

  // Remove the attachment given by the id and rev
  api.removeAttachment =
    utils.adapterFun('removeAttachment', function (docId, attachmentId, rev,
                                                   callback) {

    var url = genDBUrl(host, encodeDocId(docId) + '/' +
      encodeAttachmentId(attachmentId)) + '?rev=' + rev;

    ajax({
      headers: host.headers,
      method: 'DELETE',
      url: url
    }, callback);
  });

  // Add the attachment given by blob and its contentType property
  // to the document with the given id, the revision given by rev, and
  // add it to the database given by host.
  api.putAttachment =
    utils.adapterFun('putAttachment', function (docId, attachmentId, rev, blob,
                                                type, callback) {
    if (typeof type === 'function') {
      callback = type;
      type = blob;
      blob = rev;
      rev = null;
    }
    if (typeof type === 'undefined') {
      type = blob;
      blob = rev;
      rev = null;
    }
    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
    var url = genDBUrl(host, id);
    if (rev) {
      url += '?rev=' + rev;
    }

    if (typeof blob === 'string') {
      try {
        blob = utils.atob(blob);
      } catch (err) {
        // it's not base64-encoded, so throw error
        return callback(utils.extend({}, errors.BAD_ARG,
          {reason: "Attachments need to be base64 encoded"}));
      }
    }

    var opts = {
      headers: utils.clone(host.headers),
      method: 'PUT',
      url: url,
      processData: false,
      body: blob,
      timeout: 60000
    };
    opts.headers['Content-Type'] = type;
    // Add the attachment
    ajax(opts, callback);
  });

  // Add the document given by doc (in JSON string format) to the database
  // given by host. This fails if the doc has no _id field.
  api.put = utils.adapterFun('put', utils.getArguments(function (args) {
    var temp, temptype, opts;
    var doc = args.shift();
    var id = '_id' in doc;
    var callback = args.pop();
    if (typeof doc !== 'object' || Array.isArray(doc)) {
      return callback(errors.NOT_AN_OBJECT);
    }

    doc = utils.clone(doc);

    preprocessAttachments(doc).then(function () {
      while (true) {
        temp = args.shift();
        temptype = typeof temp;
        if (temptype === "string" && !id) {
          doc._id = temp;
          id = true;
        } else if (temptype === "string" && id && !('_rev' in doc)) {
          doc._rev = temp;
        } else if (temptype === "object") {
          opts = utils.clone(temp);
        }
        if (!args.length) {
          break;
        }
      }
      opts = opts || {};
      var error = utils.invalidIdError(doc._id);
      if (error) {
        throw error;
      }

      // List of parameter to add to the PUT request
      var params = [];

      // If it exists, add the opts.new_edits value to the list of parameters.
      // If new_edits = false then the database will NOT assign this document a
      // new revision number
      if (opts && typeof opts.new_edits !== 'undefined') {
        params.push('new_edits=' + opts.new_edits);
      }

      // Format the list of parameters into a valid URI query string
      params = params.join('&');
      if (params !== '') {
        params = '?' + params;
      }

      // Add the document
      ajax({
        headers: host.headers,
        method: 'PUT',
        url: genDBUrl(host, encodeDocId(doc._id)) + params,
        body: doc
      }, function (err, res) {
        if (err) {
          return callback(err);
        }
        res.ok = true;
        callback(null, res);
      });
    })["catch"](callback);

  }));

  // Add the document given by doc (in JSON string format) to the database
  // given by host. This does not assume that doc is a new document 
  // (i.e. does not have a _id or a _rev field.)
  api.post = utils.adapterFun('post', function (doc, opts, callback) {
    // If no options were given, set the callback to be the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = utils.clone(opts);
    if (typeof doc !== 'object') {
      return callback(errors.NOT_AN_OBJECT);
    }
    if (! ("_id" in doc)) {
      doc._id = utils.uuid();
    }
    api.put(doc, opts, function (err, res) {
      if (err) {
        return callback(err);
      }
      res.ok = true;
      callback(null, res);
    });
  });

  // Update/create multiple documents given by req in the database
  // given by host.
  api._bulkDocs = function (req, opts, callback) {
    // If opts.new_edits exists add it to the document data to be
    // send to the database.
    // If new_edits=false then it prevents the database from creating
    // new revision numbers for the documents. Instead it just uses
    // the old ones. This is used in database replication.
    if (typeof opts.new_edits !== 'undefined') {
      req.new_edits = opts.new_edits;
    }

    utils.Promise.all(req.docs.map(preprocessAttachments)).then(function () {
      // Update/create the documents
      ajax({
        headers: host.headers,
        method: 'POST',
        url: genDBUrl(host, '_bulk_docs'),
        body: req
      }, function (err, results) {
        if (err) {
          return callback(err);
        }
        results.forEach(function (result) {
          result.ok = true; // smooths out cloudant not adding this
        });
        callback(null, results);
      });
    })["catch"](callback);
  };

  // Get a listing of the documents in the database given
  // by host and ordered by increasing id.
  api.allDocs = utils.adapterFun('allDocs', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = utils.clone(opts);
    // List of parameters to add to the GET request
    var params = [];
    var body;
    var method = 'GET';

    // TODO I don't see conflicts as a valid parameter for a
    // _all_docs request 
    // (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)
    if (opts.conflicts) {
      params.push('conflicts=true');
    }

    // If opts.descending is truthy add it to params
    if (opts.descending) {
      params.push('descending=true');
    }

    // If opts.include_docs exists, add the include_docs value to the
    // list of parameters.
    // If include_docs=true then include the associated document with each
    // result.
    if (opts.include_docs) {
      params.push('include_docs=true');
    }

    if (opts.key) {
      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));
    }

    // If opts.startkey exists, add the startkey value to the list of
    // parameters.
    // If startkey is given then the returned list of documents will
    // start with the document whose id is startkey.
    if (opts.startkey) {
      params.push('startkey=' +
        encodeURIComponent(JSON.stringify(opts.startkey)));
    }

    // If opts.endkey exists, add the endkey value to the list of parameters.
    // If endkey is given then the returned list of docuemnts will
    // end with the document whose id is endkey.
    if (opts.endkey) {
      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));
    }

    if (typeof opts.inclusive_end !== 'undefined') {
      params.push('inclusive_end=' + !!opts.inclusive_end);
    }

    // If opts.limit exists, add the limit value to the parameter list.
    if (typeof opts.limit !== 'undefined') {
      params.push('limit=' + opts.limit);
    }

    if (typeof opts.skip !== 'undefined') {
      params.push('skip=' + opts.skip);
    }

    // Format the list of parameters into a valid URI query string
    params = params.join('&');
    if (params !== '') {
      params = '?' + params;
    }

    if (typeof opts.keys !== 'undefined') {

      var MAX_URL_LENGTH = 2000;
      // according to http://stackoverflow.com/a/417184/680742,
      // the de factor URL length limit is 2000 characters

      var keysAsString =
        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
        // If the keys are short enough, do a GET. we do this to work around
        // Safari not understanding 304s on POSTs (see issue #1239)
        params += (params.indexOf('?') !== -1 ? '&' : '?') + keysAsString;
      } else {
        // If keys are too long, issue a POST request to circumvent GET
        // query string limits
        // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
        method = 'POST';
        body = JSON.stringify({keys: opts.keys});
      }
    }

    // Get the document listing
    ajax({
      headers: host.headers,
      method: method,
      url: genDBUrl(host, '_all_docs' + params),
      body: body
    }, callback);
  });

  // Get a list of changes made to documents in the database given by host.
  // TODO According to the README, there should be two other methods here,
  // api.changes.addListener and api.changes.removeListener.
  api._changes = function (opts) {
    // We internally page the results of a changes request, this means
    // if there is a large set of changes to be returned we can start
    // processing them quicker instead of waiting on the entire
    // set of changes to return and attempting to process them at once
    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;

    opts = utils.clone(opts);
    opts.timeout = opts.timeout || 30 * 1000;

    // We give a 5 second buffer for CouchDB changes to respond with
    // an ok timeout
    var params = { timeout: opts.timeout - (5 * 1000) };
    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
    if (limit === 0) {
      limit = 1;
    }
    var returnDocs;
    if ('returnDocs' in opts) {
      returnDocs = opts.returnDocs;
    } else {
      returnDocs = true;
    }
    //
    var leftToFetch = limit;

    if (opts.style) {
      params.style = opts.style;
    }

    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
      params.include_docs = true;
    }

    if (opts.continuous) {
      params.feed = 'longpoll';
    }

    if (opts.conflicts) {
      params.conflicts = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    if (opts.filter && typeof opts.filter === 'string') {
      params.filter = opts.filter;
      if (opts.filter === '_view' &&
          opts.view &&
          typeof opts.view === 'string') {
        params.view = opts.view;
      }
    }

    // If opts.query_params exists, pass it through to the changes request.
    // These parameters may be used by the filter on the source database.
    if (opts.query_params && typeof opts.query_params === 'object') {
      for (var param_name in opts.query_params) {
        if (opts.query_params.hasOwnProperty(param_name)) {
          params[param_name] = opts.query_params[param_name];
        }
      }
    }
    if (opts.continuous && api._useSSE) {
      return  api.sse(opts, params, returnDocs);
    }
    var xhr;
    var lastFetchedSeq;

    // Get all the changes starting wtih the one immediately after the
    // sequence number given by since.
    var fetch = function (since, callback) {
      if (opts.aborted) {
        return;
      }
      params.since = since;
      if (opts.descending) {
        if (limit) {
          params.limit = leftToFetch;
        }
      } else {
        params.limit = (!limit || leftToFetch > batchSize) ?
          batchSize : leftToFetch;
      }

      var paramStr = '?' + Object.keys(params).map(function (k) {
        return k + '=' + params[k];
      }).join('&');

      // Set the options for the ajax call
      var xhrOpts = {
        headers: host.headers,
        method: 'GET',
        url: genDBUrl(host, '_changes' + paramStr),
        // _changes can take a long time to generate, especially when filtered
        timeout: opts.timeout
      };
      lastFetchedSeq = since;

      if (opts.aborted) {
        return;
      }

      // Get the changes
      xhr = ajax(xhrOpts, callback);
    };

    // If opts.since exists, get all the changes from the sequence
    // number given by opts.since. Otherwise, get all the changes
    // from the sequence number 0.
    var fetchTimeout = 10;
    var fetchRetryCount = 0;

    var results = {results: []};

    var fetched = function (err, res) {
      if (opts.aborted) {
        return;
      }
      var raw_results_length = 0;
      // If the result of the ajax call (res) contains changes (res.results)
      if (res && res.results) {
        raw_results_length = res.results.length;
        results.last_seq = res.last_seq;
        // For each change
        var req = {};
        req.query = opts.query_params;
        res.results = res.results.filter(function (c) {
          leftToFetch--;
          var ret = utils.filterChange(opts)(c);
          if (ret) {
            if (returnDocs) {
              results.results.push(c);
            }
            utils.call(opts.onChange, c);
          }
          return ret;
        });
      } else if (err) {
        // In case of an error, stop listening for changes and call
        // opts.complete
        opts.aborted = true;
        utils.call(opts.complete, err);
        return;
      }

      // The changes feed may have timed out with no results
      // if so reuse last update sequence
      if (res && res.last_seq) {
        lastFetchedSeq = res.last_seq;
      }

      var finished = (limit && leftToFetch <= 0) ||
        (res && raw_results_length < batchSize) ||
        (opts.descending);

      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {
        // Increase retry delay exponentially as long as errors persist
        if (err) {
          fetchRetryCount += 1;
        } else {
          fetchRetryCount = 0;
        }
        var timeoutMultiplier = 1 << fetchRetryCount;
        var retryWait = fetchTimeout * timeoutMultiplier;
        var maximumWait = opts.maximumWait || 30000;

        if (retryWait > maximumWait) {
          utils.call(opts.complete, err || errors.UNKNOWN_ERROR);
          return;
        }

        // Queue a call to fetch again with the newest sequence number
        setTimeout(function () { fetch(lastFetchedSeq, fetched); }, retryWait);
      } else {
        // We're done, call the callback
        utils.call(opts.complete, null, results);
      }
    };

    fetch(opts.since || 0, fetched);

    // Return a method to cancel this method from processing any more
    return {
      cancel: function () {
        opts.aborted = true;
        if (xhr) {
          xhr.abort();
        }
      }
    };
  };

  api.sse = function (opts, params, returnDocs) {
    params.feed = 'eventsource';
    params.since = opts.since || 0;
    params.limit = opts.limit;
    delete params.timeout;
    var paramStr = '?' + Object.keys(params).map(function (k) {
      return k + '=' + params[k];
    }).join('&');
    var url = genDBUrl(host, '_changes' + paramStr);
    var source = new EventSource(url);
    var results = {
      results: [],
      last_seq: false
    };
    var dispatched = false;
    var open = false;
    source.addEventListener('message', msgHandler, false);
    source.onopen = function () {
      open = true;
    };
    source.onerror = errHandler;
    return {
      cancel: function () {
        if (dispatched) {
          return dispatched.cancel();
        }
        source.removeEventListener('message', msgHandler, false);
        source.close();
      }
    };
    function msgHandler(e) {
      var data = JSON.parse(e.data);
      if (returnDocs) {
        results.results.push(data);
      }
      results.last_seq = data.seq;
      utils.call(opts.onChange, data);
    }
    function errHandler(err) {
      source.removeEventListener('message', msgHandler, false);
      if (open === false) {
        // errored before it opened
        // likely doesn't support EventSource
        api._useSSE = false;
        dispatched = api._changes(opts);
        return;
      }
      source.close();
      utils.call(opts.complete, err);
    }
    
  };

  api._useSSE = false;
  // Currently disabled due to failing chrome tests in saucelabs
  // api._useSSE = typeof global.EventSource === 'function';

  // Given a set of document/revision IDs (given by req), tets the subset of
  // those that do NOT correspond to revisions stored in the database.
  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
  api.revsDiff = utils.adapterFun('revsDiff', function (req, opts, callback) {
    // If no options were given, set the callback to be the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }

    // Get the missing document/revision IDs
    ajax({
      headers: host.headers,
      method: 'POST',
      url: genDBUrl(host, '_revs_diff'),
      body: JSON.stringify(req)
    }, callback);
  });

  api._close = function (callback) {
    callback();
  };

  api.destroy = utils.adapterFun('destroy', function (callback) {
    ajax({
      url: genDBUrl(host, ''),
      method: 'DELETE',
      headers: host.headers
    }, function (err, resp) {
      if (err) {
        api.emit('error', err);
        callback(err);
      } else {
        api.emit('destroyed');
        callback(null, resp);
      }
    });
  });
}

// Delete the HttpPouch specified by the given name.
HttpPouch.destroy = utils.toPromise(function (name, opts, callback) {
  var host = getHost(name, opts);
  opts = opts || {};
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts = utils.clone(opts);
  opts.headers = host.headers;
  opts.method = 'DELETE';
  opts.url = genDBUrl(host, '');
  var ajaxOpts = opts.ajax || {};
  opts = utils.extend({}, opts, ajaxOpts);
  utils.ajax(opts, callback);
});

// HttpPouch is a valid adapter.
HttpPouch.valid = function () {
  return true;
};

module.exports = HttpPouch;

}).call(this,_dereq_("/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"../deps/errors":12,"../utils":26,"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":31}],3:[function(_dereq_,module,exports){
(function (process,global){
'use strict';

var utils = _dereq_('../utils');
var merge = _dereq_('../merge');
var errors = _dereq_('../deps/errors');
var vuvuzela = _dereq_('vuvuzela');

var cachedDBs = {};
var taskQueue = {
  running: false,
  queue: []
};

function tryCode(fun, that, args) {
  try {
    fun.apply(that, args);
  } catch (err) { // shouldn't happen
    if (window.PouchDB) {
      window.PouchDB.emit('error', err);
    }
  }
}

function applyNext() {
  if (taskQueue.running || !taskQueue.queue.length) {
    return;
  }
  taskQueue.running = true;
  var item = taskQueue.queue.shift();
  item.action(function (err, res) {
    tryCode(item.callback, this, [err, res]);
    taskQueue.running = false;
    process.nextTick(applyNext);
  });
}

function idbError(callback) {
  return function (event) {
    var message = (event.target && event.target.error &&
      event.target.error.name) || event.target;
    callback(errors.error(errors.IDB_ERROR, message, event.type));
  };
}

// Unfortunately, the metadata has to be stringified
// when it is put into the database, because otherwise
// IndexedDB can throw errors for deeply-nested objects.
// Originally we just used JSON.parse/JSON.stringify; now
// we use this custom vuvuzela library that avoids recursion.
// If we could do it all over again, we'd probably use a
// format for the revision trees other than JSON.
function encodeMetadata(metadata, winningRev, deleted) {
  var storedObject = {data: vuvuzela.stringify(metadata)};
  storedObject.winningRev = winningRev;
  storedObject.deletedOrLocal = deleted ? '1' : '0';
  storedObject.id = metadata.id;
  return storedObject;
}

function decodeMetadata(storedObject) {
  if (!storedObject) {
    return null;
  }
  if (!storedObject.data) {
    // old format, when we didn't store it stringified
    return storedObject;
  }
  var metadata = vuvuzela.parse(storedObject.data);
  metadata.winningRev = storedObject.winningRev;
  metadata.deletedOrLocal = storedObject.deletedOrLocal === '1';
  return metadata;
}

function IdbPouch(opts, callback) {
  var api = this;

  taskQueue.queue.push({
    action: function (thisCallback) {
      init(api, opts, thisCallback);
    },
    callback: callback
  });
  applyNext();
}

function init(api, opts, callback) {

  // IndexedDB requires a versioned database structure, so we use the
  // version here to manage migrations.
  var ADAPTER_VERSION = 4;

  // The object stores created for each database
  // DOC_STORE stores the document meta data, its revision history and state
  // Keyed by document id
  var DOC_STORE = 'document-store';
  // BY_SEQ_STORE stores a particular version of a document, keyed by its
  // sequence id
  var BY_SEQ_STORE = 'by-sequence';
  // Where we store attachments
  var ATTACH_STORE = 'attach-store';
  // Where we store many-to-many relations
  // between attachment digests and seqs
  var ATTACH_AND_SEQ_STORE = 'attach-seq-store';

  // Where we store database-wide meta data in a single record
  // keyed by id: META_STORE
  var META_STORE = 'meta-store';
  // Where we store local documents
  var LOCAL_STORE = 'local-store';
  // Where we detect blob support
  var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

  var name = opts.name;

  var blobSupport = null;
  var instanceId = null;
  var idStored = false;
  var idb = null;
  var docCount = -1;

  // called when creating a fresh new database
  function createSchema(db) {
    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
    docStore.createIndex('seq', 'seq', {unique: true});
    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});
    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});
    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);

    // added in v2
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    // added in v3
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});

    // added in v4
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 2
  // unfortunately "deletedOrLocal" is a misnomer now that we no longer
  // store local docs in the main doc-store, but whaddyagonnado
  function addDeletedOrLocalIndex(txn, callback) {
    var docStore = txn.objectStore(DOC_STORE);
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    docStore.openCursor().onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var deleted = utils.isDeleted(metadata);
        metadata.deletedOrLocal = deleted ? "1" : "0";
        docStore.put(metadata);
        cursor["continue"]();
      } else {
        callback();
      }
    };
  }

  // migrations to get to version 3

  function createLocalStoreSchema(db) {
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
  }

  function migrateLocalStore(txn, cb) {
    var localStore = txn.objectStore(LOCAL_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var seqStore = txn.objectStore(BY_SEQ_STORE);

    var cursor = docStore.openCursor();
    cursor.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var docId = metadata.id;
        var local = utils.isLocalId(docId);
        var rev = merge.winningRev(metadata);
        if (local) {
          var docIdRev = docId + "::" + rev;
          // remove all seq entries
          // associated with this docId
          var start = docId + "::";
          var end = docId + "::~";
          var index = seqStore.index('_doc_id_rev');
          var range = global.IDBKeyRange.bound(start, end, false, false);
          var seqCursor = index.openCursor(range);
          seqCursor.onsuccess = function (e) {
            seqCursor = e.target.result;
            if (!seqCursor) {
              // done
              docStore["delete"](cursor.primaryKey);
              cursor["continue"]();
            } else {
              var data = seqCursor.value;
              if (data._doc_id_rev === docIdRev) {
                localStore.put(data);
              }
              seqStore["delete"](seqCursor.primaryKey);
              seqCursor["continue"]();
            }
          };
        } else {
          cursor["continue"]();
        }
      } else if (cb) {
        cb();
      }
    };
  }

  // migrations to get to version 4
  function addAttachAndSeqStore(db) {
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  function migrateAttsAndSeqs(txn) {
    var seqStore = txn.objectStore(BY_SEQ_STORE);
    var attStore = txn.objectStore(ATTACH_STORE);
    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

    // need to actually populate the table. this is the expensive part,
    // so as an optimization, check first that this database even
    // contains attachments
    var req = attStore.count();
    req.onsuccess = function (e) {
      var count = e.target.result;
      if (!count) {
        return; // done
      }

      seqStore.openCursor().onsuccess = function (e) {
        var cursor = e.target.result;
        if (!cursor) {
          return; // done
        }
        var doc = cursor.value;
        var seq = cursor.primaryKey;
        var atts = Object.keys(doc._attachments || {});
        var digestMap = {};
        for (var j = 0; j < atts.length; j++) {
          var att = doc._attachments[atts[j]];
          digestMap[att.digest] = true; // uniq digests, just in case
        }
        var digests = Object.keys(digestMap);
        for (j = 0; j < digests.length; j++) {
          var digest = digests[j];
          attAndSeqStore.put({
            seq: seq,
            digestSeq: digest + '::' + seq
          });
        }
        cursor["continue"]();
      };
    };
  }

  api.type = function () {
    return 'idb';
  };

  api._id = utils.toPromise(function (callback) {
    callback(null, instanceId);
  });

  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {
    var newEdits = opts.new_edits;
    var userDocs = req.docs;
    // Parse the docs, give them a sequence number for the result
    var docInfos = userDocs.map(function (doc, i) {
      if (doc._id && utils.isLocalId(doc._id)) {
        return doc;
      }
      var newDoc = utils.parseDoc(doc, newEdits);
      newDoc._bulk_seq = i;
      return newDoc;
    });

    var docInfoErrors = docInfos.filter(function (docInfo) {
      return docInfo.error;
    });
    if (docInfoErrors.length) {
      return callback(docInfoErrors[0]);
    }

    var results = new Array(docInfos.length);
    var fetchedDocs = new utils.Map();
    var preconditionErrored = false;

    function processDocs() {
      if (!docInfos.length) {
        return;
      }

      var idsToDocs = new utils.Map();

      docInfos.forEach(function (currentDoc, resultsIdx) {
        if (currentDoc._id && utils.isLocalId(currentDoc._id)) {
          api[currentDoc._deleted ? '_removeLocal' : '_putLocal'](
              currentDoc, {ctx: txn}, function (err, resp) {
            if (err) {
              results[resultsIdx] = err;
            } else {
              results[resultsIdx] = {};
            }
          });
          return;
        }

        var id = currentDoc.metadata.id;
        if (idsToDocs.has(id)) {
          idsToDocs.get(id).push([currentDoc, resultsIdx]);
        } else {
          idsToDocs.set(id, [[currentDoc, resultsIdx]]);
        }
      });

      // in the case of new_edits, the user can provide multiple docs
      // with the same id. these need to be processed sequentially
      idsToDocs.forEach(function (docs, id) {
        var numDone = 0;

        function docWritten() {
          if (++numDone < docs.length) {
            nextDoc();
          }
        }
        function nextDoc() {
          var value = docs[numDone];
          var currentDoc = value[0];
          var resultsIdx = value[1];

          if (fetchedDocs.has(id)) {
            updateDoc(fetchedDocs.get(id), currentDoc, resultsIdx, docWritten);
          } else {
            insertDoc(currentDoc, resultsIdx, docWritten);
          }
        }
        nextDoc();
      });
    }

    function fetchExistingDocs(callback) {
      if (!docInfos.length) {
        return callback();
      }

      var numFetched = 0;

      function checkDone() {
        if (++numFetched === docInfos.length) {
          callback();
        }
      }

      docInfos.forEach(function (docInfo) {
        if (docInfo._id && utils.isLocalId(docInfo._id)) {
          return checkDone(); // skip local docs
        }
        var id = docInfo.metadata.id;
        var req = txn.objectStore(DOC_STORE).get(id);
        req.onsuccess = function process_docRead(event) {
          var metadata = decodeMetadata(event.target.result);
          if (metadata) {
            fetchedDocs.set(id, metadata);
          }
          checkDone();
        };
      });
    }

    function complete() {
      if (preconditionErrored) {
        return;
      }
      var aresults = results.map(function (result) {
        if (result._bulk_seq) {
          delete result._bulk_seq;
        } else if (!Object.keys(result).length) {
          return {
            ok: true
          };
        }
        if (result.error) {
          return result;
        }

        var metadata = result.metadata;
        var rev = merge.winningRev(metadata);

        return {
          ok: true,
          id: metadata.id,
          rev: rev
        };
      });
      IdbPouch.Changes.notify(name);
      docCount = -1; // invalidate
      callback(null, aresults);
    }

    function preprocessAttachment(att, finish) {
      if (att.stub) {
        return finish();
      }
      if (typeof att.data === 'string') {
        var data;
        try {
          data = atob(att.data);
        } catch (e) {
          var err = errors.error(errors.BAD_ARG,
                                "Attachments need to be base64 encoded");
          return callback(err);
        }
        var length;
        if (blobSupport) {
          var type = att.content_type;
          data = utils.fixBinary(data);
          length = data.byteLength;
          att.data = utils.createBlob([data], {type: type});
        } else {
          length = data.length;
        }
        utils.MD5(data).then(function (result) {
          att.digest = 'md5-' + result;
          att.length = length;
          finish();
        });
        return;
      }
      utils.readAsBinaryString(att.data, function (binary) {
        if (!blobSupport) {
          att.data = btoa(binary);
        }
        utils.MD5(binary).then(function (result) {
          att.digest = 'md5-' + result;
          att.length = binary.length;
          finish();
        });
      });
    }

    function verifyAttachment(digest, callback) {
      var req = txn.objectStore([ATTACH_STORE]).get(digest);
      req.onsuccess = function (e) {
        if (!e.target.result) {
          var err = new Error('unknown stub attachment with digest ' + digest);
          err.status = 412;
          callback(err);
        } else {
          callback();
        }
      };
    }

    function verifyAttachments(finish) {
      var digests = [];
      docInfos.forEach(function (docInfo) {
        if (docInfo.data && docInfo.data._attachments) {
          Object.keys(docInfo.data._attachments).forEach(function (filename) {
            var att = docInfo.data._attachments[filename];
            if (att.stub) {
              digests.push(att.digest);
            }
          });
        }
      });
      if (!digests.length) {
        return finish();
      }
      var numDone = 0;
      var err;

      function checkDone() {
        if (++numDone === digests.length) {
          finish(err);
        }
      }
      digests.forEach(function (digest) {
        verifyAttachment(digest, function (attErr) {
          if (attErr && !err) {
            err = attErr;
          }
          checkDone();
        });
      });
    }

    function preprocessAttachments(callback) {
      if (!docInfos.length) {
        return callback();
      }

      var docv = 0;
      docInfos.forEach(function (docInfo) {
        var attachments = docInfo.data && docInfo.data._attachments ?
          Object.keys(docInfo.data._attachments) : [];

        if (!attachments.length) {
          return done();
        }

        var recv = 0;
        function attachmentProcessed() {
          recv++;
          if (recv === attachments.length) {
            done();
          }
        }

        for (var key in docInfo.data._attachments) {
          if (docInfo.data._attachments.hasOwnProperty(key)) {
            preprocessAttachment(docInfo.data._attachments[key],
                                 attachmentProcessed);
          }
        }
      });

      function done() {
        docv++;
        if (docInfos.length === docv) {
          callback();
        }
      }
    }

    function writeDoc(docInfo, winningRev, deleted, callback, resultsIdx) {
      var err = null;
      var recv = 0;
      var id = docInfo.data._id = docInfo.metadata.id;
      var rev = docInfo.data._rev = docInfo.metadata.rev;
      var docIdRev = id + "::" + rev;

      if (deleted) {
        docInfo.data._deleted = true;
      }

      var attachments = docInfo.data._attachments ?
        Object.keys(docInfo.data._attachments) : [];

      function collectResults(attachmentErr) {
        if (!err) {
          if (attachmentErr) {
            err = attachmentErr;
            callback(err);
          } else if (recv === attachments.length) {
            finish();
          }
        }
      }

      function attachmentSaved(err) {
        recv++;
        collectResults(err);
      }

      for (var key in docInfo.data._attachments) {
        if (!docInfo.data._attachments[key].stub) {
          var data = docInfo.data._attachments[key].data;
          delete docInfo.data._attachments[key].data;
          var digest = docInfo.data._attachments[key].digest;
          saveAttachment(digest, data, attachmentSaved);
        } else {
          recv++;
          collectResults();
        }
      }

      // map seqs to attachment digests, which
      // we will need later during compaction
      function insertAttachmentMappings(seq, callback) {
        var attsAdded = 0;
        var attsToAdd = Object.keys(docInfo.data._attachments || {});

        if (!attsToAdd.length) {
          return callback();
        }
        function checkDone() {
          if (++attsAdded === attsToAdd.length) {
            callback();
          }
        }
        function add(att) {
          var digest = docInfo.data._attachments[att].digest;
          var req = txn.objectStore(ATTACH_AND_SEQ_STORE).put({
            seq: seq,
            digestSeq: digest + '::' + seq
          });

          req.onsuccess = checkDone;
          req.onerror = function (e) {
            // this callback is for a constaint error, which we ignore
            // because this docid/rev has already been associated with
            // the digest (e.g. when new_edits == false)
            e.preventDefault(); // avoid transaction abort
            e.stopPropagation(); // avoid transaction onerror
            checkDone();
          };
        }
        for (var i = 0; i < attsToAdd.length; i++) {
          add(attsToAdd[i]); // do in parallel
        }
      }

      function finish() {
        docInfo.data._doc_id_rev = docIdRev;
        var seqStore = txn.objectStore(BY_SEQ_STORE);
        var index = seqStore.index('_doc_id_rev');

        function afterPut(e) {
          var metadata = docInfo.metadata;
          var seq = e.target.result;
          metadata.seq = seq;
          // Current _rev is calculated from _rev_tree on read
          delete metadata.rev;
          var metadataToStore = encodeMetadata(metadata, winningRev, deleted);
          var metaDataReq = txn.objectStore(DOC_STORE).put(metadataToStore);
          metaDataReq.onsuccess = function () {
            delete metadata.deletedOrLocal;
            delete metadata.winningRev;
            results[resultsIdx] = docInfo;
            fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
            insertAttachmentMappings(seq, function () {
              utils.call(callback);
            });
          };
        }

        var putReq = seqStore.put(docInfo.data);

        putReq.onsuccess = afterPut;
        putReq.onerror = function (e) {
          // ConstraintError, need to update, not put (see #1638 for details)
          e.preventDefault(); // avoid transaction abort
          e.stopPropagation(); // avoid transaction onerror
          var getKeyReq = index.getKey(docInfo.data._doc_id_rev);
          getKeyReq.onsuccess = function (e) {
            var putReq = seqStore.put(docInfo.data, e.target.result);
            putReq.onsuccess = afterPut;
          };
        };
      }

      if (!attachments.length) {
        finish();
      }
    }

    function updateDoc(oldDoc, docInfo, resultsIdx, callback) {

      if (utils.revExists(oldDoc, docInfo.metadata.rev)) {
        results[resultsIdx] = docInfo;
        callback();
        return;
      }

      var merged =
        merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);

      var previouslyDeleted = utils.isDeleted(oldDoc);
      var deleted = utils.isDeleted(docInfo.metadata);
      var inConflict = (previouslyDeleted && deleted && newEdits) ||
        (!previouslyDeleted && newEdits && merged.conflicts !== 'new_leaf') ||
        (previouslyDeleted && !deleted && merged.conflicts === 'new_branch');

      if (inConflict) {
        results[resultsIdx] = makeErr(errors.REV_CONFLICT, docInfo._bulk_seq);
        return callback();
      }

      docInfo.metadata.rev_tree = merged.tree;

      // recalculate
      var winningRev = merge.winningRev(docInfo.metadata);
      deleted = utils.isDeleted(docInfo.metadata, winningRev);

      writeDoc(docInfo, winningRev, deleted, callback, resultsIdx);
    }

    function insertDoc(docInfo, resultsIdx, callback) {
      var winningRev = merge.winningRev(docInfo.metadata);
      var deleted = utils.isDeleted(docInfo.metadata, winningRev);
      // Cant insert new deleted documents
      if ('was_delete' in opts && deleted) {
        results[resultsIdx] = errors.MISSING_DOC;
        return callback();
      }

      writeDoc(docInfo, winningRev, deleted, callback, resultsIdx);
    }

    // Insert sequence number into the error so we can sort later
    function makeErr(err, seq) {
      err._bulk_seq = seq;
      return err;
    }

    function saveAttachment(digest, data, callback) {
      var objectStore = txn.objectStore(ATTACH_STORE);
      objectStore.get(digest).onsuccess = function (e) {
        var exists = e.target.result;
        if (exists) {
          // don't bother re-putting if it already exists
          return utils.call(callback);
        }
        var newAtt = {
          digest: digest,
          body: data
        };
        objectStore.put(newAtt).onsuccess = function () {
          utils.call(callback);
        };
      };
    }

    var txn;
    preprocessAttachments(function () {
      var stores = [
        DOC_STORE, BY_SEQ_STORE,
        ATTACH_STORE, META_STORE,
        LOCAL_STORE, ATTACH_AND_SEQ_STORE
      ];
      txn = idb.transaction(stores, 'readwrite');
      txn.onerror = idbError(callback);
      txn.ontimeout = idbError(callback);
      txn.oncomplete = complete;

      verifyAttachments(function (err) {
        if (err) {
          preconditionErrored = true;
          return callback(err);
        }
        fetchExistingDocs(processDocs);
      });
    });
  };

  // First we look up the metadata in the ids database, then we fetch the
  // current revision(s) from the by sequence store
  api._get = function idb_get(id, opts, callback) {
    var doc;
    var metadata;
    var err;
    var txn;
    opts = utils.clone(opts);
    if (opts.ctx) {
      txn = opts.ctx;
    } else {
      txn =
        idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
    }

    function finish() {
      callback(err, {doc: doc, metadata: metadata, ctx: txn});
    }

    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      // we can determine the result here if:
      // 1. there is no such document
      // 2. the document is deleted and we don't ask about specific rev
      // When we ask with opts.rev we expect the answer to be either
      // doc (possibly with _deleted=true) or missing error
      if (!metadata) {
        err = errors.MISSING_DOC;
        return finish();
      }
      if (utils.isDeleted(metadata) && !opts.rev) {
        err = errors.error(errors.MISSING_DOC, "deleted");
        return finish();
      }
      var objectStore = txn.objectStore(BY_SEQ_STORE);

      // metadata.winningRev was added later, so older DBs might not have it
      var rev = opts.rev || metadata.winningRev || merge.winningRev(metadata);
      var key = metadata.id + '::' + rev;

      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
        doc = e.target.result;
        if (doc && doc._doc_id_rev) {
          delete(doc._doc_id_rev);
        }
        if (!doc) {
          err = errors.MISSING_DOC;
          return finish();
        }
        finish();
      };
    };
  };

  api._getAttachment = function (attachment, opts, callback) {
    var txn;
    opts = utils.clone(opts);
    if (opts.ctx) {
      txn = opts.ctx;
    } else {
      txn =
        idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
    }
    var digest = attachment.digest;
    var type = attachment.content_type;

    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
      var data = e.target.result.body;
      if (opts.encode) {
        if (!data) {
          callback(null, '');
        } else if (typeof data !== 'string') { // we have blob support
          utils.readAsBinaryString(data, function (binary) {
            callback(null, btoa(binary));
          });
        } else { // no blob support
          callback(null, data);
        }
      } else {
        if (!data) {
          callback(null, utils.createBlob([''], {type: type}));
        } else if (typeof data !== 'string') { // we have blob support
          callback(null, data);
        } else { // no blob support
          data = utils.fixBinary(atob(data));
          callback(null, utils.createBlob([data], {type: type}));
        }
      }
    };
  };

  function allDocsQuery(totalRows, opts, callback) {
    var start = 'startkey' in opts ? opts.startkey : false;
    var end = 'endkey' in opts ? opts.endkey : false;
    var key = 'key' in opts ? opts.key : false;
    var skip = opts.skip || 0;
    var limit = typeof opts.limit === 'number' ? opts.limit : -1;
    var inclusiveEnd = opts.inclusive_end !== false;
    var descending = 'descending' in opts && opts.descending ? 'prev' : null;

    var manualDescEnd = false;
    if (descending && start && end) {
      // unfortunately IDB has a quirk where IDBKeyRange.bound is invalid if the
      // start is less than the end, even in descending mode.  Best bet
      // is just to handle it manually in that case.
      manualDescEnd = end;
      end = false;
    }

    var keyRange = null;
    try {
      if (start && end) {
        keyRange = global.IDBKeyRange.bound(start, end, false, !inclusiveEnd);
      } else if (start) {
        if (descending) {
          keyRange = global.IDBKeyRange.upperBound(start);
        } else {
          keyRange = global.IDBKeyRange.lowerBound(start);
        }
      } else if (end) {
        if (descending) {
          keyRange = global.IDBKeyRange.lowerBound(end, !inclusiveEnd);
        } else {
          keyRange = global.IDBKeyRange.upperBound(end, !inclusiveEnd);
        }
      } else if (key) {
        keyRange = global.IDBKeyRange.only(key);
      }
    } catch (e) {
      if (e.name === "DataError" && e.code === 0) {
        // data error, start is less than end
        return callback(null, {
          total_rows : totalRows,
          offset : opts.skip,
          rows : []
        });
      } else {
        return callback(errors.error(errors.IDB_ERROR, e.name, e.message));
      }
    }

    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');
    transaction.oncomplete = function () {
      callback(null, {
        total_rows: totalRows,
        offset: opts.skip,
        rows: results
      });
    };

    var oStore = transaction.objectStore(DOC_STORE);
    var oCursor = descending ? oStore.openCursor(keyRange, descending)
      : oStore.openCursor(keyRange);
    var results = [];
    oCursor.onsuccess = function (e) {
      if (!e.target.result) {
        return;
      }
      var cursor = e.target.result;
      var metadata = decodeMetadata(cursor.value);
      // metadata.winningRev added later, some dbs might be missing it
      var winningRev = metadata.winningRev || merge.winningRev(metadata);

      function allDocsInner(metadata, data) {
        var doc = {
          id: metadata.id,
          key: metadata.id,
          value: {
            rev: winningRev
          }
        };
        if (opts.include_docs) {
          doc.doc = data;
          doc.doc._rev = winningRev;
          if (doc.doc._doc_id_rev) {
            delete(doc.doc._doc_id_rev);
          }
          if (opts.conflicts) {
            doc.doc._conflicts = merge.collectConflicts(metadata);
          }
          for (var att in doc.doc._attachments) {
            if (doc.doc._attachments.hasOwnProperty(att)) {
              doc.doc._attachments[att].stub = true;
            }
          }
        }
        var deleted = utils.isDeleted(metadata, winningRev);
        if (opts.deleted === 'ok') {
          // deleted docs are okay with keys_requests
          if (deleted) {
            doc.value.deleted = true;
            doc.doc = null;
          }
          results.push(doc);
        } else if (!deleted && skip-- <= 0) {
          if (manualDescEnd) {
            if (inclusiveEnd && doc.key < manualDescEnd) {
              return;
            } else if (!inclusiveEnd && doc.key <= manualDescEnd) {
              return;
            }
          }
          results.push(doc);
          if (--limit === 0) {
            return;
          }
        }
        cursor["continue"]();
      }

      if (!opts.include_docs) {
        allDocsInner(metadata);
      } else {
        var index = transaction.objectStore(BY_SEQ_STORE).index('_doc_id_rev');
        var key = metadata.id + "::" + winningRev;
        index.get(key).onsuccess = function (event) {
          allDocsInner(decodeMetadata(cursor.value), event.target.result);
        };
      }
    };
  }

  function countDocs(callback) {
    if (docCount !== -1) {
      return callback(null, docCount);
    }

    var count;
    var txn = idb.transaction([DOC_STORE], 'readonly');
    var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
    index.count(global.IDBKeyRange.only("0")).onsuccess = function (e) {
      count = e.target.result;
    };
    txn.onerror = idbError(callback);
    txn.oncomplete = function () {
      docCount = count;
      callback(null, docCount);
    };
  }

  api._allDocs = function idb_allDocs(opts, callback) {

    // first count the total_rows
    countDocs(function (err, totalRows) {
      if (err) {
        return callback(err);
      }
      if (opts.limit === 0) {
        return callback(null, {
          total_rows : totalRows,
          offset : opts.skip,
          rows : []
        });
      }
      allDocsQuery(totalRows, opts, callback);
    });
  };

  api._info = function idb_info(callback) {

    countDocs(function (err, count) {
      if (err) {
        return callback(err);
      }
      if (idb === null) {
        var error = new Error('db isn\'t open');
        error.id = 'idbNull';
        return callback(error);
      }
      var updateSeq = 0;
      var txn = idb.transaction([BY_SEQ_STORE], 'readonly');
      txn.objectStore(BY_SEQ_STORE).openCursor(null, "prev").onsuccess =
        function (event) {
        var cursor = event.target.result;
        if (cursor) {
          updateSeq = cursor.key;
        } else {
          updateSeq = 0;
        }
      };

      txn.oncomplete = function () {
        callback(null, {
          doc_count: count,
          update_seq: updateSeq
        });
      };
    });
  };

  api._changes = function (opts) {
    opts = utils.clone(opts);

    if (opts.continuous) {
      var id = name + ':' + utils.uuid();
      IdbPouch.Changes.addListener(name, id, api, opts);
      IdbPouch.Changes.notify(name);
      return {
        cancel: function () {
          IdbPouch.Changes.removeListener(name, id);
        }
      };
    }

    var descending = opts.descending ? 'prev' : null;
    var lastSeq = 0;

    // Ignore the `since` parameter when `descending` is true
    opts.since = opts.since && !descending ? opts.since : 0;

    var limit = 'limit' in opts ? opts.limit : -1;
    if (limit === 0) {
      limit = 1; // per CouchDB _changes spec
    }
    var returnDocs;
    if ('returnDocs' in opts) {
      returnDocs = opts.returnDocs;
    } else {
      returnDocs = true;
    }

    var results = [];
    var numResults = 0;
    var filter = utils.filterChange(opts);

    var txn;

    function fetchChanges() {
      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');
      txn.oncomplete = onTxnComplete;

      var req;

      if (descending) {
        req = txn.objectStore(BY_SEQ_STORE)
            .openCursor(global.IDBKeyRange.lowerBound(opts.since, true),
                        descending);
      } else {
        req = txn.objectStore(BY_SEQ_STORE)
            .openCursor(global.IDBKeyRange.lowerBound(opts.since, true));
      }

      req.onsuccess = onsuccess;
      req.onerror = onerror;
    }

    fetchChanges();

    function onsuccess(event) {
      var cursor = event.target.result;

      if (!cursor) {
        return;
      }

      var doc = cursor.value;

      if (opts.doc_ids && opts.doc_ids.indexOf(doc._id) === -1) {
        return cursor["continue"]();
      }

      var index = txn.objectStore(DOC_STORE);
      index.get(doc._id).onsuccess = function (event) {
        var metadata = decodeMetadata(event.target.result);

        if (lastSeq < metadata.seq) {
          lastSeq = metadata.seq;
        }
        // metadata.winningRev was only added later
        var winningRev = metadata.winningRev || merge.winningRev(metadata);
        if (doc._rev !== winningRev) {
          return cursor["continue"]();
        }

        delete doc['_doc_id_rev'];

        var change = opts.processChange(doc, metadata, opts);
        change.seq = cursor.key;
        if (filter(change)) {
          numResults++;
          if (returnDocs) {
            results.push(change);
          }
          opts.onChange(change);
        }
        if (numResults !== limit) {
          cursor["continue"]();
        }
      };
    }

    function onTxnComplete() {
      if (!opts.continuous) {
        opts.complete(null, {
          results: results,
          last_seq: lastSeq
        });
      }
    }
  };

  api._close = function (callback) {
    if (idb === null) {
      return callback(errors.NOT_OPEN);
    }

    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
    // "Returns immediately and closes the connection in a separate thread..."
    idb.close();
    delete cachedDBs[name];
    idb = null;
    callback();
  };

  api._getRevisionTree = function (docId, callback) {
    var txn = idb.transaction([DOC_STORE], 'readonly');
    var req = txn.objectStore(DOC_STORE).get(docId);
    req.onsuccess = function (event) {
      var doc = decodeMetadata(event.target.result);
      if (!doc) {
        callback(errors.MISSING_DOC);
      } else {
        callback(null, doc.rev_tree);
      }
    };
  };

  // This function removes revisions of document docId
  // which are listed in revs and sets this document
  // revision to to rev_tree
  api._doCompaction = function (docId, revs, callback) {
    var txn = idb.transaction([
      DOC_STORE,
      BY_SEQ_STORE,
      ATTACH_STORE,
      ATTACH_AND_SEQ_STORE
    ], 'readwrite');

    var docStore = txn.objectStore(DOC_STORE);
    var seqStore = txn.objectStore(BY_SEQ_STORE);
    var attStore = txn.objectStore(ATTACH_STORE);
    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

    var possiblyOrphanedDigests = [];

    function deleteOrphanedAttachments() {
      if (!possiblyOrphanedDigests.length) {
        return;
      }
      possiblyOrphanedDigests.forEach(function (digest) {
        var countReq = attAndSeqStore.index('digestSeq').count(
          global.IDBKeyRange.bound(
            digest + '::', digest + '::\uffff', false, false));
        countReq.onsuccess = function (e) {
          var count = e.target.result;
          if (!count) {
            // orphaned
            attStore["delete"](digest);
          }
        };
      });
    }

    docStore.get(docId).onsuccess = function (event) {
      var metadata = decodeMetadata(event.target.result);
      merge.traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                         revHash, ctx, opts) {
        var rev = pos + '-' + revHash;
        if (revs.indexOf(rev) !== -1) {
          opts.status = 'missing';
        }
      });

      var count = revs.length;
      revs.forEach(function (rev) {
        var index = seqStore.index('_doc_id_rev');
        var key = docId + "::" + rev;
        index.getKey(key).onsuccess = function (e) {
          var seq = e.target.result;
          if (typeof seq !== 'number') {
            return;
          }
          seqStore["delete"](seq);

          var cursor = attAndSeqStore.index('seq')
            .openCursor(global.IDBKeyRange.only(seq));

          cursor.onsuccess = function (event) {
            var cursor = event.target.result;
            if (cursor) {
              var digest = cursor.value.digestSeq.split('::')[0];
              possiblyOrphanedDigests.push(digest);
              attAndSeqStore["delete"](cursor.primaryKey);
              cursor["continue"]();
            } else { // done
              count--;
              if (!count) { // done processing all revs
                // winningRev is not guaranteed to be there, since it's
                // not formally migrated. deletedOrLocal is a
                // now-unfortunate name that really just means "deleted"
                var winningRev = metadata.winningRev ||
                  merge.winningRev(metadata);
                var deleted = metadata.deletedOrLocal;
                txn.objectStore(DOC_STORE).put(
                  encodeMetadata(metadata, winningRev, deleted));
                deleteOrphanedAttachments();
              }
            }
          };
        };
      });
    };
    txn.onerror = idbError(callback);
    txn.oncomplete = function () {
      utils.call(callback);
    };
  };


  api._getLocal = function (id, callback) {
    var tx = idb.transaction([LOCAL_STORE], 'readonly');
    var req = tx.objectStore(LOCAL_STORE).get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var doc = e.target.result;
      if (!doc) {
        callback(errors.MISSING_DOC);
      } else {
        delete doc['_doc_id_rev'];
        callback(null, doc);
      }
    };
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;
    if (!oldRev) {
      doc._rev = '0-1';
    } else {
      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
    }
    doc._doc_id_rev = id + '::' + doc._rev;

    var tx = opts.ctx;
    var ret;
    if (!tx) {
      tx = idb.transaction([LOCAL_STORE], 'readwrite');
      tx.onerror = idbError(callback);
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }

    var oStore = tx.objectStore(LOCAL_STORE);
    var req;
    if (oldRev) {
      var index = oStore.index('_doc_id_rev');
      var docIdRev = id + '::' + oldRev;
      req = index.get(docIdRev);
      req.onsuccess = function (e) {
        if (!e.target.result) {
          callback(errors.REV_CONFLICT);
        } else { // update
          var req = oStore.put(doc);
          req.onsuccess = function () {
            ret = {ok: true, id: doc._id, rev: doc._rev};
            if (opts.ctx) { // retuthis.immediately
              callback(null, ret);
            }
          };
        }
      };
    } else { // new doc
      req = oStore.get(id);
      req.onsuccess = function (e) {
        if (e.target.result) { // already exists
          callback(errors.REV_CONFLICT);
        } else { // insert
          var req = oStore.put(doc);
          req.onsuccess = function () {
            ret = {ok: true, id: doc._id, rev: doc._rev};
            if (opts.ctx) { // return immediately
              callback(null, ret);
            }
          };
        }
      };
    }
  };

  api._removeLocal = function (doc, callback) {
    var tx = idb.transaction([LOCAL_STORE], 'readwrite');
    var ret;
    tx.oncomplete = function () {
      if (ret) {
        callback(null, ret);
      }
    };
    var docIdRev = doc._id + '::' + doc._rev;
    var oStore = tx.objectStore(LOCAL_STORE);
    var index = oStore.index('_doc_id_rev');
    var req = index.get(docIdRev);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var doc = e.target.result;
      if (!doc) {
        callback(errors.MISSING_DOC);
      } else {
        var req = index.getKey(docIdRev);
        req.onsuccess = function (e) {
          var key = e.target.result;
          oStore["delete"](key);
          ret = {ok: true, id: doc._id, rev: '0-0'};
        };
      }
    };
  };

  var cached = cachedDBs[name];

  if (cached) {
    idb = cached.idb;
    blobSupport = cached.blobSupport;
    instanceId = cached.instanceId;
    idStored = cached.idStored;
    process.nextTick(function () {
      callback(null, api);
    });
    return;
  }

  var req = global.indexedDB.open(name, ADAPTER_VERSION);

  if (!('openReqList' in IdbPouch)) {
    IdbPouch.openReqList = {};
  }
  IdbPouch.openReqList[name] = req;

  req.onupgradeneeded = function (e) {
    var db = e.target.result;
    if (e.oldVersion < 1) {
      createSchema(db); // new db, initial schema
      return;
    }
    // promises would be great here, IndexedDB. >_<
    var txn = e.currentTarget.transaction;
    if (e.oldVersion < 4) {
      addAttachAndSeqStore(db); // v4
      if (e.oldVersion < 3) {
        createLocalStoreSchema(db); // v3
        if (e.oldVersion < 2) {
          addDeletedOrLocalIndex(txn, function () { // v2
            migrateLocalStore(txn, function () { // v3
              migrateAttsAndSeqs(txn); // v4
            });
          });
        } else {
          migrateLocalStore(txn, function () { // v3
            migrateAttsAndSeqs(txn); // v4
          });
        }
      } else {
        migrateAttsAndSeqs(txn); // v4
      }
    }
  };

  req.onsuccess = function (e) {

    idb = e.target.result;

    idb.onversionchange = function () {
      idb.close();
      delete cachedDBs[name];
    };
    idb.onabort = function () {
      idb.close();
      delete cachedDBs[name];
    };

    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],
      'readwrite');

    var req = txn.objectStore(META_STORE).get(META_STORE);

    req.onsuccess = function (e) {

      var checkSetupComplete = function () {
        if (blobSupport === null || !idStored) {
          return;
        } else {
          cachedDBs[name] = {
            idb: idb,
            blobSupport: blobSupport,
            instanceId: instanceId,
            idStored: idStored,
            loaded: true
          };
          callback(null, api);
        }
      };

      var meta = e.target.result || {id: META_STORE};
      if (name  + '_id' in meta) {
        instanceId = meta[name + '_id'];
        idStored = true;
        checkSetupComplete();
      } else {
        instanceId = utils.uuid();
        meta[name + '_id'] = instanceId;
        txn.objectStore(META_STORE).put(meta).onsuccess = function () {
          idStored = true;
          checkSetupComplete();
        };
      }

      // Detect blob support. Chrome didn't support it until version 38.
      // in version 37 they had a broken version where PNGs (and possibly
      // other binary types) aren't stored correctly.
      try {
        var blob = utils.createBlob([''], {type: 'image/png'});
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
        txn.oncomplete = function () {
          // have to do it in a separate transaction, else the correct
          // content type is always returned
          txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],
            'readwrite');
          var getBlobReq = txn.objectStore(
            DETECT_BLOB_SUPPORT_STORE).get('key');
          getBlobReq.onsuccess = function (e) {
            var storedBlob = e.target.result;
            var url = URL.createObjectURL(storedBlob);
            utils.ajax({
              url: url,
              cache: true,
              binary: true
            }, function (err, res) {
              if (err && err.status === 405) {
                // firefox won't let us do that. but firefox doesn't
                // have the blob type bug that Chrome does, so that's ok
                blobSupport = true;
              } else {
                blobSupport = !!(res && res.type === 'image/png');
                if (err && err.status === 404) {
                  utils.explain404(
                    'PouchDB is just detecting blob URL support.');
                }
              }
              URL.revokeObjectURL(url);
              checkSetupComplete();
            });
          };
        };
      } catch (err) {
        blobSupport = false;
        checkSetupComplete();
      }
    };
  };

  req.onerror = idbError(callback);

}

IdbPouch.valid = function () {
  // Issue #2533, we finally gave up on doing bug
  // detection instead of browser sniffing. Safari brought us
  // to our knees.
  var isSafari = typeof openDatabase !== 'undefined' &&
    /Safari/.test(navigator.userAgent) &&
    !/Chrome/.test(navigator.userAgent);

  // some outdated implementations of IDB that appear on Samsung
  // and HTC Android devices <4.4 are missing IDBKeyRange
  return !isSafari && global.indexedDB && global.IDBKeyRange;
};

function destroy(name, opts, callback) {
  if (!('openReqList' in IdbPouch)) {
    IdbPouch.openReqList = {};
  }
  IdbPouch.Changes.removeAllListeners(name);

  //Close open request for "name" database to fix ie delay.
  if (IdbPouch.openReqList[name] && IdbPouch.openReqList[name].result) {
    IdbPouch.openReqList[name].result.close();
  }
  var req = global.indexedDB.deleteDatabase(name);

  req.onsuccess = function () {
    //Remove open request from the list.
    if (IdbPouch.openReqList[name]) {
      IdbPouch.openReqList[name] = null;
    }
    if (utils.hasLocalStorage() && (name in global.localStorage)) {
      delete global.localStorage[name];
    }
    delete cachedDBs[name];
    callback(null, { 'ok': true });
  };

  req.onerror = idbError(callback);
}

IdbPouch.destroy = utils.toPromise(function (name, opts, callback) {
  taskQueue.queue.push({
    action: function (thisCallback) {
      destroy(name, opts, thisCallback);
    },
    callback: callback
  });
  applyNext();
});

IdbPouch.Changes = new utils.Changes();

module.exports = IdbPouch;

}).call(this,_dereq_("/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../deps/errors":12,"../merge":21,"../utils":26,"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":31,"vuvuzela":61}],4:[function(_dereq_,module,exports){
module.exports = ['idb', 'websql'];
},{}],5:[function(_dereq_,module,exports){
(function (global){
'use strict';

var utils = _dereq_('../utils');
var merge = _dereq_('../merge');
var errors = _dereq_('../deps/errors');
var vuvuzela = _dereq_('vuvuzela');
var parseHexString = _dereq_('../deps/parse-hex');

function quote(str) {
  return "'" + str + "'";
}

// escapeBlob and unescapeBlob are workarounds for a websql bug:
// https://code.google.com/p/chromium/issues/detail?id=422690
// https://bugs.webkit.org/show_bug.cgi?id=137637
// The goal is to never actually insert the \u0000 character
// in the database.
function escapeBlob(str) {
  return str
    .replace(/\u0002/g, '\u0002\u0002')
    .replace(/\u0001/g, '\u0001\u0002')
    .replace(/\u0000/g, '\u0001\u0001');
}

function unescapeBlob(str) {
  return str
    .replace(/\u0001\u0001/g, '\u0000')
    .replace(/\u0001\u0002/g, '\u0001')
    .replace(/\u0002\u0002/g, '\u0002');
}

var cachedDatabases = {};

var openDB = utils.getArguments(function (args) {
  if (typeof global !== 'undefined') {
    if (global.navigator && global.navigator.sqlitePlugin &&
        global.navigator.sqlitePlugin.openDatabase) {
      return navigator.sqlitePlugin.openDatabase
        .apply(navigator.sqlitePlugin, args);
    } else if (global.sqlitePlugin && global.sqlitePlugin.openDatabase) {
      return global.sqlitePlugin.openDatabase
        .apply(global.sqlitePlugin, args);
    } else {
      var db = cachedDatabases[args[0]];
      if (!db) {
        db = cachedDatabases[args[0]] =
          global.openDatabase.apply(global, args);
      }
      return db;
    }
  }
});

var POUCH_VERSION = 1;
var ADAPTER_VERSION = 6; // used to manage migrations

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
var DOC_STORE = quote('document-store');
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
var BY_SEQ_STORE = quote('by-sequence');
// Where we store attachments
var ATTACH_STORE = quote('attach-store');
var LOCAL_STORE = quote('local-store');
var META_STORE = quote('metadata-store');
// where we store many-to-many relations between attachment
// digests and seqs
var ATTACH_AND_SEQ_STORE = quote('attach-seq-store');

// these indexes cover the ground for most allDocs queries
var BY_SEQ_STORE_DELETED_INDEX_SQL =
  'CREATE INDEX IF NOT EXISTS \'by-seq-deleted-idx\' ON ' +
  BY_SEQ_STORE + ' (seq, deleted)';
var BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =
  'CREATE UNIQUE INDEX IF NOT EXISTS \'by-seq-doc-id-rev\' ON ' +
    BY_SEQ_STORE + ' (doc_id, rev)';
var DOC_STORE_WINNINGSEQ_INDEX_SQL =
  'CREATE INDEX IF NOT EXISTS \'doc-winningseq-idx\' ON ' +
  DOC_STORE + ' (winningseq)';
var ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =
  'CREATE INDEX IF NOT EXISTS \'attach-seq-seq-idx\' ON ' +
    ATTACH_AND_SEQ_STORE + ' (seq)';
var ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =
  'CREATE UNIQUE INDEX IF NOT EXISTS \'attach-seq-digest-idx\' ON ' +
    ATTACH_AND_SEQ_STORE + ' (digest, seq)';

var DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE +
  '.seq = ' + DOC_STORE + '.winningseq';

var SELECT_DOCS = BY_SEQ_STORE + '.seq AS seq, ' +
  BY_SEQ_STORE + '.deleted AS deleted, ' +
  BY_SEQ_STORE + '.json AS data, ' +
  BY_SEQ_STORE + '.rev AS rev, ' +
  DOC_STORE + '.json AS metadata';

function select(selector, table, joiner, where, orderBy) {
  return 'SELECT ' + selector + ' FROM ' +
    (typeof table === 'string' ? table : table.join(' JOIN ')) +
    (joiner ? (' ON ' + joiner) : '') +
    (where ? (' WHERE ' +
      (typeof where === 'string' ? where : where.join(' AND '))) : '') +
    (orderBy ? (' ORDER BY ' + orderBy) : '');
}

function unknownError(callback) {
  return function (event) {
    // event may actually be a SQLError object, so report is as such
    var errorNameMatch = event && event.constructor.toString()
      .match(/function ([^\(]+)/);
    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;
    var errorReason = event.target || event.message;
    callback(errors.error(errors.WSQ_ERROR, errorReason, errorName));
  };
}

function stringifyDoc(doc) {
  // don't bother storing the id/rev. it uses lots of space,
  // in persistent map/reduce especially
  delete doc._id;
  delete doc._rev;
  return JSON.stringify(doc);
}

function unstringifyDoc(doc, id, rev) {
  doc = JSON.parse(doc);
  doc._id = id;
  doc._rev = rev;
  return doc;
}

function getSize(opts) {
  if ('size' in opts) {
    // triggers immediate popup in iOS, fixes #2347
    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,
    return opts.size * 1000000;
  }
  // In iOS, doesn't matter as long as it's <= 5000000.
  // Except that if you request too much, our tests fail
  // because of the native "do you accept?" popup.
  // In Android <=4.3, this value is actually used as an
  // honest-to-god ceiling for data, so we need to
  // set it to a decently high number.
  var isAndroid = /Android/.test(window.navigator.userAgent);
  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash
}

function WebSqlPouch(opts, callback) {
  var api = this;
  var instanceId = null;
  var name = opts.name;
  var size = getSize(opts);
  var idRequests = [];
  var docCount = -1; // cache sqlite count(*) for performance
  var encoding;

  var db = openDB(name, POUCH_VERSION, name, size);
  if (!db) {
    return callback(errors.UNKNOWN_ERROR);
  } else if (typeof db.readTransaction !== 'function') {
    // doesn't exist in sqlite plugin
    db.readTransaction = db.transaction;
  }

  function dbCreated() {
    // note the db name in case the browser upgrades to idb
    if (utils.hasLocalStorage()) {
      global.localStorage['_pouch__websqldb_' + name] = true;
    }
    callback(null, api);
  }

  // In this migration, we added the 'deleted' and 'local' columns to the
  // by-seq and doc store tables.
  // To preserve existing user data, we re-process all the existing JSON
  // and add these values.
  // Called migration2 because it corresponds to adapter version (db_version) #2
  function runMigration2(tx, callback) {
    // index used for the join in the allDocs query
    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);

    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE +
      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {
      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
      tx.executeSql('ALTER TABLE ' + DOC_STORE +
        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {
        tx.executeSql('CREATE INDEX IF NOT EXISTS \'doc-store-local-idx\' ON ' +
          DOC_STORE + ' (local, id)');

        var sql = 'SELECT ' + DOC_STORE + '.winningseq AS seq, ' + DOC_STORE +
          '.json AS metadata FROM ' + BY_SEQ_STORE + ' JOIN ' + DOC_STORE +
          ' ON ' + BY_SEQ_STORE + '.seq = ' + DOC_STORE + '.winningseq';

        tx.executeSql(sql, [], function (tx, result) {

          var deleted = [];
          var local = [];

          for (var i = 0; i < result.rows.length; i++) {
            var item = result.rows.item(i);
            var seq = item.seq;
            var metadata = JSON.parse(item.metadata);
            if (utils.isDeleted(metadata)) {
              deleted.push(seq);
            }
            if (utils.isLocalId(metadata.id)) {
              local.push(metadata.id);
            }
          }
          tx.executeSql('UPDATE ' + DOC_STORE + 'SET local = 1 WHERE id IN (' +
            local.map(function () {
            return '?';
          }).join(',') + ')', local, function () {
            tx.executeSql('UPDATE ' + BY_SEQ_STORE +
              ' SET deleted = 1 WHERE seq IN (' + deleted.map(function () {
              return '?';
            }).join(',') + ')', deleted, callback);
          });
        });
      });
    });
  }

  // in this migration, we make all the local docs unversioned
  function runMigration3(tx, callback) {
    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE +
      ' (id UNIQUE, rev, json)';
    tx.executeSql(local, [], function () {
      var sql = 'SELECT ' + DOC_STORE + '.id AS id, ' +
        BY_SEQ_STORE + '.json AS data ' +
        'FROM ' + BY_SEQ_STORE + ' JOIN ' +
        DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +
        DOC_STORE + '.winningseq WHERE local = 1';
      tx.executeSql(sql, [], function (tx, res) {
        var rows = [];
        for (var i = 0; i < res.rows.length; i++) {
          rows.push(res.rows.item(i));
        }
        function doNext() {
          if (!rows.length) {
            return callback(tx);
          }
          var row = rows.shift();
          var rev = JSON.parse(row.data)._rev;
          tx.executeSql('INSERT INTO ' + LOCAL_STORE +
              ' (id, rev, json) VALUES (?,?,?)',
              [row.id, rev, row.data], function (tx) {
            tx.executeSql('DELETE FROM ' + DOC_STORE + ' WHERE id=?',
                [row.id], function (tx) {
              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE + ' WHERE seq=?',
                  [row.seq], function () {
                doNext();
              });
            });
          });
        }
        doNext();
      });
    });
  }

  // in this migration, we remove doc_id_rev and just use rev
  function runMigration4(tx, callback) {

    function updateRows(rows) {
      function doNext() {
        if (!rows.length) {
          return callback(tx);
        }
        var row = rows.shift();
        var doc_id_rev = parseHexString(row.hex, encoding);
        var idx = doc_id_rev.lastIndexOf('::');
        var doc_id = doc_id_rev.substring(0, idx);
        var rev = doc_id_rev.substring(idx + 2);
        var sql = 'UPDATE ' + BY_SEQ_STORE +
          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';
        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {
          doNext();
        });
      }
      doNext();
    }

    var sql = 'ALTER TABLE ' + BY_SEQ_STORE + ' ADD COLUMN doc_id';
    tx.executeSql(sql, [], function (tx) {
      var sql = 'ALTER TABLE ' + BY_SEQ_STORE + ' ADD COLUMN rev';
      tx.executeSql(sql, [], function (tx) {
        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {
          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE;
          tx.executeSql(sql, [], function (tx, res) {
            var rows = [];
            for (var i = 0; i < res.rows.length; i++) {
              rows.push(res.rows.item(i));
            }
            updateRows(rows);
          });
        });
      });
    });
  }

  // in this migration, we add the attach_and_seq table
  // for issue #2818
  function runMigration5(tx, callback) {

    function migrateAttsAndSeqs(tx) {
      // need to actually populate the table. this is the expensive part,
      // so as an optimization, check first that this database even
      // contains attachments
      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE;
      tx.executeSql(sql, [], function (tx, res) {
        var count = res.rows.item(0).cnt;
        if (!count) {
          return callback(tx);
        }

        var offset = 0;
        var pageSize = 10;
        function nextPage() {
          var sql = select(
            SELECT_DOCS + ', ' + DOC_STORE + '.id AS id',
            [DOC_STORE, BY_SEQ_STORE],
            DOC_STORE_AND_BY_SEQ_JOINER,
            null,
            DOC_STORE + '.id '
          );
          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;
          offset += pageSize;
          tx.executeSql(sql, [], function (tx, res) {
            if (!res.rows.length) {
              return callback(tx);
            }
            var digestSeqs = {};
            function addDigestSeq(digest, seq) {
              // uniq digest/seq pairs, just in case there are dups
              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);
              if (seqs.indexOf(seq) === -1) {
                seqs.push(seq);
              }
            }
            for (var i = 0; i < res.rows.length; i++) {
              var row = res.rows.item(i);
              var doc = unstringifyDoc(row.data, row.id, row.rev);
              var atts = Object.keys(doc._attachments || {});
              for (var j = 0; j < atts.length; j++) {
                var att = doc._attachments[atts[j]];
                addDigestSeq(att.digest, row.seq);
              }
            }
            var digestSeqPairs = [];
            Object.keys(digestSeqs).forEach(function (digest) {
              var seqs = digestSeqs[digest];
              seqs.forEach(function (seq) {
                digestSeqPairs.push([digest, seq]);
              });
            });
            if (!digestSeqPairs.length) {
              return nextPage();
            }
            var numDone = 0;
            digestSeqPairs.forEach(function (pair) {
              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE +
                ' (digest, seq) VALUES (?,?)';
              tx.executeSql(sql, pair, function () {
                if (++numDone === digestSeqPairs.length) {
                  nextPage();
                }
              });
            });
          });
        }
        nextPage();
      });
    }

    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +
      ATTACH_AND_SEQ_STORE + ' (digest, seq INTEGER)';
    tx.executeSql(attachAndRev, [], function (tx) {
      tx.executeSql(
        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {
          tx.executeSql(
            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],
            migrateAttsAndSeqs);
        });
    });
  }

  // in this migration, we use escapeBlob() and unescapeBlob()
  // instead of reading out the binary as HEX, which is slow
  function runMigration6(tx, callback) {
    var sql = 'ALTER TABLE ' + ATTACH_STORE +
      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';
    tx.executeSql(sql, [], callback);
  }

  function checkEncoding(tx, cb) {
    // UTF-8 on chrome/android, UTF-16 on safari < 7.1
    tx.executeSql('SELECT HEX("a") AS hex', [], function (tx, res) {
        var hex = res.rows.item(0).hex;
        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';
        cb();
      }
    );
  }

  function onGetInstanceId() {
    while (idRequests.length > 0) {
      var idCallback = idRequests.pop();
      idCallback(null, instanceId);
    }
  }

  function onGetVersion(tx, dbVersion) {
    if (dbVersion === 0) {
      // initial schema

      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +
        ' (dbid, db_version INTEGER)';
      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +
        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';
      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +
        ATTACH_AND_SEQ_STORE + ' (digest, seq INTEGER)';
      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +
        ' (id unique, json, winningseq)';
      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +
        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +
        'json, deleted TINYINT(1), doc_id, rev)';
      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE +
        ' (id UNIQUE, rev, json)';

      // creates
      tx.executeSql(attach);
      tx.executeSql(local);
      tx.executeSql(attachAndRev, [], function () {
        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);
        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);
      });
      tx.executeSql(doc, [], function () {
        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);
        tx.executeSql(seq, [], function () {
          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);
          tx.executeSql(meta, [], function () {
            // mark the db version, and new dbid
            var initSeq = 'INSERT INTO ' + META_STORE +
              ' (db_version, dbid) VALUES (?,?)';
            instanceId = utils.uuid();
            var initSeqArgs = [ADAPTER_VERSION, instanceId];
            tx.executeSql(initSeq, initSeqArgs, function (tx) {
              onGetInstanceId();
            });
          });
        });
      });
    } else { // version > 0

      var setupDone = function () {
        var migrated = dbVersion < ADAPTER_VERSION;
        if (migrated) {
          // update the db version within this transaction
          tx.executeSql('UPDATE ' + META_STORE + ' SET db_version = ' +
            ADAPTER_VERSION);
        }
        // notify db.id() callers
        var sql = 'SELECT dbid FROM ' + META_STORE;
        tx.executeSql(sql, [], function (tx, result) {
          instanceId = result.rows.item(0).dbid;
          onGetInstanceId();
        });
      };

      // would love to use promises here, but then websql
      // ends the transaction early
      var tasks = [
        runMigration2,
        runMigration3,
        runMigration4,
        runMigration5,
        runMigration6,
        setupDone
      ];

      // run each migration sequentially
      var i = dbVersion;
      var nextMigration = function (tx) {
        tasks[i - 1](tx, nextMigration);
        i++;
      };
      nextMigration(tx);
    }
  }

  function setup() {
    db.transaction(function (tx) {
      // first check the encoding
      checkEncoding(tx, function () {
        // then get the version
        fetchVersion(tx);
      });
    }, unknownError(callback), dbCreated);
  }

  function fetchVersion(tx) {
    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE;
    tx.executeSql(sql, [], function (tx, result) {
      if (!result.rows.length) {
        // database hasn't even been created yet (version 0)
        onGetVersion(tx, 0);
      } else if (!/db_version/.test(result.rows.item(0).sql)) {
        // table was created, but without the new db_version column,
        // so add it.
        tx.executeSql('ALTER TABLE ' + META_STORE +
          ' ADD COLUMN db_version INTEGER', [], function () {
          // before version 2, this column didn't even exist
          onGetVersion(tx, 1);
        });
      } else { // column exists, we can safely get it
        tx.executeSql('SELECT db_version FROM ' + META_STORE,
          [], function (tx, result) {
          var dbVersion = result.rows.item(0).db_version;
          onGetVersion(tx, dbVersion);
        });
      }
    });
  }

  if (utils.isCordova() && typeof global !== 'undefined') {
    //to wait until custom api is made in pouch.adapters before doing setup
    global.addEventListener(name + '_pouch', function cordova_init() {
      global.removeEventListener(name + '_pouch', cordova_init, false);
      setup();
    }, false);
  } else {
    setup();
  }

  api.type = function () {
    return 'websql';
  };

  api._id = utils.toPromise(function (callback) {
    callback(null, instanceId);
  });

  api._info = function (callback) {
    db.readTransaction(function (tx) {
      countDocs(tx, function (docCount) {
        var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE;
        tx.executeSql(sql, [], function (tx, res) {
          var updateSeq = res.rows.item(0).seq || 0;
          callback(null, {
            doc_count: docCount,
            update_seq: updateSeq
          });
        });
      });
    }, unknownError(callback));
  };

  api._bulkDocs = function (req, opts, callback) {

    var newEdits = opts.new_edits;
    var userDocs = req.docs;

    // Parse the docs, give them a sequence number for the result
    var docInfos = userDocs.map(function (doc, i) {
      if (doc._id && utils.isLocalId(doc._id)) {
        return doc;
      }
      var newDoc = utils.parseDoc(doc, newEdits);
      newDoc._bulk_seq = i;
      return newDoc;
    });

    var docInfoErrors = docInfos.filter(function (docInfo) {
      return docInfo.error;
    });
    if (docInfoErrors.length) {
      return callback(docInfoErrors[0]);
    }

    var tx;
    var results = new Array(docInfos.length);
    var fetchedDocs = new utils.Map();
    var numDocsWritten = 0;

    function complete() {
      var aresults = results.map(function (result) {
        if (result._bulk_seq) {
          delete result._bulk_seq;
        } else if (!Object.keys(result).length) {
          return {
            ok: true
          };
        }
        if (result.error) {
          return result;
        }

        var metadata = result.metadata;
        var rev = merge.winningRev(metadata);

        return {
          ok: true,
          id: metadata.id,
          rev: rev
        };
      });
      WebSqlPouch.Changes.notify(name);

      callback(null, aresults);
    }

    function verifyAttachment(digest, callback) {
      var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE +
        ' WHERE digest=?';
      tx.executeSql(sql, [digest], function (tx, result) {
        if (result.rows.item(0).cnt === 0) {
          var err = new Error('unknown stub attachment with digest ' + digest);
          err.status = 412;
          callback(err);
        } else {
          callback();
        }
      });
    }

    function verifyAttachments(finish) {
      var digests = [];
      docInfos.forEach(function (docInfo) {
        if (docInfo.data && docInfo.data._attachments) {
          Object.keys(docInfo.data._attachments).forEach(function (filename) {
            var att = docInfo.data._attachments[filename];
            if (att.stub) {
              digests.push(att.digest);
            }
          });
        }
      });
      if (!digests.length) {
        return finish();
      }
      var numDone = 0;
      var err;

      function checkDone() {
        if (++numDone === digests.length) {
          finish(err);
        }
      }
      digests.forEach(function (digest) {
        verifyAttachment(digest, function (attErr) {
          if (attErr && !err) {
            err = attErr;
          }
          checkDone();
        });
      });
    }

    function preprocessAttachment(att, finish) {
      if (att.stub) {
        return finish();
      }
      if (typeof att.data === 'string') {
        try {
          att.data = atob(att.data);
        } catch (e) {
          var err = errors.error(errors.BAD_ARG,
                                "Attachments need to be base64 encoded");
          return callback(err);
        }
        var data = utils.fixBinary(att.data);
        att.data = utils.createBlob([data], {type: att.content_type});
      }
      utils.readAsBinaryString(att.data, function (binary) {
        att.data = binary;
        utils.MD5(binary).then(function (result) {
          att.digest = 'md5-' + result;
          att.length = binary.length;
          finish();
        });
      });
    }

    function preprocessAttachments(callback) {
      if (!docInfos.length) {
        return callback();
      }

      var docv = 0;

      docInfos.forEach(function (docInfo) {
        var attachments = docInfo.data && docInfo.data._attachments ?
          Object.keys(docInfo.data._attachments) : [];
        var recv = 0;

        if (!attachments.length) {
          return done();
        }

        function processedAttachment() {
          recv++;
          if (recv === attachments.length) {
            done();
          }
        }

        for (var key in docInfo.data._attachments) {
          if (docInfo.data._attachments.hasOwnProperty(key)) {
            preprocessAttachment(docInfo.data._attachments[key],
                                 processedAttachment);
          }
        }
      });

      function done() {
        docv++;
        if (docInfos.length === docv) {
          callback();
        }
      }
    }

    function writeDoc(docInfo, winningRev, deleted, callback, isUpdate,
                      resultsIdx) {

      function finish() {
        var data = docInfo.data;
        var deletedInt = deleted ? 1 : 0;

        var id = data._id;
        var rev = data._rev;
        var json = stringifyDoc(data);
        var sql = 'INSERT INTO ' + BY_SEQ_STORE +
          ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';
        var sqlArgs = [id, rev, json, deletedInt];

        // map seqs to attachment digests, which
        // we will need later during compaction
        function insertAttachmentMappings(seq, callback) {
          var attsAdded = 0;
          var attsToAdd = Object.keys(data._attachments || {});

          if (!attsToAdd.length) {
            return callback();
          }
          function checkDone() {
            if (++attsAdded === attsToAdd.length) {
              callback();
            }
            return false; // ack handling a constraint error
          }
          function add(att) {
            var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE +
              ' (digest, seq) VALUES (?,?)';
            var sqlArgs = [data._attachments[att].digest, seq];
            tx.executeSql(sql, sqlArgs, checkDone, checkDone);
            // second callback is for a constaint error, which we ignore
            // because this docid/rev has already been associated with
            // the digest (e.g. when new_edits == false)
          }
          for (var i = 0; i < attsToAdd.length; i++) {
            add(attsToAdd[i]); // do in parallel
          }
        }

        tx.executeSql(sql, sqlArgs, function (tx, result) {
          var seq = result.insertId;
          insertAttachmentMappings(seq, function () {
            dataWritten(tx, seq);
          });
        }, function () {
          // constraint error, recover by updating instead (see #1638)
          var fetchSql = select('seq', BY_SEQ_STORE, null,
            'doc_id=? AND rev=?');
          tx.executeSql(fetchSql, [id, rev], function (tx, res) {
            var seq = res.rows.item(0).seq;
            var sql = 'UPDATE ' + BY_SEQ_STORE +
              ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';
            var sqlArgs = [json, deletedInt, id, rev];
            tx.executeSql(sql, sqlArgs, function (tx) {
              insertAttachmentMappings(seq, function () {
                dataWritten(tx, seq);
              });
            });
          });
          return false; // ack that we've handled the error
        });
      }

      function collectResults(attachmentErr) {
        if (!err) {
          if (attachmentErr) {
            err = attachmentErr;
            callback(err);
          } else if (recv === attachments.length) {
            finish();
          }
        }
      }

      var err = null;
      var recv = 0;

      docInfo.data._id = docInfo.metadata.id;
      docInfo.data._rev = docInfo.metadata.rev;

      if (deleted) {
        docInfo.data._deleted = true;
      }

      var attachments = docInfo.data._attachments ?
        Object.keys(docInfo.data._attachments) : [];

      function attachmentSaved(err) {
        recv++;
        collectResults(err);
      }

      for (var key in docInfo.data._attachments) {
        if (!docInfo.data._attachments[key].stub) {
          var data = docInfo.data._attachments[key].data;
          delete docInfo.data._attachments[key].data;
          var digest = docInfo.data._attachments[key].digest;
          saveAttachment(digest, data, attachmentSaved);
        } else {
          recv++;
          collectResults();
        }
      }

      if (!attachments.length) {
        finish();
      }

      function dataWritten(tx, seq) {
        docInfo.metadata.seq = seq;
        delete docInfo.metadata.rev;

        var sql = isUpdate ?
          'UPDATE ' + DOC_STORE +
          ' SET json=?, winningseq=(SELECT seq FROM ' + BY_SEQ_STORE +
          ' WHERE doc_id=' + DOC_STORE + '.id AND rev=?) WHERE id=?'
          : 'INSERT INTO ' + DOC_STORE +
          ' (id, winningseq, json) VALUES (?, ?, ?);';
        var metadataStr = vuvuzela.stringify(docInfo.metadata);
        var id = docInfo.metadata.id;
        var params = isUpdate ?
          [metadataStr, winningRev, id] :
          [id, seq, metadataStr];
        tx.executeSql(sql, params, function () {
          results[resultsIdx] = docInfo;
          fetchedDocs.set(id, docInfo.metadata);
          callback();
        });
      }
    }

    function updateDoc(oldDoc, docInfo, resultsIdx, callback) {

      if (utils.revExists(oldDoc, docInfo.metadata.rev)) {
        results[resultsIdx] = docInfo;
        callback();
        return;
      }

      var merged =
        merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);

      var previouslyDeleted = utils.isDeleted(oldDoc);
      var deleted = utils.isDeleted(docInfo.metadata);
      var inConflict = (previouslyDeleted && deleted && newEdits) ||
        (!previouslyDeleted && newEdits && merged.conflicts !== 'new_leaf') ||
        (previouslyDeleted && !deleted && merged.conflicts === 'new_branch');

      if (inConflict) {
        results[resultsIdx] = makeErr(errors.REV_CONFLICT, docInfo._bulk_seq);
        return callback();
      }

      docInfo.metadata.rev_tree = merged.tree;

      // recalculate
      var winningRev = merge.winningRev(docInfo.metadata);
      deleted = utils.isDeleted(docInfo.metadata, winningRev);

      writeDoc(docInfo, winningRev, deleted, callback, true, resultsIdx);
    }

    function insertDoc(docInfo, resultsIdx, callback) {
      // Cant insert new deleted documents
      var winningRev = merge.winningRev(docInfo.metadata);
      var deleted = utils.isDeleted(docInfo.metadata, winningRev);
      if ('was_delete' in opts && deleted) {
        results[resultsIdx] = errors.MISSING_DOC;
        return callback();
      }
      writeDoc(docInfo, winningRev, deleted, callback, false, resultsIdx);
    }

    function checkDoneWritingDocs() {
      if (++numDocsWritten === docInfos.length) {
        complete();
      }
    }

    function processDocs() {
      if (!docInfos.length) {
        return complete();
      }

      var idsToDocs = new utils.Map();

      docInfos.forEach(function (currentDoc, resultsIdx) {

        if (currentDoc._id && utils.isLocalId(currentDoc._id)) {
          api[currentDoc._deleted ? '_removeLocal' : '_putLocal'](
              currentDoc, {ctx: tx}, function (err, resp) {
            if (err) {
              results[resultsIdx] = err;
            } else {
              results[resultsIdx] = {};
            }
            checkDoneWritingDocs();
          });
          return;
        }

        var id = currentDoc.metadata.id;
        if (idsToDocs.has(id)) {
          idsToDocs.get(id).push([currentDoc, resultsIdx]);
        } else {
          idsToDocs.set(id, [[currentDoc, resultsIdx]]);
        }
      });

      // in the case of new_edits, the user can provide multiple docs
      // with the same id. these need to be processed sequentially
      idsToDocs.forEach(function (docs, id) {
        var numDone = 0;

        function docWritten() {
          checkDoneWritingDocs();
          if (++numDone < docs.length) {
            nextDoc();
          }
        }
        function nextDoc() {
          var value = docs[numDone];
          var currentDoc = value[0];
          var resultsIdx = value[1];

          if (fetchedDocs.has(id)) {
            updateDoc(fetchedDocs.get(id), currentDoc, resultsIdx, docWritten);
          } else {
            insertDoc(currentDoc, resultsIdx, docWritten);
          }
        }
        nextDoc();
      });
    }

    function fetchExistingDocs(callback) {
      if (!docInfos.length) {
        return callback();
      }

      var numFetched = 0;

      function checkDone() {
        if (++numFetched === docInfos.length) {
          callback();
        }
      }

      docInfos.forEach(function (docInfo) {
        if (docInfo._id && utils.isLocalId(docInfo._id)) {
          return checkDone(); // skip local docs
        }
        var id = docInfo.metadata.id;
        tx.executeSql('SELECT json FROM ' + DOC_STORE +
          ' WHERE id = ?', [id], function (tx, result) {
          if (result.rows.length) {
            var metadata = vuvuzela.parse(result.rows.item(0).json);
            fetchedDocs.set(id, metadata);
          }
          checkDone();
        });
      });
    }

    // Insert sequence number into the error so we can sort later
    function makeErr(err, seq) {
      err._bulk_seq = seq;
      return err;
    }

    function saveAttachment(digest, data, callback) {
      var sql = 'SELECT digest FROM ' + ATTACH_STORE + ' WHERE digest=?';
      tx.executeSql(sql, [digest], function (tx, result) {
        if (result.rows.length) { // attachment already exists
          return callback();
        }
        // we could just insert before selecting and catch the error,
        // but my hunch is that it's cheaper not to serialize the blob
        // from JS to C if we don't have to (TODO: confirm this)
        sql = 'INSERT INTO ' + ATTACH_STORE +
          ' (digest, body, escaped) VALUES (?,?,1)';
        tx.executeSql(sql, [digest, escapeBlob(data)], function () {
          callback();
        }, function () {
          // ignore constaint errors, means it already exists
          callback();
          return false; // ack we handled the error
        });
      });
    }

    preprocessAttachments(function () {
      db.transaction(function (txn) {
        tx = txn;
        verifyAttachments(function (err) {
          if (err) {
            return callback(err);
          }
          fetchExistingDocs(processDocs);
        });
      }, unknownError(callback), function () {
        docCount = -1;
      });
    });
  };

  api._get = function (id, opts, callback) {
    opts = utils.clone(opts);
    var doc;
    var metadata;
    var err;
    if (!opts.ctx) {
      db.readTransaction(function (txn) {
        opts.ctx = txn;
        api._get(id, opts, callback);
      });
      return;
    }
    var tx = opts.ctx;

    function finish() {
      callback(err, {doc: doc, metadata: metadata, ctx: tx});
    }

    var sql;
    var sqlArgs;
    if (opts.rev) {
      sql = select(
        SELECT_DOCS,
        [DOC_STORE, BY_SEQ_STORE],
        DOC_STORE + '.id=' + BY_SEQ_STORE + '.doc_id',
        [BY_SEQ_STORE + '.doc_id=?', BY_SEQ_STORE + '.rev=?']);
      sqlArgs = [id, opts.rev];
    } else {
      sql = select(
        SELECT_DOCS,
        [DOC_STORE, BY_SEQ_STORE],
        DOC_STORE_AND_BY_SEQ_JOINER,
        DOC_STORE + '.id=?');
      sqlArgs = [id];
    }
    tx.executeSql(sql, sqlArgs, function (a, results) {
      if (!results.rows.length) {
        err = errors.MISSING_DOC;
        return finish();
      }
      var item = results.rows.item(0);
      metadata = vuvuzela.parse(item.metadata);
      if (item.deleted && !opts.rev) {
        err = errors.error(errors.MISSING_DOC, 'deleted');
        return finish();
      }
      doc = unstringifyDoc(item.data, metadata.id, item.rev);
      finish();
    });
  };

  function countDocs(tx, callback) {

    if (docCount !== -1) {
      return callback(docCount);
    }

    // count the total rows
    var sql = select(
      'COUNT(' + DOC_STORE + '.id) AS \'num\'',
      [DOC_STORE, BY_SEQ_STORE],
      DOC_STORE_AND_BY_SEQ_JOINER,
      BY_SEQ_STORE + '.deleted=0');

    tx.executeSql(sql, [], function (tx, result) {
      docCount = result.rows.item(0).num;
      callback(docCount);
    });
  }

  api._allDocs = function (opts, callback) {
    var results = [];
    var totalRows;

    var start = 'startkey' in opts ? opts.startkey : false;
    var end = 'endkey' in opts ? opts.endkey : false;
    var key = 'key' in opts ? opts.key : false;
    var descending = 'descending' in opts ? opts.descending : false;
    var limit = 'limit' in opts ? opts.limit : -1;
    var offset = 'skip' in opts ? opts.skip : 0;
    var inclusiveEnd = opts.inclusive_end !== false;

    var sqlArgs = [];
    var criteria = [];

    if (key !== false) {
      criteria.push(DOC_STORE + '.id = ?');
      sqlArgs.push(key);
    } else if (start !== false || end !== false) {
      if (start !== false) {
        criteria.push(DOC_STORE + '.id ' + (descending ? '<=' : '>=') + ' ?');
        sqlArgs.push(start);
      }
      if (end !== false) {
        var comparator = descending ? '>' : '<';
        if (inclusiveEnd) {
          comparator += '=';
        }
        criteria.push(DOC_STORE + '.id ' + comparator + ' ?');
        sqlArgs.push(end);
      }
      if (key !== false) {
        criteria.push(DOC_STORE + '.id = ?');
        sqlArgs.push(key);
      }
    }

    if (opts.deleted !== 'ok') {
      // report deleted if keys are specified
      criteria.push(BY_SEQ_STORE + '.deleted = 0');
    }

    db.readTransaction(function (tx) {

      // first count up the total rows
      countDocs(tx, function (count) {
        totalRows = count;

        if (limit === 0) {
          return;
        }

        // then actually fetch the documents
        var sql = select(
          SELECT_DOCS,
          [DOC_STORE, BY_SEQ_STORE],
          DOC_STORE_AND_BY_SEQ_JOINER,
          criteria,
          DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC')
          );
        sql += ' LIMIT ' + limit + ' OFFSET ' + offset;

        tx.executeSql(sql, sqlArgs, function (tx, result) {
          for (var i = 0, l = result.rows.length; i < l; i++) {
            var item = result.rows.item(i);
            var metadata = vuvuzela.parse(item.metadata);
            var data = unstringifyDoc(item.data, metadata.id, item.rev);
            var winningRev = data._rev;
            var doc = {
              id: metadata.id,
              key: metadata.id,
              value: {rev: winningRev}
            };
            if (opts.include_docs) {
              doc.doc = data;
              doc.doc._rev = winningRev;
              if (opts.conflicts) {
                doc.doc._conflicts = merge.collectConflicts(metadata);
              }
              for (var att in doc.doc._attachments) {
                if (doc.doc._attachments.hasOwnProperty(att)) {
                  doc.doc._attachments[att].stub = true;
                }
              }
            }
            if (item.deleted) {
              if (opts.deleted === 'ok') {
                doc.value.deleted = true;
                doc.doc = null;
              } else {
                continue;
              }
            }
            results.push(doc);
          }
        });
      });
    }, unknownError(callback), function () {
      callback(null, {
        total_rows: totalRows,
        offset: opts.skip,
        rows: results
      });
    });
  };

  api._changes = function (opts) {
    opts = utils.clone(opts);

    if (opts.continuous) {
      var id = name + ':' + utils.uuid();
      WebSqlPouch.Changes.addListener(name, id, api, opts);
      WebSqlPouch.Changes.notify(name);
      return {
        cancel: function () {
          WebSqlPouch.Changes.removeListener(name, id);
        }
      };
    }

    var descending = opts.descending;

    // Ignore the `since` parameter when `descending` is true
    opts.since = opts.since && !descending ? opts.since : 0;

    var limit = 'limit' in opts ? opts.limit : -1;
    if (limit === 0) {
      limit = 1; // per CouchDB _changes spec
    }

    var returnDocs;
    if ('returnDocs' in opts) {
      returnDocs = opts.returnDocs;
    } else {
      returnDocs = true;
    }
    var results = [];
    var numResults = 0;
    function fetchChanges() {

      var criteria = [
        DOC_STORE + '.winningseq > ' + opts.since
      ];
      var sqlArgs = [];
      if (opts.doc_ids) {
        criteria.push(DOC_STORE + '.id IN (' + opts.doc_ids.map(function () {
          return '?';
        }).join(',') + ')');
        sqlArgs = opts.doc_ids;
      }

      var sql = select(SELECT_DOCS, [DOC_STORE, BY_SEQ_STORE],
        DOC_STORE_AND_BY_SEQ_JOINER, criteria,
        DOC_STORE + '.winningseq ' + (descending ? 'DESC' : 'ASC'));

      var filter = utils.filterChange(opts);
      if (!opts.view && !opts.filter) {
        // we can just limit in the query
        sql += ' LIMIT ' + limit;
      }

      db.readTransaction(function (tx) {
        tx.executeSql(sql, sqlArgs, function (tx, result) {
          var lastSeq = 0;
          for (var i = 0, l = result.rows.length; i < l; i++) {
            var res = result.rows.item(i);
            var metadata = vuvuzela.parse(res.metadata);
            if (lastSeq < res.seq) {
              lastSeq = res.seq;
            }
            var doc = unstringifyDoc(res.data, metadata.id, res.rev);
            var change = opts.processChange(doc, metadata, opts);
            change.seq = res.seq;
            if (filter(change)) {
              numResults++;
              if (returnDocs) {
                results.push(change);
              }
              opts.onChange(change);
            }
            if (numResults === limit) {
              break;
            }
          }
          if (!opts.continuous) {
            opts.complete(null, {
              results: results,
              last_seq: lastSeq
            });
          }
        });
      });
    }

    fetchChanges();
  };

  api._close = function (callback) {
    //WebSQL databases do not need to be closed
    callback();
  };

  api._getAttachment = function (attachment, opts, callback) {
    var res;
    var tx = opts.ctx;
    var digest = attachment.digest;
    var type = attachment.content_type;
    var sql = 'SELECT escaped, ' +
      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +
      ATTACH_STORE + ' WHERE digest=?';
    tx.executeSql(sql, [digest], function (tx, result) {
      // websql has a bug where \u0000 causes early truncation in strings
      // and blobs. to work around this, we used to use the hex() function,
      // but that's not performant. after migration 6, we remove \u0000
      // and add it back in afterwards
      var item = result.rows.item(0);
      var data = item.escaped ? unescapeBlob(item.body) :
        parseHexString(item.body, encoding);
      if (opts.encode) {
        res = btoa(data);
      } else {
        data = utils.fixBinary(data);
        res = utils.createBlob([data], {type: type});
      }
      callback(null, res);
    });
  };

  api._getRevisionTree = function (docId, callback) {
    db.readTransaction(function (tx) {
      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';
      tx.executeSql(sql, [docId], function (tx, result) {
        if (!result.rows.length) {
          callback(errors.MISSING_DOC);
        } else {
          var data = vuvuzela.parse(result.rows.item(0).metadata);
          callback(null, data.rev_tree);
        }
      });
    });
  };

  api._doCompaction = function (docId, revs, callback) {
    if (!revs.length) {
      return callback();
    }
    db.transaction(function (tx) {

      // update doc store
      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';
      tx.executeSql(sql, [docId], function (tx, result) {
        var metadata = vuvuzela.parse(result.rows.item(0).metadata);
        merge.traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                           revHash, ctx, opts) {
          var rev = pos + '-' + revHash;
          if (revs.indexOf(rev) !== -1) {
            opts.status = 'missing';
          }
        });

        var sql = 'UPDATE ' + DOC_STORE + ' SET json = ? WHERE id = ?';
        tx.executeSql(sql, [vuvuzela.stringify(metadata), docId]);
      });

      // update by-seq and attach stores in parallel
      revs.forEach(function (rev) {
        var sql = 'SELECT seq FROM ' + BY_SEQ_STORE +
          ' WHERE doc_id=? AND rev=?';
        tx.executeSql(sql, [docId, rev], function (tx, res) {
          if (!res.rows.length) {
            return; // already deleted
          }
          var seq = res.rows.item(0).seq;

          // find orphaned attachment digests
          var sql = 'SELECT a1.digest AS digest ' +
              'FROM ' + ATTACH_AND_SEQ_STORE + ' a1 JOIN ' +
              ATTACH_AND_SEQ_STORE + ' a2 ON a1.digest=a2.digest ' +
              'WHERE a1.seq=? ' +
              'GROUP BY a1.digest HAVING COUNT(*) = 1';
          tx.executeSql(sql, [seq], function (tx, res) {
            var orphanedAttachments = [];
            for (var i = 0; i < res.rows.length; i++) {
              orphanedAttachments.push(res.rows.item(i).digest);
            }

            tx.executeSql(
              'DELETE FROM ' + BY_SEQ_STORE + ' WHERE seq=?', [seq]);
            tx.executeSql(
              'DELETE FROM ' + ATTACH_AND_SEQ_STORE + ' WHERE seq=?', [seq]);
            orphanedAttachments.forEach(function (digest) {
              tx.executeSql(
                'DELETE FROM ' + ATTACH_AND_SEQ_STORE + ' WHERE digest=?',
                [digest]);
              tx.executeSql(
                'DELETE FROM ' + ATTACH_STORE + ' WHERE digest=?', [digest]);
            });
          });
        });
      });
    }, unknownError(callback), function () {
      callback();
    });
  };

  api._getLocal = function (id, callback) {
    db.readTransaction(function (tx) {
      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE + ' WHERE id=?';
      tx.executeSql(sql, [id], function (tx, res) {
        if (res.rows.length) {
          var item = res.rows.item(0);
          var doc = unstringifyDoc(item.json, id, item.rev);
          callback(null, doc);
        } else {
          callback(errors.MISSING_DOC);
        }
      });
    });
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;
    var newRev;
    if (!oldRev) {
      newRev = doc._rev = '0-1';
    } else {
      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
    }
    var json = stringifyDoc(doc);

    var ret;
    function putLocal(tx) {
      var sql;
      var values;
      if (oldRev) {
        sql = 'UPDATE ' + LOCAL_STORE + ' SET rev=?, json=? ' +
          'WHERE id=? AND rev=?';
        values = [newRev, json, id, oldRev];
      } else {
        sql = 'INSERT INTO ' + LOCAL_STORE + ' (id, rev, json) VALUES (?,?,?)';
        values = [id, newRev, json];
      }
      tx.executeSql(sql, values, function (tx, res) {
        if (res.rowsAffected) {
          ret = {ok: true, id: id, rev: newRev};
          if (opts.ctx) { // return immediately
            callback(null, ret);
          }
        } else {
          callback(errors.REV_CONFLICT);
        }
      }, function () {
        callback(errors.REV_CONFLICT);
        return false; // ack that we handled the error
      });
    }

    if (opts.ctx) {
      putLocal(opts.ctx);
    } else {
      db.transaction(function (tx) {
        putLocal(tx);
      }, unknownError(callback), function () {
        if (ret) {
          callback(null, ret);
        }
      });
    }
  };

  api._removeLocal = function (doc, callback) {
    var ret;
    db.transaction(function (tx) {
      var sql = 'DELETE FROM ' + LOCAL_STORE + ' WHERE id=? AND rev=?';
      var params = [doc._id, doc._rev];
      tx.executeSql(sql, params, function (tx, res) {
        if (!res.rowsAffected) {
          return callback(errors.REV_CONFLICT);
        }
        ret = {ok: true, id: doc._id, rev: '0-0'};
      });
    }, unknownError(callback), function () {
      callback(null, ret);
    });
  };
}

WebSqlPouch.valid = function () {
  if (typeof global !== 'undefined') {
    if (global.navigator &&
        global.navigator.sqlitePlugin &&
        global.navigator.sqlitePlugin.openDatabase) {
      return true;
    } else if (global.sqlitePlugin && global.sqlitePlugin.openDatabase) {
      return true;
    } else if (global.openDatabase) {
      return true;
    }
  }
  return false;
};

WebSqlPouch.destroy = utils.toPromise(function (name, opts, callback) {
  WebSqlPouch.Changes.removeAllListeners(name);
  var size = getSize(opts);
  var db = openDB(name, POUCH_VERSION, name, size);
  db.transaction(function (tx) {
    var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE,
      LOCAL_STORE, ATTACH_AND_SEQ_STORE];
    stores.forEach(function (store) {
      tx.executeSql('DROP TABLE IF EXISTS ' + store, []);
    });
  }, unknownError(callback), function () {
    if (utils.hasLocalStorage()) {
      delete global.localStorage['_pouch__websqldb_' + name];
      delete global.localStorage[name];
    }
    callback(null, {'ok': true});
  });
});

WebSqlPouch.Changes = new utils.Changes();

module.exports = WebSqlPouch;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../deps/errors":12,"../deps/parse-hex":14,"../merge":21,"../utils":26,"vuvuzela":61}],6:[function(_dereq_,module,exports){
'use strict';
var utils = _dereq_('./utils');
var merge = _dereq_('./merge');
var errors = _dereq_('./deps/errors');
var EE = _dereq_('events').EventEmitter;
var evalFilter = _dereq_('./evalFilter');
var evalView = _dereq_('./evalView');
module.exports = Changes;
utils.inherits(Changes, EE);

function Changes(db, opts, callback) {
  EE.call(this);
  var self = this;
  this.db = db;
  opts = opts ? utils.clone(opts) : {};
  var oldComplete = callback || opts.complete || function () {};
  var complete = opts.complete = utils.once(function (err, resp) {
    if (err) {
      self.emit('error', err);
    } else {
      self.emit('complete', resp);
    }
    self.removeAllListeners();
    db.removeListener('destroyed', onDestroy);
  });
  if (oldComplete) {
    self.on('complete', function (resp) {
      oldComplete(null, resp);
    });
    self.on('error', function (err) {
      oldComplete(err);
    });
  }
  var oldOnChange = opts.onChange;
  if (oldOnChange) {
    self.on('change', oldOnChange);
  }
  function onDestroy() {
    self.cancel();
  }
  db.once('destroyed', onDestroy);

  opts.onChange = function (change) {
    if (opts.isCancelled) {
      return;
    }
    self.emit('change', change);
    if (self.startSeq && self.startSeq <= change.seq) {
      self.emit('uptodate');
      self.startSeq = false;
    }
    if (change.deleted) {
      self.emit('delete', change);
    } else if (change.changes.length === 1 &&
      change.changes[0].rev.slice(0, 2) === '1-') {
      self.emit('create', change);
    } else {
      self.emit('update', change);
    }
  };

  var promise = new utils.Promise(function (fulfill, reject) {
    opts.complete = function (err, res) {
      if (err) {
        reject(err);
      } else {
        fulfill(res);
      }
    };
  });
  self.once('cancel', function () {
    if (oldOnChange) {
      self.removeListener('change', oldOnChange);
    }
    opts.complete(null, {status: 'cancelled'});
  });
  this.then = promise.then.bind(promise);
  this['catch'] = promise['catch'].bind(promise);
  this.then(function (result) {
    complete(null, result);
  }, complete);



  if (!db.taskqueue.isReady) {
    db.taskqueue.addTask(function () {
      if (self.isCancelled) {
        self.emit('cancel');
      } else {
        self.doChanges(opts);
      }
    });
  } else {
    self.doChanges(opts);
  }
}
Changes.prototype.cancel = function () {
  this.isCancelled = true;
  if (this.db.taskqueue.isReady) {
    this.emit('cancel');
  }
};
function processChange(doc, metadata, opts) {
  var changeList = [{rev: doc._rev}];
  if (opts.style === 'all_docs') {
    changeList = merge.collectLeaves(metadata.rev_tree)
    .map(function (x) { return {rev: x.rev}; });
  }
  var change = {
    id: metadata.id,
    changes: changeList,
    doc: doc
  };

  if (utils.isDeleted(metadata, doc._rev)) {
    change.deleted = true;
  }
  if (opts.conflicts) {
    change.doc._conflicts = merge.collectConflicts(metadata);
    if (!change.doc._conflicts.length) {
      delete change.doc._conflicts;
    }
  }
  return change;
}

Changes.prototype.doChanges = function (opts) {
  var self = this;
  var callback = opts.complete;

  opts = utils.clone(opts);
  if ('live' in opts && !('continuous' in opts)) {
    opts.continuous = opts.live;
  }
  opts.processChange = processChange;

  if (opts.since === 'latest') {
    opts.since = 'now';
  }
  if (!opts.since) {
    opts.since = 0;
  }
  if (opts.since === 'now') {
    this.db.info().then(function (info) {
      if (self.isCancelled) {
        callback(null, {status: 'cancelled'});
        return;
      }
      opts.since = info.update_seq  - 1;
      self.doChanges(opts);
    }, callback);
    return;
  }

  if (opts.continuous && opts.since !== 'now') {
    this.db.info().then(function (info) {
      self.startSeq = info.update_seq - 1;
    }, function (err) {
      if (err.id === 'idbNull') {
        //db closed before this returned
        //thats ok
        return;
      }
      throw err;
    });
  }

  if (this.db.type() !== 'http' &&
    opts.filter && typeof opts.filter === 'string') {
    return this.filterChanges(opts);
  }

  if (!('descending' in opts)) {
    opts.descending = false;
  }

  // 0 and 1 should return 1 document
  opts.limit = opts.limit === 0 ? 1 : opts.limit;
  opts.complete = callback;
  var newPromise = this.db._changes(opts);
  if (newPromise && typeof newPromise.cancel === 'function') {
    var cancel = self.cancel;
    self.cancel = utils.getArguments(function (args) {
      newPromise.cancel();
      cancel.apply(this, args);
    });
  }
};

Changes.prototype.filterChanges = function (opts) {
  var self = this;
  var callback = opts.complete;
  if (opts.filter === '_view') {
    if (!opts.view || typeof opts.view !== 'string') {
      var err = new  Error('`view` filter parameter is not provided.');
      err.status = errors.BAD_REQUEST.status;
      err.name = errors.BAD_REQUEST.name;
      err.error = true;
      callback(err);
      return;
    }
    // fetch a view from a design doc, make it behave like a filter
    var viewName = opts.view.split('/');
    this.db.get('_design/' + viewName[0], function (err, ddoc) {
      if (self.isCancelled) {
        callback(null, {status: 'cancelled'});
        return;
      }
      if (err) {
        callback(err);
        return;
      }
      if (ddoc && ddoc.views && ddoc.views[viewName[1]]) {
        
        var filter = evalView(ddoc.views[viewName[1]].map);
        opts.filter = filter;
        self.doChanges(opts);
        return;
      }
      var msg = ddoc.views ? 'missing json key: ' + viewName[1] :
        'missing json key: views';
      if (!err) {
        err = new  Error(msg);
        err.status = errors.MISSING_DOC.status;
        err.name = errors.MISSING_DOC.name;
        err.error = true;
      }
      callback(err);
      return;
    });
  } else {
    // fetch a filter from a design doc
    var filterName = opts.filter.split('/');
    this.db.get('_design/' + filterName[0], function (err, ddoc) {
      if (self.isCancelled) {
        callback(null, {status: 'cancelled'});
        return;
      }
      if (err) {
        callback(err);
        return;
      }
      if (ddoc && ddoc.filters && ddoc.filters[filterName[1]]) {
        var filter = evalFilter(ddoc.filters[filterName[1]]);
        opts.filter = filter;
        self.doChanges(opts);
        return;
      } else {
        var msg = (ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]
          : 'missing json key: filters';
        if (!err) {
          err = new  Error(msg);
          err.status = errors.MISSING_DOC.status;
          err.name = errors.MISSING_DOC.name;
          err.error = true;
        }
        callback(err);
        return;
      }
    });
  }
};
},{"./deps/errors":12,"./evalFilter":18,"./evalView":19,"./merge":21,"./utils":26,"events":30}],7:[function(_dereq_,module,exports){
'use strict';

var utils = _dereq_('./utils');

function updateCheckpoint(db, id, checkpoint, returnValue) {
  return db.get(id)["catch"](function (err) {
    if (err.status === 404) {
      if (db.type() === 'http') {
        utils.explain404(
          'PouchDB is just checking if a remote checkpoint exists.');
      }
      return {_id: id};
    }
    throw err;
  }).then(function (doc) {
    if (returnValue.cancelled) {
      return;
    }
    doc.last_seq = checkpoint;
    return db.put(doc);
  });
}

function Checkpointer(src, target, id, returnValue) {
  this.src = src;
  this.target = target;
  this.id = id;
  this.returnValue = returnValue;
}

Checkpointer.prototype.writeCheckpoint = function (checkpoint) {
  var self = this;
  return this.updateTarget(checkpoint).then(function () {
    return self.updateSource(checkpoint);
  });
};

Checkpointer.prototype.updateTarget = function (checkpoint) {
  return updateCheckpoint(this.target, this.id, checkpoint, this.returnValue);
};

Checkpointer.prototype.updateSource = function (checkpoint) {
  var self = this;
  if (this.readOnlySource) {
    return utils.Promise.resolve(true);
  }
  return updateCheckpoint(this.src, this.id, checkpoint, this.returnValue)[
    "catch"](function (err) {
      var isForbidden = typeof err.status === 'number' &&
        Math.floor(err.status / 100) === 4;
      if (isForbidden) {
        self.readOnlySource = true;
        return true;
      }
      throw err;
    });
};

Checkpointer.prototype.getCheckpoint = function () {
  var self = this;
  return self.target.get(self.id).then(function (targetDoc) {
    return self.src.get(self.id).then(function (sourceDoc) {
      if (targetDoc.last_seq === sourceDoc.last_seq) {
        return sourceDoc.last_seq;
      }
      return 0;
    }, function (err) {
      if (err.status === 404 && targetDoc.last_seq) {
        return self.src.put({
          _id: self.id,
          last_seq: 0
        }).then(function () {
          return 0;
        }, function (err) {
          if (err.status === 401) {
            self.readOnlySource = true;
            return targetDoc.last_seq;
          }
          return 0;
        });
      }
      throw err;
    });
  })["catch"](function (err) {
    if (err.status !== 404) {
      throw err;
    }
    return 0;
  });
};

module.exports = Checkpointer;

},{"./utils":26}],8:[function(_dereq_,module,exports){
(function (global){
/*globals cordova */
"use strict";

var Adapter = _dereq_('./adapter');
var utils = _dereq_('./utils');
var TaskQueue = _dereq_('./taskqueue');
var Promise = utils.Promise;

function defaultCallback(err) {
  if (err && global.debug) {
    console.error(err);
  }
}

utils.inherits(PouchDB, Adapter);
function PouchDB(name, opts, callback) {

  if (!(this instanceof PouchDB)) {
    return new PouchDB(name, opts, callback);
  }
  var self = this;
  if (typeof opts === 'function' || typeof opts === 'undefined') {
    callback = opts;
    opts = {};
  }

  if (name && typeof name === 'object') {
    opts = name;
    name = undefined;
  }
  if (typeof callback === 'undefined') {
    callback = defaultCallback;
  }
  opts = opts || {};
  this.__opts = opts;
  var oldCB = callback;
  self.auto_compaction = opts.auto_compaction;
  self.prefix = PouchDB.prefix;
  Adapter.call(self);
  self.taskqueue = new TaskQueue();
  var promise = new Promise(function (fulfill, reject) {
    callback = function (err, resp) {
      if (err) {
        return reject(err);
      }
      delete resp.then;
      fulfill(resp);
    };
  
    opts = utils.clone(opts);
    var originalName = opts.name || name;
    var backend, error;
    (function () {
      try {

        if (typeof originalName !== 'string') {
          error = new Error('Missing/invalid DB name');
          error.code = 400;
          throw error;
        }

        backend = PouchDB.parseAdapter(originalName, opts);
        
        opts.originalName = originalName;
        opts.name = backend.name;
        if (opts.prefix && backend.adapter !== 'http' &&
            backend.adapter !== 'https') {
          opts.name = opts.prefix + opts.name;
        }
        opts.adapter = opts.adapter || backend.adapter;
        self._adapter = opts.adapter;
        self._db_name = originalName;
        if (!PouchDB.adapters[opts.adapter]) {
          error = new Error('Adapter is missing');
          error.code = 404;
          throw error;
        }

        if (!PouchDB.adapters[opts.adapter].valid()) {
          error = new Error('Invalid Adapter');
          error.code = 404;
          throw error;
        }
      } catch (err) {
        self.taskqueue.fail(err);
        self.changes = utils.toPromise(function (opts) {
          if (opts.complete) {
            opts.complete(err);
          }
        });
      }
    }());
    if (error) {
      return reject(error); // constructor error, see above
    }
    self.adapter = opts.adapter;

    // needs access to PouchDB;
    self.replicate = {};

    self.replicate.from = function (url, opts, callback) {
      return self.constructor.replicate(url, self, opts, callback);
    };

    self.replicate.to = function (url, opts, callback) {
      return self.constructor.replicate(self, url, opts, callback);
    };

    self.sync = function (dbName, opts, callback) {
      return self.constructor.sync(self, dbName, opts, callback);
    };

    self.replicate.sync = self.sync;

    self.destroy = utils.adapterFun('destroy', function (callback) {
      var self = this;
      self.info(function (err, info) {
        if (err) {
          return callback(err);
        }
        self.constructor.destroy(info.db_name, callback);
      });
    });

    PouchDB.adapters[opts.adapter].call(self, opts, function (err, db) {
      if (err) {
        if (callback) {
          self.taskqueue.fail(err);
          callback(err);
        }
        return;
      }
      function destructionListener(event) {
        if (event === 'destroyed') {
          self.emit('destroyed');
          PouchDB.removeListener(originalName, destructionListener);
        }
      }
      PouchDB.on(originalName, destructionListener);
      self.emit('created', self);
      PouchDB.emit('created', opts.originalName);
      self.taskqueue.ready(self);
      callback(null, self);
      
    });
    if (opts.skipSetup) {
      self.taskqueue.ready(self);
    }

    if (utils.isCordova()) {
      //to inform websql adapter that we can use api
      cordova.fireWindowEvent(opts.name + "_pouch", {});
    }
  });
  promise.then(function (resp) {
    oldCB(null, resp);
  }, oldCB);
  self.then = promise.then.bind(promise);
  self["catch"] = promise["catch"].bind(promise);

}

module.exports = PouchDB;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapter":1,"./taskqueue":25,"./utils":26}],9:[function(_dereq_,module,exports){
"use strict";

var createBlob = _dereq_('./blob.js');
var errors = _dereq_('./errors');
var utils = _dereq_("../utils");
var hasUpload;

function ajax(options, adapterCallback) {

  var requestCompleted = false;
  var callback = utils.getArguments(function (args) {
    if (requestCompleted) {
      return;
    }
    adapterCallback.apply(this, args);
    requestCompleted = true;
  });

  if (typeof options === "function") {
    callback = options;
    options = {};
  }

  options = utils.clone(options);

  var defaultOptions = {
    method : "GET",
    headers: {},
    json: true,
    processData: true,
    timeout: 10000,
    cache: false
  };

  options = utils.extend(true, defaultOptions, options);

  // cache-buster, specifically designed to work around IE's aggressive caching
  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/
  if (options.method === 'GET' && !options.cache) {
    var hasArgs = options.url.indexOf('?') !== -1;
    options.url += (hasArgs ? '&' : '?') + '_nonce=' + utils.uuid(16);
  }

  function onSuccess(obj, resp, cb) {
    if (!options.binary && !options.json && options.processData &&
      typeof obj !== 'string') {
      obj = JSON.stringify(obj);
    } else if (!options.binary && options.json && typeof obj === 'string') {
      try {
        obj = JSON.parse(obj);
      } catch (e) {
        // Probably a malformed JSON from server
        return cb(e);
      }
    }
    if (Array.isArray(obj)) {
      obj = obj.map(function (v) {
        var obj;
        if (v.ok) {
          return v;
        } else if (v.error && v.error === 'conflict') {
          obj = errors.REV_CONFLICT;
          obj.id = v.id;
          return obj;
        } else if (v.error && v.error === 'forbidden') {
          obj = errors.FORBIDDEN;
          obj.id = v.id;
          obj.reason = v.reason;
          return obj;
        } else if (v.missing) {
          obj = errors.MISSING_DOC;
          obj.missing = v.missing;
          return obj;
        } else {
          return v;
        }
      });
    }
    cb(null, obj, resp);
  }

  function onError(err, cb) {
    var errParsed, errObj, errType, key;
    try {
      errParsed = JSON.parse(err.responseText);
      //would prefer not to have a try/catch clause
      for (key in errors) {
        if (errors.hasOwnProperty(key) &&
            errors[key].name === errParsed.error) {
          errType = errors[key];
          break;
        }
      }
      if (!errType) {
        errType = errors.UNKNOWN_ERROR;
        if (err.status) {
          errType.status = err.status;
        }
        if (err.statusText) {
          err.name = err.statusText;
        }
      }
      errObj = errors.error(errType, errParsed.reason);
    } catch (e) {
      for (var key in errors) {
        if (errors.hasOwnProperty(key) && errors[key].status === err.status) {
          errType = errors[key];
          break;
        }
      }
      if (!errType) {
        errType = errors.UNKNOWN_ERROR;
        if (err.status) {
          errType.status = err.status;
        }
        if (err.statusText) {
          err.name = err.statusText;
        }
      }
      errObj = errors.error(errType);
    }
    if (err.withCredentials && err.status === 0) {
      // apparently this is what we get when the method
      // is reported as not allowed by CORS. so fudge it
      errObj.status = 405;
      errObj.statusText = "Method Not Allowed";
    }
    cb(errObj);
  }

  var timer;
  var xhr;
  if (options.xhr) {
    xhr = new options.xhr();
  } else {
    xhr = new XMLHttpRequest();
  }
  xhr.open(options.method, options.url);
  xhr.withCredentials = true;

  if (options.json) {
    options.headers.Accept = 'application/json';
    options.headers['Content-Type'] = options.headers['Content-Type'] ||
      'application/json';
    if (options.body &&
        options.processData &&
        typeof options.body !== "string") {
      options.body = JSON.stringify(options.body);
    }
  }

  if (options.binary) {
    xhr.responseType = 'arraybuffer';
  }

  var createCookie = function (name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toGMTString();
    }
    document.cookie = name + "=" + value + expires + "; path=/";
  };

  for (var key in options.headers) {
    if (key === 'Cookie') {
      var cookie = options.headers[key].split('=');
      createCookie(cookie[0], cookie[1], 10);
    } else {
      xhr.setRequestHeader(key, options.headers[key]);
    }
  }

  if (!("body" in options)) {
    options.body = null;
  }

  var abortReq = function () {
    if (requestCompleted) {
      return;
    }
    xhr.abort();
    onError(xhr, callback);
  };

  xhr.onreadystatechange = function () {
    if (xhr.readyState !== 4 || requestCompleted) {
      return;
    }
    clearTimeout(timer);
    if (xhr.status >= 200 && xhr.status < 300) {
      var data;
      if (options.binary) {
        data = createBlob([xhr.response || ''], {
          type: xhr.getResponseHeader('Content-Type')
        });
      } else {
        data = xhr.responseText;
      }
      onSuccess(data, xhr, callback);
    } else {
      onError(xhr, callback);
    }
  };

  if (options.timeout > 0) {
    timer = setTimeout(abortReq, options.timeout);
    xhr.onprogress = function () {
      clearTimeout(timer);
      timer = setTimeout(abortReq, options.timeout);
    };
    if (typeof hasUpload === 'undefined') {
      // IE throws an error if you try to access it directly
      hasUpload = Object.keys(xhr).indexOf('upload') !== -1;
    }
    if (hasUpload) { // does not exist in ie9
      xhr.upload.onprogress = xhr.onprogress;
    }
  }
  if (options.body && (options.body instanceof Blob)) {
    utils.readAsBinaryString(options.body, function (binary) {
      xhr.send(utils.fixBinary(binary));
    });
  } else {
    xhr.send(options.body);
  }
  return {abort: abortReq};
}

module.exports = ajax;

},{"../utils":26,"./blob.js":10,"./errors":12}],10:[function(_dereq_,module,exports){
(function (global){
"use strict";

//Abstracts constructing a Blob object, so it also works in older
//browsers that don't support the native Blob constructor. (i.e.
//old QtWebKit versions, at least).
function createBlob(parts, properties) {
  parts = parts || [];
  properties = properties || {};
  try {
    return new Blob(parts, properties);
  } catch (e) {
    if (e.name !== "TypeError") {
      throw e;
    }
    var BlobBuilder = global.BlobBuilder ||
                      global.MSBlobBuilder ||
                      global.MozBlobBuilder ||
                      global.WebKitBlobBuilder;
    var builder = new BlobBuilder();
    for (var i = 0; i < parts.length; i += 1) {
      builder.append(parts[i]);
    }
    return builder.getBlob(properties.type);
  }
}

module.exports = createBlob;


}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],11:[function(_dereq_,module,exports){
'use strict';
exports.Map = LazyMap; // TODO: use ES6 map
exports.Set = LazySet; // TODO: use ES6 set
// based on https://github.com/montagejs/collections
function LazyMap() {
  this.store = {};
}
LazyMap.prototype.mangle = function (key) {
  if (typeof key !== "string") {
    throw new TypeError("key must be a string but Got " + key);
  }
  return '$' + key;
};
LazyMap.prototype.unmangle = function (key) {
  return key.substring(1);
};
LazyMap.prototype.get = function (key) {
  var mangled = this.mangle(key);
  if (mangled in this.store) {
    return this.store[mangled];
  } else {
    return void 0;
  }
};
LazyMap.prototype.set = function (key, value) {
  var mangled = this.mangle(key);
  this.store[mangled] = value;
  return true;
};
LazyMap.prototype.has = function (key) {
  var mangled = this.mangle(key);
  return mangled in this.store;
};
LazyMap.prototype["delete"] = function (key) {
  var mangled = this.mangle(key);
  if (mangled in this.store) {
    delete this.store[mangled];
    return true;
  }
  return false;
};
LazyMap.prototype.forEach = function (cb) {
  var self = this;
  var keys = Object.keys(self.store);
  keys.forEach(function (key) {
    var value = self.store[key];
    key = self.unmangle(key);
    cb(value, key);
  });
};

function LazySet() {
  this.store = new LazyMap();
}
LazySet.prototype.add = function (key) {
  return this.store.set(key, true);
};
LazySet.prototype.has = function (key) {
  return this.store.has(key);
};
LazySet.prototype["delete"] = function (key) {
  return this.store["delete"](key);
};
},{}],12:[function(_dereq_,module,exports){
"use strict";

function PouchError(opts) {
  this.status = opts.status;
  this.name = opts.error;
  this.message = opts.reason;
  this.error = true;
}

PouchError.prototype__proto__ = Error.prototype;

PouchError.prototype.toString = function () {
  return JSON.stringify({
    status: this.status,
    name: this.name,
    message: this.message
  });
};

exports.UNAUTHORIZED = new PouchError({
  status: 401,
  error: 'unauthorized',
  reason: "Name or password is incorrect."
});
exports.MISSING_BULK_DOCS = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: "Missing JSON list of 'docs'"
});
exports.MISSING_DOC = new PouchError({
  status: 404,
  error: 'not_found',
  reason: 'missing'
});
exports.REV_CONFLICT = new PouchError({
  status: 409,
  error: 'conflict',
  reason: 'Document update conflict'
});
exports.INVALID_ID = new PouchError({
  status: 400,
  error: 'invalid_id',
  reason: '_id field must contain a string'
});
exports.MISSING_ID = new PouchError({
  status: 412,
  error: 'missing_id',
  reason: '_id is required for puts'
});
exports.RESERVED_ID = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: 'Only reserved document ids may start with underscore.'
});
exports.NOT_OPEN = new PouchError({
  status: 412,
  error: 'precondition_failed',
  reason: 'Database not open'
});
exports.UNKNOWN_ERROR = new PouchError({
  status: 500,
  error: 'unknown_error',
  reason: 'Database encountered an unknown error'
});
exports.BAD_ARG = new PouchError({
  status: 500,
  error: 'badarg',
  reason: 'Some query argument is invalid'
});
exports.INVALID_REQUEST = new PouchError({
  status: 400,
  error: 'invalid_request',
  reason: 'Request was invalid'
});
exports.QUERY_PARSE_ERROR = new PouchError({
  status: 400,
  error: 'query_parse_error',
  reason: 'Some query parameter is invalid'
});
exports.DOC_VALIDATION = new PouchError({
  status: 500,
  error: 'doc_validation',
  reason: 'Bad special document member'
});
exports.BAD_REQUEST = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: 'Something wrong with the request'
});
exports.NOT_AN_OBJECT = new PouchError({
  status: 400,
  error: 'bad_request',
  reason: 'Document must be a JSON object'
});
exports.DB_MISSING = new PouchError({
  status: 404,
  error: 'not_found',
  reason: 'Database not found'
});
exports.IDB_ERROR = new PouchError({
  status: 500,
  error: 'indexed_db_went_bad',
  reason: 'unknown'
});
exports.WSQ_ERROR = new PouchError({
  status: 500,
  error: 'web_sql_went_bad',
  reason: 'unknown'
});
exports.LDB_ERROR = new PouchError({
  status: 500,
  error: 'levelDB_went_went_bad',
  reason: 'unknown'
});
exports.FORBIDDEN = new PouchError({
  status: 403,
  error: 'forbidden',
  reason: 'Forbidden by design doc validate_doc_update function'
});
exports.error = function (error, reason, name) {
  function CustomPouchError(msg) {
    this.message = reason;
    if (name) {
      this.name = name;
    }
  }
  CustomPouchError.prototype = error;
  return new CustomPouchError(reason);
};

},{}],13:[function(_dereq_,module,exports){
(function (process,global){
'use strict';

var crypto = _dereq_('crypto');
var Md5 = _dereq_('spark-md5');
var setImmediateShim = global.setImmediate || global.setTimeout;
var MD5_CHUNK_SIZE = 32768;

function sliceShim(arrayBuffer, begin, end) {
  if (typeof arrayBuffer.slice === 'function') {
    if (!begin) {
      return arrayBuffer.slice();
    } else if (!end) {
      return arrayBuffer.slice(begin);
    } else {
      return arrayBuffer.slice(begin, end);
    }
  }
  //
  // shim for IE courtesy of http://stackoverflow.com/a/21440217
  //

  //If `begin`/`end` is unspecified, Chrome assumes 0, so we do the same
  //Chrome also converts the values to integers via flooring
  begin = Math.floor(begin || 0);
  end = Math.floor(end || 0);

  var len = arrayBuffer.byteLength;

  //If either `begin` or `end` is negative, it refers to an
  //index from the end of the array, as opposed to from the beginning.
  //The range specified by the `begin` and `end` values is clamped to the
  //valid index range for the current array.
  begin = begin < 0 ? Math.max(begin + len, 0) : Math.min(len, begin);
  end = end < 0 ? Math.max(end + len, 0) : Math.min(len, end);

  //If the computed length of the new ArrayBuffer would be negative, it
  //is clamped to zero.
  if (end - begin <= 0) {
    return new ArrayBuffer(0);
  }

  var result = new ArrayBuffer(end - begin);
  var resultBytes = new Uint8Array(result);
  var sourceBytes = new Uint8Array(arrayBuffer, begin, end - begin);

  resultBytes.set(sourceBytes);

  return result;
}

// convert a 64-bit int to a binary string
function intToString(int) {
  var bytes = [
    (int & 0xff),
    ((int >>> 8) & 0xff),
    ((int >>> 16) & 0xff),
    ((int >>> 24) & 0xff)
  ];
  return bytes.map(function (byte) {
    return String.fromCharCode(byte);
  }).join('');
}

// convert an array of 64-bit ints into
// a base64-encoded string
function rawToBase64(raw) {
  var res = '';
  for (var i = 0; i < raw.length; i++) {
    res += intToString(raw[i]);
  }
  return global.btoa(res);
}

module.exports = function (data, callback) {
  if (!process.browser) {
    var base64 = crypto.createHash('md5').update(data).digest('base64');
    callback(null, base64);
    return;
  }
  var inputIsString = typeof data === 'string';
  var len = inputIsString ? data.length : data.byteLength;
  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
  var chunks = Math.ceil(len / chunkSize);
  var currentChunk = 0;
  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();

  function append(buffer, data, start, end) {
    if (inputIsString) {
      buffer.appendBinary(data.substring(start, end));
    } else {
      buffer.append(sliceShim(data, start, end));
    }
  }

  function loadNextChunk() {
    var start = currentChunk * chunkSize;
    var end = start + chunkSize;
    if ((start + chunkSize) >= data.size) {
      end = data.size;
    }
    currentChunk++;
    if (currentChunk < chunks) {
      append(buffer, data, start, end);
      setImmediateShim(loadNextChunk);
    } else {
      append(buffer, data, start, end);
      var raw = buffer.end(true);
      var base64 = rawToBase64(raw);
      callback(null, base64);
      buffer.destroy();
    }
  }
  loadNextChunk();
};

}).call(this,_dereq_("/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":31,"crypto":29,"spark-md5":60}],14:[function(_dereq_,module,exports){
'use strict';

//
// Parsing hex strings. Yeah.
//
// So basically we need this because of a bug in WebSQL:
// https://code.google.com/p/chromium/issues/detail?id=422690
// https://bugs.webkit.org/show_bug.cgi?id=137637
//
// UTF-8 and UTF-16 are provided as separate functions
// for meager performance improvements
//

function decodeUtf8(str) {
  return decodeURIComponent(window.escape(str));
}

function hexToInt(charCode) {
  // '0'-'9' is 48-57
  // 'A'-'F' is 65-70
  // SQLite will only give us uppercase hex
  return charCode < 65 ? (charCode - 48) : (charCode - 55);
}


// Example:
// pragma encoding=utf8;
// select hex('A');
// returns '41'
function parseHexUtf8(str, start, end) {
  var result = '';
  while (start < end) {
    result += String.fromCharCode(
      (hexToInt(str.charCodeAt(start++)) << 4) |
        hexToInt(str.charCodeAt(start++)));
  }
  return result;
}

// Example:
// pragma encoding=utf16;
// select hex('A');
// returns '4100'
// notice that the 00 comes after the 41 (i.e. it's swizzled)
function parseHexUtf16(str, start, end) {
  var result = '';
  while (start < end) {
    // UTF-16, so swizzle the bytes
    result += String.fromCharCode(
      (hexToInt(str.charCodeAt(start + 2)) << 12) |
        (hexToInt(str.charCodeAt(start + 3)) << 8) |
        (hexToInt(str.charCodeAt(start)) << 4) |
        hexToInt(str.charCodeAt(start + 1)));
    start += 4;
  }
  return result;
}

function parseHexString(str, encoding) {
  if (encoding === 'UTF-8') {
    return decodeUtf8(parseHexUtf8(str, 0, str.length));
  } else {
    return parseHexUtf16(str, 0, str.length);
  }
}

module.exports = parseHexString;
},{}],15:[function(_dereq_,module,exports){
'use strict';

// originally parseUri 1.2.2, now patched by us
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
var options = {
  strictMode: false,
  key: ["source", "protocol", "authority", "userInfo", "user", "password",
    "host", "port", "relative", "path", "directory", "file", "query",
    "anchor"],
  q:   {
    name:   "queryKey",
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    /* jshint maxlen: false */
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};
function parseUri(str) {
  var o = options;
  var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
  var uri = {};
  var i = 14;

  while (i--) {
    var key = o.key[i];
    var value = m[i] || "";
    var encoded = ['user', 'password'].indexOf(key) !== -1;
    uri[key] = encoded ? decodeURIComponent(value) : value;
  }

  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) {
      uri[o.q.name][$1] = $2;
    }
  });

  return uri;
}


module.exports = parseUri;
},{}],16:[function(_dereq_,module,exports){
'use strict';
var Promise = _dereq_('../utils').Promise;

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
function upsert(db, docId, diffFun) {
  return new Promise(function (fulfill, reject) {
    if (docId && typeof docId === 'object') {
      docId = docId._id;
    }
    if (typeof docId !== 'string') {
      return reject(new Error('doc id is required'));
    }

    db.get(docId, function (err, doc) {
      if (err) {
        if (err.status !== 404) {
          return reject(err);
        }
        return fulfill(tryAndPut(db, diffFun({_id : docId}), diffFun));
      }
      var newDoc = diffFun(doc);
      if (!newDoc) {
        return fulfill(doc);
      }
      fulfill(tryAndPut(db, newDoc, diffFun));
    });
  });
}

function tryAndPut(db, doc, diffFun) {
  return db.put(doc)["catch"](function (err) {
    if (err.status !== 409) {
      throw err;
    }
    return upsert(db, doc, diffFun);
  });
}

module.exports = function (db, docId, diffFun, cb) {
  if (typeof cb === 'function') {
    upsert(db, docId, diffFun).then(function (resp) {
      cb(null, resp);
    }, cb);
  } else {
    return upsert(db, docId, diffFun);
  }
};

},{"../utils":26}],17:[function(_dereq_,module,exports){
"use strict";

// BEGIN Math.uuid.js

/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix)
 *   length - the desired number of characters
 *   radix  - the number of allowable values for each character.
 *
 * EXAMPLES:
 *   // No arguments  - returns RFC4122, version 4 ID
 *   >>> Math.uuid()
 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
 *
 *   // One argument - returns ID of the specified length
 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
 *   "VcydxgltxrVZSTV"
 *
 *   // Two arguments - returns ID of the specified length, and radix. 
 *   // (Radix must be <= 62)
 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
 *   "01001010"
 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
 *   "47473046"
 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
 *   "098F4D35"
 */
var chars = (
  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
  'abcdefghijklmnopqrstuvwxyz'
).split('');
function getValue(radix) {
  return 0 | Math.random() * radix;
}
function uuid(len, radix) {
  radix = radix || chars.length;
  var out = '';
  var i = -1;

  if (len) {
    // Compact form
    while (++i < len) {
      out += chars[getValue(radix)];
    }
    return out;
  }
    // rfc4122, version 4 form
    // Fill in random data.  At i==19 set the high bits of clock sequence as
    // per rfc4122, sec. 4.1.5
  while (++i < 36) {
    switch (i) {
      case 8:
      case 13:
      case 18:
      case 23:
        out += '-';
        break;
      case 19:
        out += chars[(getValue(16) & 0x3) | 0x8];
        break;
      default:
        out += chars[getValue(16)];
    }
  }

  return out;
}



module.exports = uuid;


},{}],18:[function(_dereq_,module,exports){
'use strict';

module.exports = evalFilter;
function evalFilter(input) {
  /*jshint evil: true */
  return eval([
    '(function () { return ',
    input,
    ' })()'
  ].join(''));
}
},{}],19:[function(_dereq_,module,exports){
'use strict';

module.exports = evalView;
function evalView(input) {
  /*jshint evil: true */
  return eval([
    '(function () {',
    '  return function (doc) {',
    '    var emitted = false;',
    '    var emit = function (a, b) {',
    '      emitted = true;',
    '    };',
    '    var view = ' + input + ';',
    '    view(doc);',
    '    if (emitted) {',
    '      return true;',
    '    }',
    '  }',
    '})()'
  ].join('\n'));
}
},{}],20:[function(_dereq_,module,exports){
(function (process){
"use strict";

var PouchDB = _dereq_('./setup');

module.exports = PouchDB;

PouchDB.ajax = _dereq_('./deps/ajax');
PouchDB.extend = _dereq_('pouchdb-extend');
PouchDB.utils = _dereq_('./utils');
PouchDB.Errors = _dereq_('./deps/errors');
PouchDB.replicate = _dereq_('./replicate').replicate;
PouchDB.sync = _dereq_('./sync');
PouchDB.version = _dereq_('./version');
var httpAdapter = _dereq_('./adapters/http');
PouchDB.adapter('http', httpAdapter);
PouchDB.adapter('https', httpAdapter);

PouchDB.adapter('idb', _dereq_('./adapters/idb'));
PouchDB.adapter('websql', _dereq_('./adapters/websql'));
PouchDB.plugin(_dereq_('pouchdb-mapreduce'));

if (!process.browser) {
  var ldbAdapter = _dereq_('./adapters/leveldb');
  PouchDB.adapter('ldb', ldbAdapter);
  PouchDB.adapter('leveldb', ldbAdapter);
}

}).call(this,_dereq_("/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./adapters/http":2,"./adapters/idb":3,"./adapters/leveldb":29,"./adapters/websql":5,"./deps/ajax":9,"./deps/errors":12,"./replicate":22,"./setup":23,"./sync":24,"./utils":26,"./version":27,"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":31,"pouchdb-extend":51,"pouchdb-mapreduce":54}],21:[function(_dereq_,module,exports){
'use strict';
var extend = _dereq_('pouchdb-extend');


// for a better overview of what this is doing, read:
// https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl
//
// But for a quick intro, CouchDB uses a revision tree to store a documents
// history, A -> B -> C, when a document has conflicts, that is a branch in the
// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format
//
// KeyTree = [Path ... ]
// Path = {pos: position_from_root, ids: Tree}
// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]

// Turn a path as a flat array into a tree with a single branch
function pathToTree(path) {
  var doc = path.shift();
  var root = [doc.id, doc.opts, []];
  var leaf = root;
  var nleaf;

  while (path.length) {
    doc = path.shift();
    nleaf = [doc.id, doc.opts, []];
    leaf[2].push(nleaf);
    leaf = nleaf;
  }
  return root;
}

// Merge two trees together
// The roots of tree1 and tree2 must be the same revision
function mergeTree(in_tree1, in_tree2) {
  var queue = [{tree1: in_tree1, tree2: in_tree2}];
  var conflicts = false;
  while (queue.length > 0) {
    var item = queue.pop();
    var tree1 = item.tree1;
    var tree2 = item.tree2;

    if (tree1[1].status || tree2[1].status) {
      tree1[1].status =
        (tree1[1].status ===  'available' ||
         tree2[1].status === 'available') ? 'available' : 'missing';
    }

    for (var i = 0; i < tree2[2].length; i++) {
      if (!tree1[2][0]) {
        conflicts = 'new_leaf';
        tree1[2][0] = tree2[2][i];
        continue;
      }

      var merged = false;
      for (var j = 0; j < tree1[2].length; j++) {
        if (tree1[2][j][0] === tree2[2][i][0]) {
          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});
          merged = true;
        }
      }
      if (!merged) {
        conflicts = 'new_branch';
        tree1[2].push(tree2[2][i]);
        tree1[2].sort();
      }
    }
  }
  return {conflicts: conflicts, tree: in_tree1};
}

function doMerge(tree, path, dontExpand) {
  var restree = [];
  var conflicts = false;
  var merged = false;
  var res;

  if (!tree.length) {
    return {tree: [path], conflicts: 'new_leaf'};
  }

  tree.forEach(function (branch) {
    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
      // Paths start at the same position and have the same root, so they need
      // merged
      res = mergeTree(branch.ids, path.ids);
      restree.push({pos: branch.pos, ids: res.tree});
      conflicts = conflicts || res.conflicts;
      merged = true;
    } else if (dontExpand !== true) {
      // The paths start at a different position, take the earliest path and
      // traverse up until it as at the same point from root as the path we
      // want to merge.  If the keys match we return the longer path with the
      // other merged After stemming we dont want to expand the trees

      var t1 = branch.pos < path.pos ? branch : path;
      var t2 = branch.pos < path.pos ? path : branch;
      var diff = t2.pos - t1.pos;

      var candidateParents = [];

      var trees = [];
      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});
      while (trees.length > 0) {
        var item = trees.pop();
        if (item.diff === 0) {
          if (item.ids[0] === t2.ids[0]) {
            candidateParents.push(item);
          }
          continue;
        }
        if (!item.ids) {
          continue;
        }
        /*jshint loopfunc:true */
        item.ids[2].forEach(function (el, idx) {
          trees.push(
            {ids: el, diff: item.diff - 1, parent: item.ids, parentIdx: idx});
        });
      }

      var el = candidateParents[0];

      if (!el) {
        restree.push(branch);
      } else {
        res = mergeTree(el.ids, t2.ids);
        el.parent[2][el.parentIdx] = res.tree;
        restree.push({pos: t1.pos, ids: t1.ids});
        conflicts = conflicts || res.conflicts;
        merged = true;
      }
    } else {
      restree.push(branch);
    }
  });

  // We didnt find
  if (!merged) {
    restree.push(path);
  }

  restree.sort(function (a, b) {
    return a.pos - b.pos;
  });

  return {
    tree: restree,
    conflicts: conflicts || 'internal_node'
  };
}

// To ensure we dont grow the revision tree infinitely, we stem old revisions
function stem(tree, depth) {
  // First we break out the tree into a complete list of root to leaf paths,
  // we cut off the start of the path and generate a new set of flat trees
  var stemmedPaths = PouchMerge.rootToLeaf(tree).map(function (path) {
    var stemmed = path.ids.slice(-depth);
    return {
      pos: path.pos + (path.ids.length - stemmed.length),
      ids: pathToTree(stemmed)
    };
  });
  // Then we remerge all those flat trees together, ensuring that we dont
  // connect trees that would go beyond the depth limit
  return stemmedPaths.reduce(function (prev, current, i, arr) {
    return doMerge(prev, current, true).tree;
  }, [stemmedPaths.shift()]);
}

var PouchMerge = {};

PouchMerge.merge = function (tree, path, depth) {
  // Ugh, nicer way to not modify arguments in place?
  tree = extend(true, [], tree);
  path = extend(true, {}, path);
  var newTree = doMerge(tree, path);
  return {
    tree: stem(newTree.tree, depth),
    conflicts: newTree.conflicts
  };
};

// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// http://guide.couchdb.org/draft/conflicts.html
PouchMerge.winningRev = function (metadata) {
  var leafs = [];
  PouchMerge.traverseRevTree(metadata.rev_tree,
                              function (isLeaf, pos, id, something, opts) {
    if (isLeaf) {
      leafs.push({pos: pos, id: id, deleted: !!opts.deleted});
    }
  });
  leafs.sort(function (a, b) {
    if (a.deleted !== b.deleted) {
      return a.deleted > b.deleted ? 1 : -1;
    }
    if (a.pos !== b.pos) {
      return b.pos - a.pos;
    }
    return a.id < b.id ? 1 : -1;
  });

  return leafs[0].pos + '-' + leafs[0].id;
};

// Pretty much all below can be combined into a higher order function to
// traverse revisions
// The return value from the callback will be passed as context to all
// children of that node
PouchMerge.traverseRevTree = function (revs, callback) {
  var toVisit = revs.slice();

  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var branches = tree[2];
    var newCtx =
      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});
    }
  }
};

PouchMerge.collectLeaves = function (revs) {
  var leaves = [];
  PouchMerge.traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
    if (isLeaf) {
      leaves.unshift({rev: pos + "-" + id, pos: pos, opts: opts});
    }
  });
  leaves.sort(function (a, b) {
    return b.pos - a.pos;
  });
  leaves.map(function (leaf) { delete leaf.pos; });
  return leaves;
};

// returns revs of all conflicts that is leaves such that
// 1. are not deleted and
// 2. are different than winning revision
PouchMerge.collectConflicts = function (metadata) {
  var win = PouchMerge.winningRev(metadata);
  var leaves = PouchMerge.collectLeaves(metadata.rev_tree);
  var conflicts = [];
  leaves.forEach(function (leaf) {
    if (leaf.rev !== win && !leaf.opts.deleted) {
      conflicts.push(leaf.rev);
    }
  });
  return conflicts;
};

PouchMerge.rootToLeaf = function (tree) {
  var paths = [];
  PouchMerge.traverseRevTree(tree, function (isLeaf, pos, id, history, opts) {
    history = history ? history.slice(0) : [];
    history.push({id: id, opts: opts});
    if (isLeaf) {
      var rootPos = pos + 1 - history.length;
      paths.unshift({pos: rootPos, ids: history});
    }
    return history;
  });
  return paths;
};


module.exports = PouchMerge;

},{"pouchdb-extend":51}],22:[function(_dereq_,module,exports){
'use strict';

var utils = _dereq_('./utils');
var EE = _dereq_('events').EventEmitter;
var Checkpointer = _dereq_('./checkpointer');
var MAX_SIMULTANEOUS_REVS = 50;

function randomNumber(min, max) {
  min = parseInt(min, 10);
  max = parseInt(max, 10);
  if (min !== min) {
    min = 0;
  }
  if (max !== max || max <= min) {
    max = (min || 1) << 1; //doubling
  } else {
    max = max + 1;
  }
  var ratio = Math.random();
  var range = max - min;

  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
}

function defaultBackOff(min) {
  var max = 0;
  if (!min) {
    max = 2000;
  }
  return randomNumber(min, max);
}

function backOff(repId, src, target, opts, returnValue, result, error) {
  if (opts.retry === false) {
    returnValue.emit('error', error);
    returnValue.removeAllListeners();
    return;
  }
  opts.default_back_off = opts.default_back_off || 0;
  opts.retries = opts.retries || 0;
  if (typeof opts.back_off_function !== 'function') {
    opts.back_off_function = defaultBackOff;
  }
  opts.retries++;
  if (opts.max_retries && opts.retries > opts.max_retries) {
    returnValue.emit('error', new Error('tried ' +
      opts.retries + ' times but replication failed'));
    returnValue.removeAllListeners();
    return;
  }
  returnValue.emit('requestError', error);
  if (returnValue.state === 'active') {
    returnValue.emit('syncStopped');
    returnValue.state = 'stopped';
    returnValue.once('syncRestarted', function () {
      opts.current_back_off = opts.default_back_off;
    });
  }

  opts.current_back_off = opts.current_back_off || opts.default_back_off;
  opts.current_back_off = opts.back_off_function(opts.current_back_off);
  setTimeout(function () {
    replicate(repId, src, target, opts, returnValue);
  }, opts.current_back_off);
}

// We create a basic promise so the caller can cancel the replication possibly
// before we have actually started listening to changes etc
utils.inherits(Replication, EE);
function Replication(opts) {
  EE.call(this);
  this.cancelled = false;
  this.state = 'pending';
  var self = this;
  var promise = new utils.Promise(function (fulfill, reject) {
    self.once('complete', fulfill);
    self.once('error', reject);
  });
  self.then = function (resolve, reject) {
    return promise.then(resolve, reject);
  };
  self["catch"] = function (reject) {
    return promise["catch"](reject);
  };
  // As we allow error handling via "error" event as well,
  // put a stub in here so that rejecting never throws UnhandledError.
  self["catch"](function (err) {});

}

Replication.prototype.cancel = function () {
  this.cancelled = true;
  this.state = 'cancelled';
  this.emit('cancel');
};

Replication.prototype.ready = function (src, target) {
  var self = this;
  this.once('change', function () {
    if (this.state === 'pending') {
      self.state = 'active';
      self.emit('syncStarted');
    } else if (self.state === 'stopped') {
      self.state = 'active';
      self.emit('syncRestarted');
    }
  });
  function onDestroy() {
    self.cancel();
  }
  src.once('destroyed', onDestroy);
  target.once('destroyed', onDestroy);
  function cleanup() {
    src.removeListener('destroyed', onDestroy);
    target.removeListener('destroyed', onDestroy);
  }
  this.then(cleanup, cleanup);
};


// TODO: check CouchDB's replication id generation
// Generate a unique id particular to this replication
function genReplicationId(src, target, opts) {
  var filterFun = opts.filter ? opts.filter.toString() : '';
  return src.id().then(function (src_id) {
    return target.id().then(function (target_id) {
      var queryData = src_id + target_id + filterFun +
        JSON.stringify(opts.query_params) + opts.doc_ids;
      return utils.MD5(queryData).then(function (md5) {
        // can't use straight-up md5 alphabet, because
        // the char '/' is interpreted as being for attachments,
        // and + is also not url-safe
        md5 = md5.replace(/\//g, '.').replace(/\+/g, '_');
        return '_local/' + md5;
      });
    });
  });
}

function replicate(repId, src, target, opts, returnValue, result) {
  var batches = [];               // list of batches to be processed
  var currentBatch;               // the batch currently being processed
  var pendingBatch = {
    seq: 0,
    changes: [],
    docs: []
  }; // next batch, not yet ready to be processed
  var writingCheckpoint = false;  // true while checkpoint is being written
  var changesCompleted = false;   // true when all changes received
  var replicationCompleted = false; // true when replication has completed
  var last_seq = 0;
  var continuous = opts.continuous || opts.live || false;
  var batch_size = opts.batch_size || 100;
  var batches_limit = opts.batches_limit || 10;
  var changesPending = false;     // true while src.changes is running
  var doc_ids = opts.doc_ids;
  var state = {
    cancelled: false
  };
  var checkpointer = new Checkpointer(src, target, repId, state);
  result = result || {
    ok: true,
    start_time: new Date(),
    docs_read: 0,
    docs_written: 0,
    doc_write_failures: 0,
    errors: []
  };
  var changesOpts = {};
  returnValue.ready(src, target);

  function writeDocs() {
    if (currentBatch.docs.length === 0) {
      return;
    }
    var docs = currentBatch.docs;
    return target.bulkDocs({
      docs: docs
    }, {
      new_edits: false
    }).then(function (res) {
      if (state.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      var errors = [];
      res.forEach(function (res) {
        if (res.error) {
          result.doc_write_failures++;
          var error = new Error(res.reason || res.message || 'Unknown reason');
          error.name = res.name || res.error;
          errors.push(error);
        }
      });
      result.errors = result.errors.concat(errors);
      result.docs_written += currentBatch.docs.length - errors.length;
      var non403s = errors.filter(function (error) {
        return error.name !== 'unauthorized' && error.name !== 'forbidden';
      });
      if (non403s.length > 0) {
        var error = new Error('bulkDocs error');
        error.other_errors = errors;
        abortReplication('target.bulkDocs failed to write docs', error);
        throw new Error('bulkWrite partial failure');
      }
    }, function (err) {
      result.doc_write_failures += docs.length;
      throw err;
    });
  }


  function getNextDoc() {
    var diffs = currentBatch.diffs;
    var id = Object.keys(diffs)[0];
    var allMissing = diffs[id].missing;
    // avoid url too long error by batching
    var missingBatches = [];
    for (var i = 0; i < allMissing.length; i += MAX_SIMULTANEOUS_REVS) {
      missingBatches.push(allMissing.slice(i, Math.min(allMissing.length,
        i + MAX_SIMULTANEOUS_REVS)));
    }

    return utils.Promise.all(missingBatches.map(function (missing) {
      return src.get(id, {revs: true, open_revs: missing, attachments: true})
        .then(function (docs) {
          docs.forEach(function (doc) {
            if (state.cancelled) {
              return completeReplication();
            }
            if (doc.ok) {
              result.docs_read++;
              currentBatch.pendingRevs++;
              currentBatch.docs.push(doc.ok);
            }
          });
          delete diffs[id];
        });
    }));
  }

  function getAllDocs() {
    if (Object.keys(currentBatch.diffs).length > 0) {
      return getNextDoc().then(getAllDocs);
    } else {
      return utils.Promise.resolve();
    }
  }


  function getRevisionOneDocs() {
    // filter out the generation 1 docs and get them
    // leaving the non-generation one docs to be got otherwise
    var ids = Object.keys(currentBatch.diffs).filter(function (id) {
      var missing = currentBatch.diffs[id].missing;
      return missing.length === 1 && missing[0].slice(0, 2) === '1-';
    });
    return src.allDocs({
      keys: ids,
      include_docs: true
    }).then(function (res) {
      if (state.cancelled) {
        completeReplication();
        throw (new Error('cancelled'));
      }
      res.rows.forEach(function (row) {
        if (row.doc && !row.deleted &&
          row.value.rev.slice(0, 2) === '1-' && (
            !row.doc._attachments ||
            Object.keys(row.doc._attachments).length === 0
          )
        ) {
          result.docs_read++;
          currentBatch.pendingRevs++;
          currentBatch.docs.push(row.doc);
          delete currentBatch.diffs[row.id];
        }
      });
    });
  }


  function getDocs() {
    return getRevisionOneDocs().then(getAllDocs);
  }


  function finishBatch() {
    writingCheckpoint = true;
    return checkpointer.writeCheckpoint(
      currentBatch.seq
    ).then(function (res) {
      writingCheckpoint = false;
      if (state.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      result.last_seq = last_seq = currentBatch.seq;
      returnValue.emit('change', utils.clone(result));
      currentBatch = undefined;
      getChanges();
    })["catch"](function (err) {
      writingCheckpoint = false;
      abortReplication('writeCheckpoint completed with error', err);
      throw err;
    });
  }


  function getDiffs() {
    var diff = {};
    currentBatch.changes.forEach(function (change) {
      diff[change.id] = change.changes.map(function (x) {
        return x.rev;
      });
    });
    return target.revsDiff(diff).then(function (diffs) {
      if (state.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      // currentBatch.diffs elements are deleted as the documents are written
      currentBatch.diffs = diffs;
      currentBatch.pendingRevs = 0;
    });
  }


  function startNextBatch() {
    if (state.cancelled || currentBatch) {
      return;
    }
    if (batches.length === 0) {
      processPendingBatch(true);
      return;
    }
    currentBatch = batches.shift();
    getDiffs()
    .then(getDocs)
    .then(writeDocs)
    .then(finishBatch)
    .then(startNextBatch)[
    "catch"](function (err) {
      abortReplication('batch processing terminated with error', err);
    });
  }


  function processPendingBatch(immediate) {
    if (pendingBatch.changes.length === 0) {
      if (batches.length === 0 && !currentBatch) {
        if ((continuous && changesOpts.live) || changesCompleted) {
          returnValue.emit('uptodate', utils.clone(result));
        }
        if (changesCompleted) {
          completeReplication();
        }
      }
      return;
    }
    if (
      immediate ||
      changesCompleted ||
      pendingBatch.changes.length >= batch_size
    ) {
      batches.push(pendingBatch);
      pendingBatch = {
        seq: 0,
        changes: [],
        docs: []
      };
      startNextBatch();
    }
  }


  function abortReplication(reason, err) {
    if (replicationCompleted) {
      return;
    }
    result.ok = false;
    result.status = 'aborting';
    result.errors.push(err);
    batches = [];
    pendingBatch = {
      seq: 0,
      changes: [],
      docs: []
    };
    completeReplication();
  }


  function completeReplication() {
    if (replicationCompleted) {
      return;
    }
    if (state.cancelled) {
      result.status = 'cancelled';
      if (writingCheckpoint) {
        return;
      }
    }
    result.status = result.status || 'complete';
    result.end_time = new Date();
    result.last_seq = last_seq;
    replicationCompleted = state.cancelled = true;
    var non403s = result.errors.filter(function (error) {
      return error.name !== 'unauthorized' && error.name !== 'forbidden';
    });
    if (non403s.length > 0) {
      var error = result.errors.pop();
      if (result.errors.length > 0) {
        error.other_errors = result.errors;
      }
      error.result = result;
      backOff(repId, src, target, opts, returnValue, result, error);
    } else {
      returnValue.emit('complete', result);
      returnValue.removeAllListeners();
    }
  }


  function onChange(change) {
    if (state.cancelled) {
      return completeReplication();
    }
    if (
      pendingBatch.changes.length === 0 &&
      batches.length === 0 &&
      !currentBatch
    ) {
      returnValue.emit('outofdate', utils.clone(result));
    }
    pendingBatch.seq = change.seq;
    pendingBatch.changes.push(change);
    processPendingBatch(batches.length === 0);
  }


  function onChangesComplete(changes) {
    changesPending = false;
    if (state.cancelled) {
      return completeReplication();
    }
    if (changesOpts.since < changes.last_seq) {
      changesOpts.since = changes.last_seq;
      getChanges();
    } else {
      if (continuous) {
        changesOpts.live = true;
        getChanges();
      } else {
        changesCompleted = true;
      }
    }
    processPendingBatch(true);
  }


  function onChangesError(err) {
    changesPending = false;
    if (state.cancelled) {
      return completeReplication();
    }
    abortReplication('changes rejected', err);
  }


  function getChanges() {
    if (!(
      !changesPending &&
      !changesCompleted &&
      batches.length < batches_limit
    )) {
      return;
    }
    changesPending = true;
    function abortChanges() {
      changes.cancel();
    }
    function removeListener() {
      returnValue.removeListener('cancel', abortChanges);
    }
    returnValue.once('cancel', abortChanges);
    var changes = src.changes(changesOpts)
    .on('change', onChange);
    changes.then(removeListener, removeListener);
    changes.then(onChangesComplete)[
    "catch"](onChangesError);
  }


  function startChanges() {
    checkpointer.getCheckpoint().then(function (checkpoint) {
      last_seq = checkpoint;
      changesOpts = {
        since: last_seq,
        limit: batch_size,
        batch_size: batch_size,
        style: 'all_docs',
        doc_ids: doc_ids,
        returnDocs: false
      };
      if (opts.filter) {
        changesOpts.filter = opts.filter;
      }
      if (opts.query_params) {
        changesOpts.query_params = opts.query_params;
      }
      getChanges();
    })["catch"](function (err) {
      abortReplication('getCheckpoint rejected with ', err);
    });
  }


  returnValue.once('cancel', completeReplication);

  if (typeof opts.onChange === 'function') {
    returnValue.on('change', opts.onChange);
  }

  if (typeof opts.complete === 'function') {
    returnValue.once('error', opts.complete);
    returnValue.once('complete', function (result) {
      opts.complete(null, result);
    });
  }

  if (typeof opts.since === 'undefined') {
    startChanges();
  } else {
    writingCheckpoint = true;
    checkpointer.writeCheckpoint(opts.since).then(function (res) {
      writingCheckpoint = false;
      if (state.cancelled) {
        completeReplication();
        return;
      }
      last_seq = opts.since;
      startChanges();
    })["catch"](function (err) {
      writingCheckpoint = false;
      abortReplication('writeCheckpoint completed with error', err);
      throw err;
    });
  }
}

exports.toPouch = toPouch;
function toPouch(db, opts) {
  var PouchConstructor = opts.PouchConstructor;
  if (typeof db === 'string') {
    return new PouchConstructor(db);
  } else if (db.then) {
    return db;
  } else {
    return utils.Promise.resolve(db);
  }
}


exports.replicate = replicateWrapper;
function replicateWrapper(src, target, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }
  if (!opts.complete) {
    opts.complete = callback || function () {};
  }
  opts = utils.clone(opts);
  opts.continuous = opts.continuous || opts.live;
  opts.retry = opts.retry || false;
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  var replicateRet = new Replication(opts);
  toPouch(src, opts).then(function (src) {
    return toPouch(target, opts).then(function (target) {
      return genReplicationId(src, target, opts).then(function (repId) {
        replicate(repId, src, target, opts, replicateRet);
      });
    });
  })["catch"](function (err) {
    replicateRet.emit('error', err);
    opts.complete(err);
  });
  return replicateRet;
}

},{"./checkpointer":7,"./utils":26,"events":30}],23:[function(_dereq_,module,exports){
(function (global){
"use strict";

var PouchDB = _dereq_("./constructor");
var utils = _dereq_('./utils');
var Promise = utils.Promise;
var EventEmitter = _dereq_('events').EventEmitter;
PouchDB.adapters = {};
PouchDB.preferredAdapters = _dereq_('./adapters/preferredAdapters.js');

PouchDB.prefix = '_pouch_';

var eventEmitter = new EventEmitter();

var eventEmitterMethods = [
  'on',
  'addListener',
  'emit',
  'listeners',
  'once',
  'removeAllListeners',
  'removeListener',
  'setMaxListeners'
];

eventEmitterMethods.forEach(function (method) {
  PouchDB[method] = eventEmitter[method].bind(eventEmitter);
});
PouchDB.setMaxListeners(0);
PouchDB.parseAdapter = function (name, opts) {
  var match = name.match(/([a-z\-]*):\/\/(.*)/);
  var adapter, adapterName;
  if (match) {
    // the http adapter expects the fully qualified name
    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];
    adapter = match[1];
    if (!PouchDB.adapters[adapter].valid()) {
      throw 'Invalid adapter';
    }
    return {name: name, adapter: match[1]};
  }

  // check for browsers that have been upgraded from websql-only to websql+idb
  var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&
    utils.hasLocalStorage() &&
    global.localStorage['_pouch__websqldb_' + PouchDB.prefix + name];

  if (typeof opts !== 'undefined' && opts.db) {
    adapterName = 'leveldb';
  } else {
    for (var i = 0; i < PouchDB.preferredAdapters.length; ++i) {
      adapterName = PouchDB.preferredAdapters[i];
      if (adapterName in PouchDB.adapters) {
        if (skipIdb && adapterName === 'idb') {
          continue; // keep using websql to avoid user data loss
        }
        break;
      }
    }
  }

  adapter = PouchDB.adapters[adapterName];
  if (adapterName && adapter) {
    var use_prefix = 'use_prefix' in adapter ? adapter.use_prefix : true;

    return {
      name: use_prefix ? PouchDB.prefix + name : name,
      adapter: adapterName
    };
  }

  throw 'No valid adapter found';
};

PouchDB.destroy = utils.toPromise(function (name, opts, callback) {
  if (typeof opts === 'function' || typeof opts === 'undefined') {
    callback = opts;
    opts = {};
  }

  if (name && typeof name === 'object') {
    opts = name;
    name = undefined;
  }

  var backend = PouchDB.parseAdapter(opts.name || name, opts);
  var dbName = backend.name;
  var adapter = PouchDB.adapters[backend.adapter];
  var usePrefix = 'use_prefix' in adapter ? adapter.use_prefix : true;
  var baseName = usePrefix ?
    dbName.replace(new RegExp('^' + PouchDB.prefix), '') : dbName;
  var fullName = (backend.adapter === 'http' || backend.adapter === 'https' ?
      '' : (opts.prefix || '')) + dbName;
  function destroyDb() {
    // call destroy method of the particular adaptor
    adapter.destroy(fullName, opts, function (err, resp) {
      if (err) {
        callback(err);
      } else {
        PouchDB.emit('destroyed', name);
        //so we don't have to sift through all dbnames
        PouchDB.emit(name, 'destroyed');
        callback(null, resp || { 'ok': true });
      }
    });
  }

  var createOpts = utils.extend(true, {}, opts, {adapter : backend.adapter});
  new PouchDB(baseName, createOpts, function (err, db) {
    if (err) {
      return callback(err);
    }
    db.get('_local/_pouch_dependentDbs', function (err, localDoc) {
      if (err) {
        if (err.status !== 404) {
          return callback(err);
        } else { // no dependencies
          return destroyDb();
        }
      }
      var dependentDbs = localDoc.dependentDbs;
      var deletedMap = Object.keys(dependentDbs).map(function (name) {
        var trueName = usePrefix ?
          name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
        var subOpts = utils.extend(true, opts, {adapter: backend.adapter});
        return PouchDB.destroy(trueName, subOpts);
      });
      Promise.all(deletedMap).then(destroyDb, function (error) {
        callback(error);
      });
    });
  });
});

PouchDB.allDbs = utils.toPromise(function (callback) {
  var err = new Error('allDbs method removed');
  err.stats = '400';
  callback(err);
});
PouchDB.adapter = function (id, obj) {
  if (obj.valid()) {
    PouchDB.adapters[id] = obj;
  }
};

PouchDB.plugin = function (obj) {
  Object.keys(obj).forEach(function (id) {
    PouchDB.prototype[id] = obj[id];
  });
};

PouchDB.defaults = function (defaultOpts) {
  function PouchAlt(name, opts, callback) {
    if (typeof opts === 'function' || typeof opts === 'undefined') {
      callback = opts;
      opts = {};
    }
    if (name && typeof name === 'object') {
      opts = name;
      name = undefined;
    }

    opts = utils.extend(true, {}, defaultOpts, opts);
    PouchDB.call(this, name, opts, callback);
  }

  utils.inherits(PouchAlt, PouchDB);

  PouchAlt.destroy = utils.toPromise(function (name, opts, callback) {
    if (typeof opts === 'function' || typeof opts === 'undefined') {
      callback = opts;
      opts = {};
    }

    if (name && typeof name === 'object') {
      opts = name;
      name = undefined;
    }
    opts = utils.extend(true, {}, defaultOpts, opts);
    return PouchDB.destroy(name, opts, callback);
  });

  eventEmitterMethods.forEach(function (method) {
    PouchAlt[method] = eventEmitter[method].bind(eventEmitter);
  });
  PouchAlt.setMaxListeners(0);

  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();
  Object.keys(PouchDB).forEach(function (key) {
    if (!(key in PouchAlt)) {
      PouchAlt[key] = PouchDB[key];
    }
  });

  return PouchAlt;
};

module.exports = PouchDB;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapters/preferredAdapters.js":4,"./constructor":8,"./utils":26,"events":30}],24:[function(_dereq_,module,exports){
'use strict';
var utils = _dereq_('./utils');
var replication = _dereq_('./replicate');
var replicate = replication.replicate;
var EE = _dereq_('events').EventEmitter;

utils.inherits(Sync, EE);
module.exports = sync;
function sync(src, target, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }
  opts = utils.clone(opts);
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  src = replication.toPouch(src, opts);
  target = replication.toPouch(target, opts);
  return new Sync(src, target, opts, callback);
}
function Sync(src, target, opts, callback) {
  var self = this;
  this.canceled = false;
  
  var onChange, complete;
  if ('onChange' in opts) {
    onChange = opts.onChange;
    delete opts.onChange;
  }
  if (typeof callback === 'function' && !opts.complete) {
    complete = callback;
  } else if ('complete' in opts) {
    complete = opts.complete;
    delete opts.complete;
  }

  this.push = replicate(src, target, opts);

  this.pull = replicate(target, src, opts);
  var emittedCancel = false;
  function onCancel(data) {
    if (!emittedCancel) {
      emittedCancel = true;
      self.emit('cancel', data);
    }
  }

  function pullChange(change) {
    self.emit('change', {
      direction: 'pull',
      change: change
    });
  }
  function pushChange(change) {
    self.emit('change', {
      direction: 'push',
      change: change
    });
  }
  var listeners = {};

  var removed = {};
  function removeAll(type) { // type is 'push' or 'pull'
    return function (event, func) {
      var isChange = event === 'change' &&
        (func === pullChange || func === pushChange);
      var isCancel = event === 'cancel' && func === onCancel;
      var isOtherEvent = event in listeners && func === listeners[event];

      if (isChange || isCancel || isOtherEvent) {
        if (!(event in removed)) {
          removed[event] = {};
        }
        removed[event][type] = true;
        if (Object.keys(removed[event]).length === 2) {
          // both push and pull have asked to be removed
          self.removeAllListeners(event);
        }
      }
    };
  }

  this.on('newListener', function (event) {
    if (event === 'change') {
      self.pull.on('change', pullChange);
      self.push.on('change', pushChange);
    } else if (event === 'cancel') {
      self.pull.on('cancel', onCancel);
      self.push.on('cancel', onCancel);
    } else if (event !== 'error' &&
      event !== 'removeListener' &&
      event !== 'complete' && !(event in listeners)) {
      listeners[event] = function (e) {
        self.emit(event, e);
      };
      self.pull.on(event, listeners[event]);
      self.push.on(event, listeners[event]);
    }
  });

  this.on('removeListener', function (event) {
    if (event === 'change') {
      self.pull.removeListener('change', pullChange);
      self.push.removeListener('change', pushChange);
    } else if (event === 'cancel') {
      self.pull.removeListener('cancel', onCancel);
      self.push.removeListener('cancel', onCancel);
    } else if (event in listeners) {
      if (typeof listeners[event] === 'function') {
        self.pull.removeListener(event, listeners[event]);
        self.push.removeListener(event, listeners[event]);
        delete listeners[event];
      }
    }
  });

  this.pull.on('removeListener', removeAll('pull'));
  this.push.on('removeListener', removeAll('push'));

  var promise = utils.Promise.all([
    this.push,
    this.pull
  ]).then(function (resp) {
    var out = {
      push: resp[0],
      pull: resp[1]
    };
    self.emit('complete', out);
    if (complete) {
      complete(null, out);
    }
    self.removeAllListeners();
    return out;
  }, function (err) {
    self.cancel();
    self.emit('error', err);
    if (complete) {
      complete(err);
    }
    self.removeAllListeners();
    throw err;
  });

  this.then = function (success, err) {
    return promise.then(success, err);
  };

  this["catch"] = function (err) {
    return promise["catch"](err);
  };
}

Sync.prototype.cancel = function () {
  if (!this.canceled) {
    this.canceled = true;
    this.push.cancel();
    this.pull.cancel();
  }
};

},{"./replicate":22,"./utils":26,"events":30}],25:[function(_dereq_,module,exports){
'use strict';

module.exports = TaskQueue;

function TaskQueue() {
  this.isReady = false;
  this.failed = false;
  this.queue = [];
}

TaskQueue.prototype.execute = function () {
  var d, func;
  if (this.failed) {
    while ((d = this.queue.shift())) {
      if (typeof d === 'function') {
        d(this.failed);
        continue;
      }
      func = d.parameters[d.parameters.length - 1];
      if (typeof func === 'function') {
        func(this.failed);
      } else if (d.name === 'changes' && typeof func.complete === 'function') {
        func.complete(this.failed);
      }
    }
  } else if (this.isReady) {
    while ((d = this.queue.shift())) {

      if (typeof d === 'function') {
        d();
      } else {
        d.task = this.db[d.name].apply(this.db, d.parameters);
      }
    }
  }
};

TaskQueue.prototype.fail = function (err) {
  this.failed = err;
  this.execute();
};

TaskQueue.prototype.ready = function (db) {
  if (this.failed) {
    return false;
  } else if (arguments.length === 0) {
    return this.isReady;
  }
  this.isReady = db ? true: false;
  this.db = db;
  this.execute();
};

TaskQueue.prototype.addTask = function (name, parameters) {
  if (typeof name === 'function') {
    this.queue.push(name);
    if (this.failed) {
      this.execute();
    }
  } else {
    var task = { name: name, parameters: parameters };
    this.queue.push(task);
    if (this.failed) {
      this.execute();
    }
    return task;
  }
};

},{}],26:[function(_dereq_,module,exports){
(function (process,global){
/*jshint strict: false */
/*global chrome */
var merge = _dereq_('./merge');
exports.extend = _dereq_('pouchdb-extend');
exports.ajax = _dereq_('./deps/ajax');
exports.createBlob = _dereq_('./deps/blob');
exports.uuid = _dereq_('./deps/uuid');
exports.getArguments = _dereq_('argsarray');
var buffer = _dereq_('./deps/buffer');
var errors = _dereq_('./deps/errors');
var EventEmitter = _dereq_('events').EventEmitter;
var collections = _dereq_('./deps/collections');
exports.Map = collections.Map;
exports.Set = collections.Set;

if (typeof global.Promise === 'function') {
  exports.Promise = global.Promise;
} else {
  exports.Promise = _dereq_('bluebird');
}
var Promise = exports.Promise;

function toObject(array) {
  var obj = {};
  array.forEach(function (item) { obj[item] = true; });
  return obj;
}
// List of top level reserved words for doc
var reservedWords = toObject([
  '_id',
  '_rev',
  '_attachments',
  '_deleted',
  '_revisions',
  '_revs_info',
  '_conflicts',
  '_deleted_conflicts',
  '_local_seq',
  '_rev_tree',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats'
]);

// List of reserved words that should end up the document
var dataWords = toObject([
  '_attachments',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats'
]);

exports.lastIndexOf = function (str, char) {
  for (var i = str.length - 1; i >= 0; i--) {
    if (str.charAt(i) === char) {
      return i;
    }
  }
  return -1;
};
exports.clone = function (obj) {
  return exports.extend(true, {}, obj);
};
exports.inherits = _dereq_('inherits');
// Determine id an ID is valid
//   - invalid IDs begin with an underescore that does not begin '_design' or
//     '_local'
//   - any other string value is a valid id
// Returns the specific error object for each case
exports.invalidIdError = function (id) {
  var err;
  if (!id) {
    err = new TypeError(errors.MISSING_ID.message);
    err.status = 412;
  } else if (typeof id !== 'string') {
    err = new TypeError(errors.INVALID_ID.message);
    err.status = 400;
  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
    err = new TypeError(errors.RESERVED_ID.message);
    err.status = 400;
  }
  if (err) {
    throw err;
  }
};

function isChromeApp() {
  return (typeof chrome !== "undefined" &&
          typeof chrome.storage !== "undefined" &&
          typeof chrome.storage.local !== "undefined");
}

// Pretty dumb name for a function, just wraps callback calls so we dont
// to if (callback) callback() everywhere
exports.call = exports.getArguments(function (args) {
  if (!args.length) {
    return;
  }
  var fun = args.shift();
  if (typeof fun === 'function') {
    fun.apply(this, args);
  }
});

exports.isLocalId = function (id) {
  return (/^_local/).test(id);
};

// check if a specific revision of a doc has been deleted
//  - metadata: the metadata object from the doc store
//  - rev: (optional) the revision to check. defaults to winning revision
exports.isDeleted = function (metadata, rev) {
  if (!rev) {
    rev = merge.winningRev(metadata);
  }
  var dashIndex = rev.indexOf('-');
  if (dashIndex !== -1) {
    rev = rev.substring(dashIndex + 1);
  }
  var deleted = false;
  merge.traverseRevTree(metadata.rev_tree,
  function (isLeaf, pos, id, acc, opts) {
    if (id === rev) {
      deleted = !!opts.deleted;
    }
  });

  return deleted;
};

exports.revExists = function (metadata, rev) {
  var found = false;
  merge.traverseRevTree(metadata.rev_tree, function (leaf, pos, id, acc, opts) {
    if ((pos + '-' + id) === rev) {
      found = true;
    }
  });
  return found;
};

exports.filterChange = function (opts) {
  return function (change) {
    var req = {};
    var hasFilter = opts.filter && typeof opts.filter === 'function';

    req.query = opts.query_params;
    if (opts.filter && hasFilter && !opts.filter.call(this, change.doc, req)) {
      return false;
    }
    if (opts.doc_ids && opts.doc_ids.indexOf(change.id) === -1) {
      return false;
    }
    if (!opts.include_docs) {
      delete change.doc;
    } else {
      for (var att in change.doc._attachments) {
        if (change.doc._attachments.hasOwnProperty(att)) {
          change.doc._attachments[att].stub = true;
        }
      }
    }
    return true;
  };
};

// Preprocess documents, parse their revisions, assign an id and a
// revision for new writes that are missing them, etc
exports.parseDoc = function (doc, newEdits) {
  var nRevNum;
  var newRevId;
  var revInfo;
  var error;
  var opts = {status: 'available'};
  if (doc._deleted) {
    opts.deleted = true;
  }

  if (newEdits) {
    if (!doc._id) {
      doc._id = exports.uuid();
    }
    newRevId = exports.uuid(32, 16).toLowerCase();
    if (doc._rev) {
      revInfo = /^(\d+)-(.+)$/.exec(doc._rev);
      if (!revInfo) {
        var err = new TypeError("invalid value for property '_rev'");
        err.status = 400;
      }
      doc._rev_tree = [{
        pos: parseInt(revInfo[1], 10),
        ids: [revInfo[2], {status: 'missing'}, [[newRevId, opts, []]]]
      }];
      nRevNum = parseInt(revInfo[1], 10) + 1;
    } else {
      doc._rev_tree = [{
        pos: 1,
        ids : [newRevId, opts, []]
      }];
      nRevNum = 1;
    }
  } else {
    if (doc._revisions) {
      doc._rev_tree = [{
        pos: doc._revisions.start - doc._revisions.ids.length + 1,
        ids: doc._revisions.ids.reduce(function (acc, x) {
          if (acc === null) {
            return [x, opts, []];
          } else {
            return [x, {status: 'missing'}, [acc]];
          }
        }, null)
      }];
      nRevNum = doc._revisions.start;
      newRevId = doc._revisions.ids[0];
    }
    if (!doc._rev_tree) {
      revInfo = /^(\d+)-(.+)$/.exec(doc._rev);
      if (!revInfo) {
        error = new TypeError(errors.BAD_ARG.message);
        error.status = errors.BAD_ARG.status;
        throw error;
      }
      nRevNum = parseInt(revInfo[1], 10);
      newRevId = revInfo[2];
      doc._rev_tree = [{
        pos: parseInt(revInfo[1], 10),
        ids: [revInfo[2], opts, []]
      }];
    }
  }

  exports.invalidIdError(doc._id);

  doc._rev = [nRevNum, newRevId].join('-');

  var result = {metadata : {}, data : {}};
  for (var key in doc) {
    if (doc.hasOwnProperty(key)) {
      var specialKey = key[0] === '_';
      if (specialKey && !reservedWords[key]) {
        error = new Error(errors.DOC_VALIDATION.message + ': ' + key);
        error.status = errors.DOC_VALIDATION.status;
        throw error;
      } else if (specialKey && !dataWords[key]) {
        result.metadata[key.slice(1)] = doc[key];
      } else {
        result.data[key] = doc[key];
      }
    }
  }
  return result;
};

exports.isCordova = function () {
  return (typeof cordova !== "undefined" ||
          typeof PhoneGap !== "undefined" ||
          typeof phonegap !== "undefined");
};

exports.hasLocalStorage = function () {
  if (isChromeApp()) {
    return false;
  }
  try {
    return global.localStorage;
  } catch (e) {
    return false;
  }
};
exports.Changes = Changes;
exports.inherits(Changes, EventEmitter);
function Changes() {
  if (!(this instanceof Changes)) {
    return new Changes();
  }
  var self = this;
  EventEmitter.call(this);
  this.isChrome = isChromeApp();
  this.listeners = {};
  this.hasLocal = false;
  if (!this.isChrome) {
    this.hasLocal = exports.hasLocalStorage();
  }
  if (this.isChrome) {
    chrome.storage.onChanged.addListener(function (e) {
      // make sure it's event addressed to us
      if (e.db_name != null) {
        //object only has oldValue, newValue members
        self.emit(e.dbName.newValue);
      }
    });
  } else if (this.hasLocal) {
    if (global.addEventListener) {
      global.addEventListener("storage", function (e) {
        self.emit(e.key);
      });
    } else {
      global.attachEvent("storage", function (e) {
        self.emit(e.key);
      });
    }
  }

}
Changes.prototype.addListener = function (dbName, id, db, opts) {
  if (this.listeners[id]) {
    return;
  }
  function eventFunction() {
    db.changes({
      include_docs: opts.include_docs,
      conflicts: opts.conflicts,
      continuous: false,
      descending: false,
      filter: opts.filter,
      view: opts.view,
      since: opts.since,
      query_params: opts.query_params,
      onChange: function (c) {
        if (c.seq > opts.since && !opts.cancelled) {
          opts.since = c.seq;
          exports.call(opts.onChange, c);
        }
      }
    });
  }
  this.listeners[id] = eventFunction;
  this.on(dbName, eventFunction);
};

Changes.prototype.removeListener = function (dbName, id) {
  if (!(id in this.listeners)) {
    return;
  }
  EventEmitter.prototype.removeListener.call(this, dbName,
    this.listeners[id]);
};


Changes.prototype.notifyLocalWindows = function (dbName) {
  //do a useless change on a storage thing
  //in order to get other windows's listeners to activate
  if (this.isChrome) {
    chrome.storage.local.set({dbName: dbName});
  } else if (this.hasLocal) {
    localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
  }
};

Changes.prototype.notify = function (dbName) {
  this.emit(dbName);
  this.notifyLocalWindows(dbName);
};

if (!process.browser || !('atob' in global)) {
  exports.atob = function (str) {
    var base64 = new buffer(str, 'base64');
    // Node.js will just skip the characters it can't encode instead of
    // throwing and exception
    if (base64.toString('base64') !== str) {
      throw ("Cannot base64 encode full string");
    }
    return base64.toString('binary');
  };
} else {
  exports.atob = function (str) {
    return atob(str);
  };
}

if (!process.browser || !('btoa' in global)) {
  exports.btoa = function (str) {
    return new buffer(str, 'binary').toString('base64');
  };
} else {
  exports.btoa = function (str) {
    return btoa(str);
  };
}

// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
exports.fixBinary = function (bin) {
  if (!process.browser) {
    // don't need to do this in Node
    return bin;
  }

  var length = bin.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  for (var i = 0; i < length; i++) {
    arr[i] = bin.charCodeAt(i);
  }
  return buf;
};

// shim for browsers that don't support it
exports.readAsBinaryString = function (blob, callback) {
  var reader = new FileReader();
  var hasBinaryString = typeof reader.readAsBinaryString === 'function';
  reader.onloadend = function (e) {
    var result = e.target.result || '';
    if (hasBinaryString) {
      return callback(result);
    }
    callback(exports.arrayBufferToBinaryString(result));
  };
  if (hasBinaryString) {
    reader.readAsBinaryString(blob);
  } else {
    reader.readAsArrayBuffer(blob);
  }
};

exports.once = function (fun) {
  var called = false;
  return exports.getArguments(function (args) {
    if (called) {
      throw new Error('once called  more than once');
    } else {
      called = true;
      fun.apply(this, args);
    }
  });
};

exports.toPromise = function (func) {
  //create the function we will be returning
  return exports.getArguments(function (args) {
    var self = this;
    var tempCB =
      (typeof args[args.length - 1] === 'function') ? args.pop() : false;
    // if the last argument is a function, assume its a callback
    var usedCB;
    if (tempCB) {
      // if it was a callback, create a new callback which calls it,
      // but do so async so we don't trap any errors
      usedCB = function (err, resp) {
        process.nextTick(function () {
          tempCB(err, resp);
        });
      };
    }
    var promise = new Promise(function (fulfill, reject) {
      var resp;
      try {
        var callback = exports.once(function (err, mesg) {
          if (err) {
            reject(err);
          } else {
            fulfill(mesg);
          }
        });
        // create a callback for this invocation
        // apply the function in the orig context
        args.push(callback);
        resp = func.apply(self, args);
        if (resp && typeof resp.then === 'function') {
          fulfill(resp);
        }
      } catch (e) {
        reject(e);
      }
    });
    // if there is a callback, call it back
    if (usedCB) {
      promise.then(function (result) {
        usedCB(null, result);
      }, usedCB);
    }
    promise.cancel = function () {
      return this;
    };
    return promise;
  });
};

exports.adapterFun = function (name, callback) {
  return exports.toPromise(exports.getArguments(function (args) {
    if (this._closed) {
      return Promise.reject(new Error('database is closed'));
    }
    var self = this;
    if (!this.taskqueue.isReady) {
      return new exports.Promise(function (fulfill, reject) {
        self.taskqueue.addTask(function (failed) {
          if (failed) {
            reject(failed);
          } else {
            fulfill(self[name].apply(self, args));
          }
        });
      });
    }
    return callback.apply(this, args);
  }));
};
//Can't find original post, but this is close
//http://stackoverflow.com/questions/6965107/ (continues on next line)
//converting-between-strings-and-arraybuffers
exports.arrayBufferToBinaryString = function (buffer) {
  var binary = "";
  var bytes = new Uint8Array(buffer);
  var length = bytes.byteLength;
  for (var i = 0; i < length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return binary;
};

exports.cancellableFun = function (fun, self, opts) {

  opts = opts ? exports.clone(true, {}, opts) : {};

  var emitter = new EventEmitter();
  var oldComplete = opts.complete || function () { };
  var complete = opts.complete = exports.once(function (err, resp) {
    if (err) {
      oldComplete(err);
    } else {
      emitter.emit('end', resp);
      oldComplete(null, resp);
    }
    emitter.removeAllListeners();
  });
  var oldOnChange = opts.onChange || function () {};
  var lastChange = 0;
  self.on('destroyed', function () {
    emitter.removeAllListeners();
  });
  opts.onChange = function (change) {
    oldOnChange(change);
    if (change.seq <= lastChange) {
      return;
    }
    lastChange = change.seq;
    emitter.emit('change', change);
    if (change.deleted) {
      emitter.emit('delete', change);
    } else if (change.changes.length === 1 &&
      change.changes[0].rev.slice(0, 1) === '1-') {
      emitter.emit('create', change);
    } else {
      emitter.emit('update', change);
    }
  };
  var promise = new Promise(function (fulfill, reject) {
    opts.complete = function (err, res) {
      if (err) {
        reject(err);
      } else {
        fulfill(res);
      }
    };
  });

  promise.then(function (result) {
    complete(null, result);
  }, complete);

  // this needs to be overwridden by caller, dont fire complete until
  // the task is ready
  promise.cancel = function () {
    promise.isCancelled = true;
    if (self.taskqueue.isReady) {
      opts.complete(null, {status: 'cancelled'});
    }
  };

  if (!self.taskqueue.isReady) {
    self.taskqueue.addTask(function () {
      if (promise.isCancelled) {
        opts.complete(null, {status: 'cancelled'});
      } else {
        fun(self, opts, promise);
      }
    });
  } else {
    fun(self, opts, promise);
  }
  promise.on = emitter.on.bind(emitter);
  promise.once = emitter.once.bind(emitter);
  promise.addListener = emitter.addListener.bind(emitter);
  promise.removeListener = emitter.removeListener.bind(emitter);
  promise.removeAllListeners = emitter.removeAllListeners.bind(emitter);
  promise.setMaxListeners = emitter.setMaxListeners.bind(emitter);
  promise.listeners = emitter.listeners.bind(emitter);
  promise.emit = emitter.emit.bind(emitter);
  return promise;
};

exports.MD5 = exports.toPromise(_dereq_('./deps/md5'));

// designed to give info to browser users, who are disturbed
// when they see 404s in the console
exports.explain404 = function (str) {
  if (process.browser && 'console' in global && 'info' in console) {
    console.info('The above 404 is totally normal. ' +
      str + '\n\u2665 the PouchDB team');
  }
};

exports.parseUri = _dereq_('./deps/parse-uri');

exports.compare = function (left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
};
}).call(this,_dereq_("/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./deps/ajax":9,"./deps/blob":10,"./deps/buffer":29,"./deps/collections":11,"./deps/errors":12,"./deps/md5":13,"./deps/parse-uri":15,"./deps/uuid":17,"./merge":21,"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":31,"argsarray":28,"bluebird":36,"events":30,"inherits":32,"pouchdb-extend":51}],27:[function(_dereq_,module,exports){
module.exports = "3.1.0";

},{}],28:[function(_dereq_,module,exports){
'use strict';

module.exports = argsArray;

function argsArray(fun) {
  return function () {
    var len = arguments.length;
    if (len) {
      var args = [];
      var i = -1;
      while (++i < len) {
        args[i] = arguments[i];
      }
      return fun.call(this, args);
    } else {
      return fun.call(this, []);
    }
  };
}
},{}],29:[function(_dereq_,module,exports){

},{}],30:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],31:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],32:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],33:[function(_dereq_,module,exports){
'use strict';

module.exports = INTERNAL;

function INTERNAL() {}
},{}],34:[function(_dereq_,module,exports){
'use strict';
var Promise = _dereq_('./promise');
var reject = _dereq_('./reject');
var resolve = _dereq_('./resolve');
var INTERNAL = _dereq_('./INTERNAL');
var handlers = _dereq_('./handlers');
module.exports = all;
function all(iterable) {
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new Promise(INTERNAL);
  
  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len & !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}
},{"./INTERNAL":33,"./handlers":35,"./promise":37,"./reject":40,"./resolve":41}],35:[function(_dereq_,module,exports){
'use strict';
var tryCatch = _dereq_('./tryCatch');
var resolveThenable = _dereq_('./resolveThenable');
var states = _dereq_('./states');

exports.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return exports.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    resolveThenable.safely(self, thenable);
  } else {
    self.state = states.FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
exports.reject = function (self, error) {
  self.state = states.REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && typeof obj === 'object' && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}
},{"./resolveThenable":42,"./states":43,"./tryCatch":44}],36:[function(_dereq_,module,exports){
module.exports = exports = _dereq_('./promise');

exports.resolve = _dereq_('./resolve');
exports.reject = _dereq_('./reject');
exports.all = _dereq_('./all');
exports.race = _dereq_('./race');
},{"./all":34,"./promise":37,"./race":39,"./reject":40,"./resolve":41}],37:[function(_dereq_,module,exports){
'use strict';

var unwrap = _dereq_('./unwrap');
var INTERNAL = _dereq_('./INTERNAL');
var resolveThenable = _dereq_('./resolveThenable');
var states = _dereq_('./states');
var QueueItem = _dereq_('./queueItem');

module.exports = Promise;
function Promise(resolver) {
  if (!(this instanceof Promise)) {
    return new Promise(resolver);
  }
  if (typeof resolver !== 'function') {
    throw new TypeError('reslover must be a function');
  }
  this.state = states.PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    resolveThenable.safely(this, resolver);
  }
}

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === states.FULFILLED ||
    typeof onRejected !== 'function' && this.state === states.REJECTED) {
    return this;
  }
  var promise = new Promise(INTERNAL);

  
  if (this.state !== states.PENDING) {
    var resolver = this.state === states.FULFILLED ? onFulfilled: onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};

},{"./INTERNAL":33,"./queueItem":38,"./resolveThenable":42,"./states":43,"./unwrap":45}],38:[function(_dereq_,module,exports){
'use strict';
var handlers = _dereq_('./handlers');
var unwrap = _dereq_('./unwrap');

module.exports = QueueItem;
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};
},{"./handlers":35,"./unwrap":45}],39:[function(_dereq_,module,exports){
'use strict';
var Promise = _dereq_('./promise');
var reject = _dereq_('./reject');
var resolve = _dereq_('./resolve');
var INTERNAL = _dereq_('./INTERNAL');
var handlers = _dereq_('./handlers');
module.exports = race;
function race(iterable) {
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return resolve([]);
  }

  var resolved = 0;
  var i = -1;
  var promise = new Promise(INTERNAL);
  
  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}
},{"./INTERNAL":33,"./handlers":35,"./promise":37,"./reject":40,"./resolve":41}],40:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_('./promise');
var INTERNAL = _dereq_('./INTERNAL');
var handlers = _dereq_('./handlers');
module.exports = reject;

function reject(reason) {
	var promise = new Promise(INTERNAL);
	return handlers.reject(promise, reason);
}
},{"./INTERNAL":33,"./handlers":35,"./promise":37}],41:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_('./promise');
var INTERNAL = _dereq_('./INTERNAL');
var handlers = _dereq_('./handlers');
module.exports = resolve;

var FALSE = handlers.resolve(new Promise(INTERNAL), false);
var NULL = handlers.resolve(new Promise(INTERNAL), null);
var UNDEFINED = handlers.resolve(new Promise(INTERNAL), void 0);
var ZERO = handlers.resolve(new Promise(INTERNAL), 0);
var EMPTYSTRING = handlers.resolve(new Promise(INTERNAL), '');

function resolve(value) {
  if (value) {
    if (value instanceof Promise) {
      return value;
    }
    return handlers.resolve(new Promise(INTERNAL), value);
  }
  var valueType = typeof value;
  switch (valueType) {
    case 'boolean':
      return FALSE;
    case 'undefined':
      return UNDEFINED;
    case 'object':
      return NULL;
    case 'number':
      return ZERO;
    case 'string':
      return EMPTYSTRING;
  }
}
},{"./INTERNAL":33,"./handlers":35,"./promise":37}],42:[function(_dereq_,module,exports){
'use strict';
var handlers = _dereq_('./handlers');
var tryCatch = _dereq_('./tryCatch');
function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }
  
  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}
exports.safely = safelyResolveThenable;
},{"./handlers":35,"./tryCatch":44}],43:[function(_dereq_,module,exports){
// Lazy man's symbols for states

exports.REJECTED = ['REJECTED'];
exports.FULFILLED = ['FULFILLED'];
exports.PENDING = ['PENDING'];
},{}],44:[function(_dereq_,module,exports){
'use strict';

module.exports = tryCatch;

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}
},{}],45:[function(_dereq_,module,exports){
'use strict';

var immediate = _dereq_('immediate');
var handlers = _dereq_('./handlers');
module.exports = unwrap;

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}
},{"./handlers":35,"immediate":46}],46:[function(_dereq_,module,exports){
'use strict';
var types = [
  _dereq_('./nextTick'),
  _dereq_('./mutation.js'),
  _dereq_('./messageChannel'),
  _dereq_('./stateChange'),
  _dereq_('./timeout')
];
var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++ i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}
},{"./messageChannel":47,"./mutation.js":48,"./nextTick":29,"./stateChange":49,"./timeout":50}],47:[function(_dereq_,module,exports){
(function (global){
'use strict';

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],48:[function(_dereq_,module,exports){
(function (global){
'use strict';
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],49:[function(_dereq_,module,exports){
(function (global){
'use strict';

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],50:[function(_dereq_,module,exports){
'use strict';
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};
},{}],51:[function(_dereq_,module,exports){
"use strict";

// Extends method
// (taken from http://code.jquery.com/jquery-1.9.0.js)
// Populate the class2type map
var class2type = {};

var types = [
  "Boolean", "Number", "String", "Function", "Array",
  "Date", "RegExp", "Object", "Error"
];
for (var i = 0; i < types.length; i++) {
  var typename = types[i];
  class2type["[object " + typename + "]"] = typename.toLowerCase();
}

var core_toString = class2type.toString;
var core_hasOwn = class2type.hasOwnProperty;

function type(obj) {
  if (obj === null) {
    return String(obj);
  }
  return typeof obj === "object" || typeof obj === "function" ?
    class2type[core_toString.call(obj)] || "object" :
    typeof obj;
}

function isWindow(obj) {
  return obj !== null && obj === obj.window;
}

function isPlainObject(obj) {
  // Must be an Object.
  // Because of IE, we also have to check the presence of
  // the constructor property.
  // Make sure that DOM nodes and window objects don't pass through, as well
  if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
    return false;
  }

  try {
    // Not own constructor property must be Object
    if (obj.constructor &&
      !core_hasOwn.call(obj, "constructor") &&
      !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
      return false;
    }
  } catch ( e ) {
    // IE8,9 Will throw exceptions on certain host objects #9897
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {}

  return key === undefined || core_hasOwn.call(obj, key);
}


function isFunction(obj) {
  return type(obj) === "function";
}

var isArray = Array.isArray || function (obj) {
  return type(obj) === "array";
};

function extend() {
  // originally extend() was recursive, but this ended up giving us
  // "call stack exceeded", so it's been unrolled to use a literal stack
  // (see https://github.com/pouchdb/pouchdb/issues/2543)
  var stack = [];
  var i = -1;
  var len = arguments.length;
  var args = new Array(len);
  while (++i < len) {
    args[i] = arguments[i];
  }
  var container = {};
  stack.push({args: args, result: {container: container, key: 'key'}});
  var next;
  while ((next = stack.pop())) {
    extendInner(stack, next.args, next.result);
  }
  return container.key;
}

function extendInner(stack, args, result) {
  var options, name, src, copy, copyIsArray, clone,
    target = args[0] || {},
    i = 1,
    length = args.length,
    deep = false,
    numericStringRegex = /\d+/,
    optionsIsArray;

  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;
    target = args[1] || {};
    // skip the boolean and the target
    i = 2;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== "object" && !isFunction(target)) {
    target = {};
  }

  // extend jQuery itself if only one argument is passed
  if (length === i) {
    /* jshint validthis: true */
    target = this;
    --i;
  }

  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    if ((options = args[i]) != null) {
      optionsIsArray = isArray(options);
      // Extend the base object
      for (name in options) {
        //if (options.hasOwnProperty(name)) {
        if (!(name in Object.prototype)) {
          if (optionsIsArray && !numericStringRegex.test(name)) {
            continue;
          }

          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (isPlainObject(copy) ||
              (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];

            } else {
              clone = src && isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            stack.push({
              args: [deep, clone, copy],
              result: {
                container: target,
                key: name
              }
            });

          // Don't bring in undefined values
          } else if (copy !== undefined) {
            if (!(isArray(options) && isFunction(copy))) {
              target[name] = copy;
            }
          }
        }
      }
    }
  }

  // "Return" the modified object by setting the key
  // on the given container
  result.container[result.key] = target;
}


module.exports = extend;



},{}],52:[function(_dereq_,module,exports){
'use strict';

var upsert = _dereq_('./upsert');
var utils = _dereq_('./utils');
var Promise = utils.Promise;

module.exports = function (opts) {
  var sourceDB = opts.db;
  var viewName = opts.viewName;
  var mapFun = opts.map;
  var reduceFun = opts.reduce;
  var temporary = opts.temporary;

  // the "undefined" part is for backwards compatibility
  var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +
    'undefined';

  if (!temporary && sourceDB._cachedViews) {
    var cachedView = sourceDB._cachedViews[viewSignature];
    if (cachedView) {
      return Promise.resolve(cachedView);
    }
  }

  return sourceDB.info().then(function (info) {

    var depDbName = info.db_name + '-mrview-' +
      (temporary ? 'temp' : utils.MD5(viewSignature));

    // save the view name in the source PouchDB so it can be cleaned up if necessary
    // (e.g. when the _design doc is deleted, remove all associated view data)
    function diffFunction(doc) {
      doc.views = doc.views || {};
      var fullViewName = viewName;
      if (fullViewName.indexOf('/') === -1) {
        fullViewName = viewName + '/' + viewName;
      }
      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
      /* istanbul ignore if */
      if (depDbs[depDbName]) {
        return; // no update necessary
      }
      depDbs[depDbName] = true;
      return doc;
    }
    return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {
      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
        var db = res.db;
        db.auto_compaction = true;
        var view = {
          name: depDbName,
          db: db, 
          sourceDB: sourceDB,
          adapter: sourceDB.adapter,
          mapFun: mapFun,
          reduceFun: reduceFun
        };
        return view.db.get('_local/lastSeq')["catch"](function (err) {
          /* istanbul ignore if */
          if (err.status !== 404) {
            throw err;
          }
        }).then(function (lastSeqDoc) {
          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
          if (!temporary) {
            sourceDB._cachedViews = sourceDB._cachedViews || {};
            sourceDB._cachedViews[viewSignature] = view;
            view.db.on('destroyed', function () {
              delete sourceDB._cachedViews[viewSignature];
            });
          }
          return view;
        });
      });
    });
  });
};

},{"./upsert":58,"./utils":59}],53:[function(_dereq_,module,exports){
'use strict';

module.exports = function (func, emit, sum, log, isArray, toJSON) {
  /*jshint evil:true,unused:false */
  return eval("'use strict'; (" + func.replace(/;\s*$/, "") + ");");
};

},{}],54:[function(_dereq_,module,exports){
(function (process){
'use strict';

var pouchCollate = _dereq_('pouchdb-collate');
var TaskQueue = _dereq_('./taskqueue');
var collate = pouchCollate.collate;
var toIndexableString = pouchCollate.toIndexableString;
var normalizeKey = pouchCollate.normalizeKey;
var createView = _dereq_('./create-view');
var evalFunc = _dereq_('./evalfunc');
var log; 
/* istanbul ignore else */
if ((typeof console !== 'undefined') && (typeof console.log === 'function')) {
  log = Function.prototype.bind.call(console.log, console);
} else {
  log = function () {};
}
var utils = _dereq_('./utils');
var Promise = utils.Promise;
var mainQueue = new TaskQueue();
var tempViewQueue = new TaskQueue();
var CHANGES_BATCH_SIZE = 50;

function parseViewName(name) {
  // can be either 'ddocname/viewname' or just 'viewname'
  // (where the ddoc name is the same)
  return name.indexOf('/') === -1 ? [name, name] : name.split('/');
}

function tryCode(db, fun, args) {
  // emit an event if there was an error thrown by a map/reduce function.
  // putting try/catches in a single function also avoids deoptimizations.
  try {
    return {
      output : fun.apply(null, args)
    };
  } catch (e) {
    db.emit('error', e);
    return {error : e};
  }
}

function sortByKeyThenValue(x, y) {
  var keyCompare = collate(x.key, y.key);
  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
}

function sliceResults(results, limit, skip) {
  skip = skip || 0;
  if (typeof limit === 'number') {
    return results.slice(skip, limit + skip);
  } else if (skip > 0) {
    return results.slice(skip);
  }
  return results;
}

function createBuiltInError(name) {
  var error = new Error('builtin ' + name +
    ' function requires map values to be numbers' +
    ' or number arrays');
  error.name = 'invalid_value';
  error.status = 500;
  return error;
}

function sum(values) {
  var result = 0;
  for (var i = 0, len = values.length; i < len; i++) {
    var num = values[i];
    if (typeof num !== 'number') {
      if (Array.isArray(num)) {
        // lists of numbers are also allowed, sum them separately
        result = typeof result === 'number' ? [result] : result;
        for (var j = 0, jLen = num.length; j < jLen; j++) {
          var jNum = num[j];
          if (typeof jNum !== 'number') {
            throw createBuiltInError('_sum');
          } else if (typeof result[j] === 'undefined') {
            result.push(jNum);
          } else {
            result[j] += jNum;
          }
        }
      } else { // not array/number
        throw createBuiltInError('_sum');
      }
    } else if (typeof result === 'number') {
      result += num;
    } else { // add number to array
      result[0] += num;
    }
  }
  return result;
}

var builtInReduce = {
  _sum: function (keys, values) {
    return sum(values);
  },

  _count: function (keys, values) {
    return values.length;
  },

  _stats: function (keys, values) {
    // no need to implement rereduce=true, because Pouch
    // will never call it
    function sumsqr(values) {
      var _sumsqr = 0;
      for (var i = 0, len = values.length; i < len; i++) {
        var num = values[i];
        _sumsqr += (num * num);
      }
      return _sumsqr;
    }
    return {
      sum     : sum(values),
      min     : Math.min.apply(null, values),
      max     : Math.max.apply(null, values),
      count   : values.length,
      sumsqr : sumsqr(values)
    };
  }
};

function addHttpParam(paramName, opts, params, asJson) {
  // add an http param from opts to params, optionally json-encoded
  var val = opts[paramName];
  if (typeof val !== 'undefined') {
    if (asJson) {
      val = encodeURIComponent(JSON.stringify(val));
    }
    params.push(paramName + '=' + val);
  }
}

function checkQueryParseError(options, fun) {
  var startkeyName = options.descending ? 'endkey' : 'startkey';
  var endkeyName = options.descending ? 'startkey' : 'endkey';

  if (typeof options[startkeyName] !== 'undefined' &&
    typeof options[endkeyName] !== 'undefined' &&
    collate(options[startkeyName], options[endkeyName]) > 0) {
    throw new QueryParseError('No rows can match your key range, reverse your ' +
        'start_key and end_key or set {descending : true}');
  } else if (fun.reduce && options.reduce !== false) {
    if (options.include_docs) {
      throw new QueryParseError('{include_docs:true} is invalid for reduce');
    } else if (options.keys && options.keys.length > 1 &&
        !options.group && !options.group_level) {
      throw new QueryParseError('Multi-key fetches for reduce views must use {group: true}');
    }
  }
  if (options.group_level) {
    if (typeof options.group_level !== 'number') {
      throw new QueryParseError('Invalid value for integer: "' + options.group_level + '"');
    }
    if (options.group_level < 0) {
      throw new QueryParseError('Invalid value for positive integer: ' +
        '"' + options.group_level + '"');
    }
  }
}

function httpQuery(db, fun, opts) {
  // List of parameters to add to the PUT request
  var params = [];
  var body;
  var method = 'GET';

  // If opts.reduce exists and is defined, then add it to the list
  // of parameters.
  // If reduce=false then the results are that of only the map function
  // not the final result of map and reduce.
  addHttpParam('reduce', opts, params);
  addHttpParam('include_docs', opts, params);
  addHttpParam('limit', opts, params);
  addHttpParam('descending', opts, params);
  addHttpParam('group', opts, params);
  addHttpParam('group_level', opts, params);
  addHttpParam('skip', opts, params);
  addHttpParam('stale', opts, params);
  addHttpParam('conflicts', opts, params);
  addHttpParam('startkey', opts, params, true);
  addHttpParam('endkey', opts, params, true);
  addHttpParam('inclusive_end', opts, params);
  addHttpParam('key', opts, params, true);

  // Format the list of parameters into a valid URI query string
  params = params.join('&');
  params = params === '' ? '' : '?' + params;

  // If keys are supplied, issue a POST request to circumvent GET query string limits
  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
  if (typeof opts.keys !== 'undefined') {
    var MAX_URL_LENGTH = 2000;
    // according to http://stackoverflow.com/a/417184/680742,
    // the de facto URL length limit is 2000 characters

    var keysAsString =
      'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
    if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
      // If the keys are short enough, do a GET. we do this to work around
      // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)
      params += (params[0] === '?' ? '&' : '?') + keysAsString;
    } else {
      method = 'POST';
      if (typeof fun === 'string') {
        body = JSON.stringify({keys: opts.keys});
      } else { // fun is {map : mapfun}, so append to this
        fun.keys = opts.keys;
      }
    }
  }

  // We are referencing a query defined in the design doc
  if (typeof fun === 'string') {
    var parts = parseViewName(fun);
    return db.request({
      method: method,
      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,
      body: body
    });
  }

  // We are using a temporary view, terrible for performance but good for testing
  body = body || {};
  Object.keys(fun).forEach(function (key) {
    if (Array.isArray(fun[key])) {
      body[key] = fun[key];
    } else {
      body[key] = fun[key].toString();
    }
  });
  return db.request({
    method: 'POST',
    url: '_temp_view' + params,
    body: body
  });
}

function defaultsTo(value) {
  return function (reason) {
    /* istanbul ignore else */
    if (reason.status === 404) {
      return value;
    } else {
      throw reason;
    }
  };
}

// returns a promise for a list of docs to update, based on the input docId.
// we update the metaDoc first (i.e. the doc that points from the sourceDB
// document Id to the ids of the documents in the mrview database), then
// the key/value docs.  that way, if lightning strikes the user's computer
// in the middle of an update, we don't write any docs that we wouldn't
// be able to find later using the metaDoc.
function getDocsToPersist(docId, view, docIdsToEmits) {
  var metaDocId = '_local/doc_' + docId;
  return view.db.get(metaDocId)[
    "catch"](defaultsTo({_id: metaDocId, keys: []}))
    .then(function (metaDoc) {
      return Promise.resolve().then(function () {
        if (metaDoc.keys.length) {
          return view.db.allDocs({
            keys: metaDoc.keys,
            include_docs: true
          });
        }
        return {rows: []}; // no keys, no need for a lookup
      }).then(function (res) {
        var kvDocs = res.rows.map(function (row) {
          return row.doc;
        }).filter(function (row) {
          return row;
        });

        var indexableKeysToKeyValues = docIdsToEmits[docId];
        var oldKeysMap = {};
        kvDocs.forEach(function (kvDoc) {
          oldKeysMap[kvDoc._id] = true;
          kvDoc._deleted = !indexableKeysToKeyValues[kvDoc._id];
          if (!kvDoc._deleted) {
            var keyValue = indexableKeysToKeyValues[kvDoc._id];
            if ('value' in keyValue) {
              kvDoc.value = keyValue.value;
            }
          }
        });

        var newKeys = Object.keys(indexableKeysToKeyValues);
        newKeys.forEach(function (key) {
          if (!oldKeysMap[key]) {
            // new doc
            var kvDoc = {
              _id: key
            };
            var keyValue = indexableKeysToKeyValues[key];
            if ('value' in keyValue) {
              kvDoc.value = keyValue.value;
            }
            kvDocs.push(kvDoc);
          }
        });
        metaDoc.keys = utils.uniq(newKeys.concat(metaDoc.keys));
        kvDocs.splice(0, 0, metaDoc);

        return kvDocs;
      });
    });
}

// updates all emitted key/value docs and metaDocs in the mrview database
// for the given batch of documents from the source database
function saveKeyValues(view, docIdsToEmits, seq) {
  var seqDocId = '_local/lastSeq';
  return view.db.get(seqDocId)[
  "catch"](defaultsTo({_id: seqDocId, seq: 0}))
  .then(function (lastSeqDoc) {
    var docIds = Object.keys(docIdsToEmits);
    return Promise.all(docIds.map(function (docId) {
        return getDocsToPersist(docId, view, docIdsToEmits);
      })).then(function (listOfDocsToPersist) {
        var docsToPersist = [];
        listOfDocsToPersist.forEach(function (docList) {
          docsToPersist = docsToPersist.concat(docList);
        });

        // update the seq doc last, so that if a meteor strikes the user's
        // computer in the middle of an update, we can apply the idempotent
        // batch update operation again
        lastSeqDoc.seq = seq;
        docsToPersist.push(lastSeqDoc);

        return view.db.bulkDocs({docs : docsToPersist});
      });
  });
}

var updateView = utils.sequentialize(mainQueue, function (view) {
  // bind the emit function once
  var mapResults;
  var doc;

  function emit(key, value) {
    var output = { id: doc._id, key: normalizeKey(key) };
    // Don't explicitly store the value unless it's defined and non-null.
    // This saves on storage space, because often people don't use it.
    if (typeof value !== 'undefined' && value !== null) {
      output.value = normalizeKey(value);
    }
    mapResults.push(output);
  }

  var mapFun;
  // for temp_views one can use emit(doc, emit), see #38
  if (typeof view.mapFun === "function" && view.mapFun.length === 2) {
    var origMap = view.mapFun;
    mapFun = function (doc) {
      return origMap(doc, emit);
    };
  } else {
    mapFun = evalFunc(view.mapFun.toString(), emit, sum, log, Array.isArray, JSON.parse);
  }

  var currentSeq = view.seq || 0;

  function processChange(docIdsToEmits, seq) {
    return function () {
      return saveKeyValues(view, docIdsToEmits, seq);
    };
  }
  var queue = new TaskQueue();
  // TODO(neojski): https://github.com/daleharvey/pouchdb/issues/1521

  return new Promise(function (resolve, reject) {

    function complete() {
      queue.finish().then(function () {
        view.seq = currentSeq;
        resolve();
      });
    }

    function processNextBatch() {
      view.sourceDB.changes({
        conflicts: true,
        include_docs: true,
        since : currentSeq,
        limit : CHANGES_BATCH_SIZE
      }).on('complete', function (response) {
        var results = response.results;
        if (!results.length) {
          return complete();
        }
        var docIdsToEmits = {};
        for (var i = 0, l = results.length; i < l; i++) {
          var change = results[i];
          if (change.doc._id[0] !== '_') {
            mapResults = [];
            doc = change.doc;

            if (!doc._deleted) {
              tryCode(view.sourceDB, mapFun, [doc]);
            }
            mapResults.sort(sortByKeyThenValue);

            var indexableKeysToKeyValues = {};
            var lastKey;
            for (var j = 0, jl = mapResults.length; j < jl; j++) {
              var obj = mapResults[j];
              var complexKey = [obj.key, obj.id];
              if (obj.key === lastKey) {
                complexKey.push(j); // dup key+id, so make it unique
              }
              var indexableKey = toIndexableString(complexKey);
              indexableKeysToKeyValues[indexableKey] = obj;
              lastKey = obj.key;
            }
            docIdsToEmits[change.doc._id] = indexableKeysToKeyValues;
          }
          currentSeq = change.seq;
        }
        queue.add(processChange(docIdsToEmits, currentSeq));
        if (results.length < CHANGES_BATCH_SIZE) {
          return complete();
        }
        return processNextBatch();
      }).on('error', onError);
      /* istanbul ignore next */
      function onError(err) {
        reject(err);
      }
    }
    processNextBatch();
  });
});

function reduceView(view, results, options) {
  if (options.group_level === 0) {
    delete options.group_level;
  }

  var shouldGroup = options.group || options.group_level;

  var reduceFun;
  if (builtInReduce[view.reduceFun]) {
    reduceFun = builtInReduce[view.reduceFun];
  } else {
    reduceFun = evalFunc(
      view.reduceFun.toString(), null, sum, log, Array.isArray, JSON.parse);
  }

  var groups = [];
  var lvl = options.group_level;
  results.forEach(function (e) {
    var last = groups[groups.length - 1];
    var key = shouldGroup ? e.key : null;

    // only set group_level for array keys
    if (shouldGroup && Array.isArray(key) && typeof lvl === 'number') {
      key = key.length > lvl ? key.slice(0, lvl) : key;
    }

    if (last && collate(last.key[0][0], key) === 0) {
      last.key.push([key, e.id]);
      last.value.push(e.value);
      return;
    }
    groups.push({key: [
      [key, e.id]
    ], value: [e.value]});
  });
  for (var i = 0, len = groups.length; i < len; i++) {
    var e = groups[i];
    var reduceTry = tryCode(view.sourceDB, reduceFun, [e.key, e.value, false]);
    // CouchDB typically just sets the value to null if reduce errors out
    e.value = reduceTry.error ? null : reduceTry.output;
    e.key = e.key[0][0];
  }
  // no total_rows/offset when reducing
  return {rows: sliceResults(groups, options.limit, options.skip)};
}

var queryView = utils.sequentialize(mainQueue, function (view, opts) {
  var totalRows;
  var shouldReduce = view.reduceFun && opts.reduce !== false;
  var skip = opts.skip || 0;
  if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
    // equivalent query
    opts.limit = 0;
    delete opts.keys;
  }

  function fetchFromView(viewOpts) {
    viewOpts.include_docs = true;
    return view.db.allDocs(viewOpts).then(function (res) {
      totalRows = res.total_rows;
      return res.rows.map(function (result) {

        // implicit migration - in older versions of PouchDB,
        // we explicitly stored the doc as {id: ..., key: ..., value: ...}
        // this is tested in a migration test
        /* istanbul ignore next */
        if ('value' in result.doc && typeof result.doc.value === 'object' &&
            result.doc.value !== null) {
          var keys = Object.keys(result.doc.value).sort();
          // this detection method is not perfect, but it's unlikely the user
          // emitted a value which was an object with these 3 exact keys
          var expectedKeys = ['id', 'key', 'value'];
          if (!(keys < expectedKeys || keys > expectedKeys)) {
            return result.doc.value;
          }
        }

        var parsedKeyAndDocId = pouchCollate.parseIndexableString(result.doc._id);
        return {
          key: parsedKeyAndDocId[0],
          id: parsedKeyAndDocId[1],
          value: ('value' in result.doc ? result.doc.value : null)
        };
      });
    });
  }

  function onMapResultsReady(results) {
    var res;
    if (shouldReduce) {
      res = reduceView(view, results, opts);
    } else {
      res = {
        total_rows: totalRows,
        offset: skip,
        rows: results
      };
    }
    if (opts.include_docs) {
      var getDocsPromises = results.map(function (row) {
        var val = row.value;
        var docId = (val && typeof val === 'object' && val._id) || row.id;
        return view.sourceDB.get(docId, {conflicts: opts.conflicts}).then(function (joinedDoc) {
          row.doc = joinedDoc;
        }, function () {
          // document error = don't join
        });
      });
      return Promise.all(getDocsPromises).then(function () {
        return res;
      });
    } else {
      return res;
    }
  }

  var flatten = function (array) {
    return array.reduce(function (prev, cur) {
      return prev.concat(cur);
    });
  };

  if (typeof opts.keys !== 'undefined') {
    var keys = opts.keys;
    var fetchPromises = keys.map(function (key) {
      var viewOpts = {
        startkey : toIndexableString([key]),
        endkey   : toIndexableString([key, {}])
      };
      return fetchFromView(viewOpts);
    });
    return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);
  } else { // normal query, no 'keys'
    var viewOpts = {
      descending : opts.descending
    };
    if (typeof opts.startkey !== 'undefined') {
      viewOpts.startkey = opts.descending ?
        toIndexableString([opts.startkey, {}]) :
        toIndexableString([opts.startkey]);
    }
    if (typeof opts.endkey !== 'undefined') {
      var inclusiveEnd = opts.inclusive_end !== false;
      if (opts.descending) {
        inclusiveEnd = !inclusiveEnd;
      }

      viewOpts.endkey = toIndexableString(inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);
    }
    if (typeof opts.key !== 'undefined') {
      var keyStart = toIndexableString([opts.key]);
      var keyEnd = toIndexableString([opts.key, {}]);
      if (viewOpts.descending) {
        viewOpts.endkey = keyStart;
        viewOpts.startkey = keyEnd;
      } else {
        viewOpts.startkey = keyStart;
        viewOpts.endkey = keyEnd;
      }
    }
    if (!shouldReduce) {
      if (typeof opts.limit === 'number') {
        viewOpts.limit = opts.limit;
      }
      viewOpts.skip = skip;
    }
    return fetchFromView(viewOpts).then(onMapResultsReady);
  }
});

function httpViewCleanup(db) {
  return db.request({
    method: 'POST',
    url: '_view_cleanup'
  });
}

var localViewCleanup = utils.sequentialize(mainQueue, function (db) {
  return db.get('_local/mrviews').then(function (metaDoc) {
    var docsToViews = {};
    Object.keys(metaDoc.views).forEach(function (fullViewName) {
      var parts = parseViewName(fullViewName);
      var designDocName = '_design/' + parts[0];
      var viewName = parts[1];
      docsToViews[designDocName] = docsToViews[designDocName] || {};
      docsToViews[designDocName][viewName] = true;
    });
    var opts = {
      keys : Object.keys(docsToViews),
      include_docs : true
    };
    return db.allDocs(opts).then(function (res) {
      var viewsToStatus = {};
      res.rows.forEach(function (row) {
        var ddocName = row.key.substring(8);
        Object.keys(docsToViews[row.key]).forEach(function (viewName) {
          var fullViewName = ddocName + '/' + viewName;
          /* istanbul ignore if */
          if (!metaDoc.views[fullViewName]) {
            // new format, without slashes, to support PouchDB 2.2.0
            // migration test in pouchdb's browser.migration.js verifies this
            fullViewName = viewName;
          }
          var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
          // design doc deleted, or view function nonexistent
          var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];
          viewDBNames.forEach(function (viewDBName) {
            viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;
          });
        });
      });
      var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {
        return !viewsToStatus[viewDBName];
      });
      var destroyPromises = dbsToDelete.map(function (viewDBName) {
        return db.constructor.destroy(viewDBName, {adapter : db.adapter});
      });
      return Promise.all(destroyPromises).then(function () {
        return {ok: true};
      });
    });
  }, defaultsTo({ok: true}));
});

exports.viewCleanup = utils.callbackify(function () {
  var db = this;
  if (db.type() === 'http') {
    return httpViewCleanup(db);
  }
  return localViewCleanup(db);
});

function queryPromised(db, fun, opts) {
  if (db.type() === 'http') {
    return httpQuery(db, fun, opts);
  }

  if (typeof fun !== 'string') {
    // temp_view
    checkQueryParseError(opts, fun);

    var createViewOpts = {
      db : db,
      viewName : 'temp_view/temp_view',
      map : fun.map,
      reduce : fun.reduce,
      temporary : true
    };
    tempViewQueue.add(function () {
      return createView(createViewOpts).then(function (view) {
        function cleanup() {
          return view.db.destroy();
        }
        return utils.fin(updateView(view).then(function () {
          return queryView(view, opts);
        }), cleanup);
      });
    });
    return tempViewQueue.finish();
  } else {
    // persistent view
    var fullViewName = fun;
    var parts = parseViewName(fullViewName);
    var designDocName = parts[0];
    var viewName = parts[1];
    return db.get('_design/' + designDocName).then(function (doc) {
      var fun = doc.views && doc.views[viewName];

      if (!fun || typeof fun.map !== 'string') {
        throw new NotFoundError('ddoc ' + designDocName + ' has no view named ' +
          viewName);
      }
      checkQueryParseError(opts, fun);

      var createViewOpts = {
        db : db,
        viewName : fullViewName,
        map : fun.map,
        reduce : fun.reduce
      };
      return createView(createViewOpts).then(function (view) {
        if (opts.stale === 'ok' || opts.stale === 'update_after') {
          if (opts.stale === 'update_after') {
            process.nextTick(function () {
              updateView(view);
            });
          }
          return queryView(view, opts);
        } else { // stale not ok
          return updateView(view).then(function () {
            return queryView(view, opts);
          });
        }
      });
    });
  }
}

exports.query = function (fun, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts = utils.extend(true, {}, opts);

  if (typeof fun === 'function') {
    fun = {map : fun};
  }

  var db = this;
  var promise = Promise.resolve().then(function () {
    return queryPromised(db, fun, opts);
  });
  utils.promisedCallback(promise, callback);
  return promise;
};

function QueryParseError(message) {
  this.status = 400;
  this.name = 'query_parse_error';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, QueryParseError);
  } catch (e) {}
}

utils.inherits(QueryParseError, Error);

function NotFoundError(message) {
  this.status = 404;
  this.name = 'not_found';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, NotFoundError);
  } catch (e) {}
}

utils.inherits(NotFoundError, Error);

}).call(this,_dereq_("/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./create-view":52,"./evalfunc":53,"./taskqueue":57,"./utils":59,"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":31,"pouchdb-collate":55}],55:[function(_dereq_,module,exports){
'use strict';

var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
var MAGNITUDE_DIGITS = 3; // ditto
var SEP = ''; // set to '_' for easier debugging 

var utils = _dereq_('./utils');

exports.collate = function (a, b) {

  if (a === b) {
    return 0;
  }

  a = exports.normalizeKey(a);
  b = exports.normalizeKey(b);

  var ai = collationIndex(a);
  var bi = collationIndex(b);
  if ((ai - bi) !== 0) {
    return ai - bi;
  }
  if (a === null) {
    return 0;
  }
  switch (typeof a) {
    case 'number':
      return a - b;
    case 'boolean':
      return a === b ? 0 : (a < b ? -1 : 1);
    case 'string':
      return stringCollate(a, b);
  }
  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
};

// couch considers null/NaN/Infinity/-Infinity === undefined,
// for the purposes of mapreduce indexes. also, dates get stringified.
exports.normalizeKey = function (key) {
  switch (typeof key) {
    case 'undefined':
      return null;
    case 'number':
      if (key === Infinity || key === -Infinity || isNaN(key)) {
        return null;
      }
      return key;
    case 'object':
      var origKey = key;
      if (Array.isArray(key)) {
        var len = key.length;
        key = new Array(len);
        for (var i = 0; i < len; i++) {
          key[i] = exports.normalizeKey(origKey[i]);
        }
      } else if (key instanceof Date) {
        return key.toJSON();
      } else if (key !== null) { // generic object
        key = {};
        for (var k in origKey) {
          if (origKey.hasOwnProperty(k)) {
            var val = origKey[k];
            if (typeof val !== 'undefined') {
              key[k] = exports.normalizeKey(val);
            }
          }
        }
      }
  }
  return key;
};

function indexify(key) {
  if (key !== null) {
    switch (typeof key) {
      case 'boolean':
        return key ? 1 : 0;
      case 'number':
        return numToIndexableString(key);
      case 'string':
        // We've to be sure that key does not contain \u0000
        // Do order-preserving replacements:
        // 0 -> 1, 1
        // 1 -> 1, 2
        // 2 -> 2, 2
        return key
          .replace(/\u0002/g, '\u0002\u0002')
          .replace(/\u0001/g, '\u0001\u0002')
          .replace(/\u0000/g, '\u0001\u0001');
      case 'object':
        var isArray = Array.isArray(key);
        var arr = isArray ? key : Object.keys(key);
        var i = -1;
        var len = arr.length;
        var result = '';
        if (isArray) {
          while (++i < len) {
            result += exports.toIndexableString(arr[i]);
          }
        } else {
          while (++i < len) {
            var objKey = arr[i];
            result += exports.toIndexableString(objKey) +
                exports.toIndexableString(key[objKey]);
          }
        }
        return result;
    }
  }
  return '';
}

// convert the given key to a string that would be appropriate
// for lexical sorting, e.g. within a database, where the
// sorting is the same given by the collate() function.
exports.toIndexableString = function (key) {
  var zero = '\u0000';
  key = exports.normalizeKey(key);
  return collationIndex(key) + SEP + indexify(key) + zero;
};

function parseNumber(str, i) {
  var originalIdx = i;
  var num;
  var zero = str[i] === '1';
  if (zero) {
    num = 0;
    i++;
  } else {
    var neg = str[i] === '0';
    i++;
    var numAsString = '';
    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
    if (neg) {
      magnitude = -magnitude;
    }
    i += MAGNITUDE_DIGITS;
    while (true) {
      var ch = str[i];
      if (ch === '\u0000') {
        break;
      } else {
        numAsString += ch;
      }
      i++;
    }
    numAsString = numAsString.split('.');
    if (numAsString.length === 1) {
      num = parseInt(numAsString, 10);
    } else {
      num = parseFloat(numAsString[0] + '.' + numAsString[1]);
    }
    if (neg) {
      num = num - 10;
    }
    if (magnitude !== 0) {
      // parseFloat is more reliable than pow due to rounding errors
      // e.g. Number.MAX_VALUE would return Infinity if we did
      // num * Math.pow(10, magnitude);
      num = parseFloat(num + 'e' + magnitude);
    }
  }
  return {num: num, length : i - originalIdx};
}

// move up the stack while parsing
// this function moved outside of parseIndexableString for performance
function pop(stack, metaStack) {
  var obj = stack.pop();

  if (metaStack.length) {
    var lastMetaElement = metaStack[metaStack.length - 1];
    if (obj === lastMetaElement.element) {
      // popping a meta-element, e.g. an object whose value is another object
      metaStack.pop();
      lastMetaElement = metaStack[metaStack.length - 1];
    }
    var element = lastMetaElement.element;
    var lastElementIndex = lastMetaElement.index;
    if (Array.isArray(element)) {
      element.push(obj);
    } else if (lastElementIndex === stack.length - 2) { // obj with key+value
      var key = stack.pop();
      element[key] = obj;
    } else {
      stack.push(obj); // obj with key only
    }
  }
}

exports.parseIndexableString = function (str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;

  while (true) {
    var collationIndex = str[i++];
    if (collationIndex === '\u0000') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case '1':
        stack.push(null);
        break;
      case '2':
        stack.push(str[i] === '1');
        i++;
        break;
      case '3':
        var parsedNum = parseNumber(str, i);
        stack.push(parsedNum.num);
        i += parsedNum.length;
        break;
      case '4':
        var parsedStr = '';
        while (true) {
          var ch = str[i];
          if (ch === '\u0000') {
            break;
          }
          parsedStr += ch;
          i++;
        }
        // perform the reverse of the order-preserving replacement
        // algorithm (see above)
        parsedStr = parsedStr.replace(/\u0001\u0001/g, '\u0000')
          .replace(/\u0001\u0002/g, '\u0001')
          .replace(/\u0002\u0002/g, '\u0002');
        stack.push(parsedStr);
        break;
      case '5':
        var arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '6':
        var objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      default:
        throw new Error(
          'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);
    }
  }
};

function arrayCollate(a, b) {
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; i++) {
    var sort = exports.collate(a[i], b[i]);
    if (sort !== 0) {
      return sort;
    }
  }
  return (a.length === b.length) ? 0 :
    (a.length > b.length) ? 1 : -1;
}
function stringCollate(a, b) {
  // See: https://github.com/daleharvey/pouchdb/issues/40
  // This is incompatible with the CouchDB implementation, but its the
  // best we can do for now
  return (a === b) ? 0 : ((a > b) ? 1 : -1);
}
function objectCollate(a, b) {
  var ak = Object.keys(a), bk = Object.keys(b);
  var len = Math.min(ak.length, bk.length);
  for (var i = 0; i < len; i++) {
    // First sort the keys
    var sort = exports.collate(ak[i], bk[i]);
    if (sort !== 0) {
      return sort;
    }
    // if the keys are equal sort the values
    sort = exports.collate(a[ak[i]], b[bk[i]]);
    if (sort !== 0) {
      return sort;
    }

  }
  return (ak.length === bk.length) ? 0 :
    (ak.length > bk.length) ? 1 : -1;
}
// The collation is defined by erlangs ordered terms
// the atoms null, true, false come first, then numbers, strings,
// arrays, then objects
// null/undefined/NaN/Infinity/-Infinity are all considered null
function collationIndex(x) {
  var id = ['boolean', 'number', 'string', 'object'];
  var idx = id.indexOf(typeof x);
  //false if -1 otherwise true, but fast!!!!1
  if (~idx) {
    if (x === null) {
      return 1;
    }
    if (Array.isArray(x)) {
      return 5;
    }
    return idx < 3 ? (idx + 2) : (idx + 3);
  }
  if (Array.isArray(x)) {
    return 5;
  }
}

// conversion:
// x yyy zz...zz
// x = 0 for negative, 1 for 0, 2 for positive
// y = exponent (for negative numbers negated) moved so that it's >= 0
// z = mantisse
function numToIndexableString(num) {

  if (num === 0) {
    return '1';
  }

  // convert number to exponential format for easier and
  // more succinct string sorting
  var expFormat = num.toExponential().split(/e\+?/);
  var magnitude = parseInt(expFormat[1], 10);

  var neg = num < 0;

  var result = neg ? '0' : '2';

  // first sort by magnitude
  // it's easier if all magnitudes are positive
  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
  var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

  result += SEP + magString;

  // then sort by the factor
  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
  if (neg) { // for negative reverse ordering
    factor = 10 - factor;
  }

  var factorStr = factor.toFixed(20);

  // strip zeros from the end
  factorStr = factorStr.replace(/\.?0+$/, '');

  result += SEP + factorStr;

  return result;
}

},{"./utils":56}],56:[function(_dereq_,module,exports){
'use strict';

function pad(str, padWith, upToLength) {
  var padding = '';
  var targetLength = upToLength - str.length;
  while (padding.length < targetLength) {
    padding += padWith;
  }
  return padding;
}

exports.padLeft = function (str, padWith, upToLength) {
  var padding = pad(str, padWith, upToLength);
  return padding + str;
};

exports.padRight = function (str, padWith, upToLength) {
  var padding = pad(str, padWith, upToLength);
  return str + padding;
};

exports.stringLexCompare = function (a, b) {

  var aLen = a.length;
  var bLen = b.length;

  var i;
  for (i = 0; i < aLen; i++) {
    if (i === bLen) {
      // b is shorter substring of a
      return 1;
    }
    var aChar = a.charAt(i);
    var bChar = b.charAt(i);
    if (aChar !== bChar) {
      return aChar < bChar ? -1 : 1;
    }
  }

  if (aLen < bLen) {
    // a is shorter substring of b
    return -1;
  }

  return 0;
};

/*
 * returns the decimal form for the given integer, i.e. writes
 * out all the digits (in base-10) instead of using scientific notation
 */
exports.intToDecimalForm = function (int) {

  var isNeg = int < 0;
  var result = '';

  do {
    var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);

    result = remainder + result;
    int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);
  } while (int);


  if (isNeg && result !== '0') {
    result = '-' + result;
  }

  return result;
};
},{}],57:[function(_dereq_,module,exports){
'use strict';
/*
 * Simple task queue to sequentialize actions. Assumes callbacks will eventually fire (once).
 */

var Promise = _dereq_('./utils').Promise;

function TaskQueue() {
  this.promise = new Promise(function (fulfill) {fulfill(); });
}
TaskQueue.prototype.add = function (promiseFactory) {
  this.promise = this.promise["catch"](function () {
    // just recover
  }).then(function () {
    return promiseFactory();
  });
  return this.promise;
};
TaskQueue.prototype.finish = function () {
  return this.promise;
};

module.exports = TaskQueue;

},{"./utils":59}],58:[function(_dereq_,module,exports){
'use strict';
var Promise = _dereq_('./utils').Promise;

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
function upsert(db, docId, diffFun) {
  return new Promise(function (fulfill, reject) {
    if (docId && typeof docId === 'object') {
      docId = docId._id;
    }
    if (typeof docId !== 'string') {
      return reject(new Error('doc id is required'));
    }

    db.get(docId, function (err, doc) {
      if (err) {
        if (err.status !== 404) {
          return reject(err);
        }
        return fulfill(tryAndPut(db, diffFun({_id : docId}), diffFun));
      }
      var newDoc = diffFun(doc);
      if (!newDoc) {
        return fulfill(doc);
      }
      fulfill(tryAndPut(db, newDoc, diffFun));
    });
  });
}

function tryAndPut(db, doc, diffFun) {
  return db.put(doc)["catch"](function (err) {
    if (err.status !== 409) {
      throw err;
    }
    return upsert(db, doc, diffFun);
  });
}

module.exports = upsert;

},{"./utils":59}],59:[function(_dereq_,module,exports){
(function (process,global){
'use strict';
/* istanbul ignore if */
if (typeof global.Promise === 'function') {
  exports.Promise = global.Promise;
} else {
  exports.Promise = _dereq_('lie');
}
// uniquify a list, similar to underscore's _.uniq
exports.uniq = function (arr) {
  var map = {};
  arr.forEach(function (element) {
    map[element] = true;
  });
  return Object.keys(map);
};

exports.inherits = _dereq_('inherits');
exports.extend = _dereq_('pouchdb-extend');
var argsarray = _dereq_('argsarray');

exports.promisedCallback = function (promise, callback) {
  if (callback) {
    promise.then(function (res) {
      process.nextTick(function () {
        callback(null, res);
      });
    }, function (reason) {
      process.nextTick(function () {
        callback(reason);
      });
    });
  }
  return promise;
};

exports.callbackify = function (fun) {
  return argsarray(function (args) {
    var cb = args.pop();
    var promise = fun.apply(this, args);
    if (typeof cb === 'function') {
      exports.promisedCallback(promise, cb);
    }
    return promise;
  });
};

// Promise finally util similar to Q.finally
exports.fin = function (promise, cb) {
  return promise.then(function (res) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        return res;
      });
    }
    return res;
  }, function (reason) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        throw reason;
      });
    }
    throw reason;
  });
};

exports.sequentialize = function (queue, promiseFactory) {
  return function () {
    var args = arguments;
    var that = this;
    return queue.add(function () {
      return promiseFactory.apply(that, args);
    });
  };
};

var crypto = _dereq_('crypto');
var Md5 = _dereq_('spark-md5');

exports.MD5 = function (string) {
  /* istanbul ignore else */
  if (!process.browser) {
    return crypto.createHash('md5').update(string).digest('hex');
  } else {
    return Md5.hash(string);
  }
};
}).call(this,_dereq_("/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":31,"argsarray":28,"crypto":29,"inherits":32,"lie":36,"pouchdb-extend":51,"spark-md5":60}],60:[function(_dereq_,module,exports){
/*jshint bitwise:false*/
/*global unescape*/

(function (factory) {
    if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals (with support for web workers)
        var glob;
        try {
            glob = window;
        } catch (e) {
            glob = self;
        }

        glob.SparkMD5 = factory();
    }
}(function (undefined) {

    'use strict';

    ////////////////////////////////////////////////////////////////////////////

    /*
     * Fastest md5 implementation around (JKM md5)
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },

    cmn = function (q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    },

    ff = function (a, b, c, d, x, s, t) {
        return cmn((b & c) | ((~b) & d), a, b, x, s, t);
    },

    gg = function (a, b, c, d, x, s, t) {
        return cmn((b & d) | (c & (~d)), a, b, x, s, t);
    },

    hh = function (a, b, c, d, x, s, t) {
        return cmn(b ^ c ^ d, a, b, x, s, t);
    },

    ii = function (a, b, c, d, x, s, t) {
        return cmn(c ^ (b | (~d)), a, b, x, s, t);
    },

    md5cycle = function (x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a = ff(a, b, c, d, k[0], 7, -680876936);
        d = ff(d, a, b, c, k[1], 12, -389564586);
        c = ff(c, d, a, b, k[2], 17, 606105819);
        b = ff(b, c, d, a, k[3], 22, -1044525330);
        a = ff(a, b, c, d, k[4], 7, -176418897);
        d = ff(d, a, b, c, k[5], 12, 1200080426);
        c = ff(c, d, a, b, k[6], 17, -1473231341);
        b = ff(b, c, d, a, k[7], 22, -45705983);
        a = ff(a, b, c, d, k[8], 7, 1770035416);
        d = ff(d, a, b, c, k[9], 12, -1958414417);
        c = ff(c, d, a, b, k[10], 17, -42063);
        b = ff(b, c, d, a, k[11], 22, -1990404162);
        a = ff(a, b, c, d, k[12], 7, 1804603682);
        d = ff(d, a, b, c, k[13], 12, -40341101);
        c = ff(c, d, a, b, k[14], 17, -1502002290);
        b = ff(b, c, d, a, k[15], 22, 1236535329);

        a = gg(a, b, c, d, k[1], 5, -165796510);
        d = gg(d, a, b, c, k[6], 9, -1069501632);
        c = gg(c, d, a, b, k[11], 14, 643717713);
        b = gg(b, c, d, a, k[0], 20, -373897302);
        a = gg(a, b, c, d, k[5], 5, -701558691);
        d = gg(d, a, b, c, k[10], 9, 38016083);
        c = gg(c, d, a, b, k[15], 14, -660478335);
        b = gg(b, c, d, a, k[4], 20, -405537848);
        a = gg(a, b, c, d, k[9], 5, 568446438);
        d = gg(d, a, b, c, k[14], 9, -1019803690);
        c = gg(c, d, a, b, k[3], 14, -187363961);
        b = gg(b, c, d, a, k[8], 20, 1163531501);
        a = gg(a, b, c, d, k[13], 5, -1444681467);
        d = gg(d, a, b, c, k[2], 9, -51403784);
        c = gg(c, d, a, b, k[7], 14, 1735328473);
        b = gg(b, c, d, a, k[12], 20, -1926607734);

        a = hh(a, b, c, d, k[5], 4, -378558);
        d = hh(d, a, b, c, k[8], 11, -2022574463);
        c = hh(c, d, a, b, k[11], 16, 1839030562);
        b = hh(b, c, d, a, k[14], 23, -35309556);
        a = hh(a, b, c, d, k[1], 4, -1530992060);
        d = hh(d, a, b, c, k[4], 11, 1272893353);
        c = hh(c, d, a, b, k[7], 16, -155497632);
        b = hh(b, c, d, a, k[10], 23, -1094730640);
        a = hh(a, b, c, d, k[13], 4, 681279174);
        d = hh(d, a, b, c, k[0], 11, -358537222);
        c = hh(c, d, a, b, k[3], 16, -722521979);
        b = hh(b, c, d, a, k[6], 23, 76029189);
        a = hh(a, b, c, d, k[9], 4, -640364487);
        d = hh(d, a, b, c, k[12], 11, -421815835);
        c = hh(c, d, a, b, k[15], 16, 530742520);
        b = hh(b, c, d, a, k[2], 23, -995338651);

        a = ii(a, b, c, d, k[0], 6, -198630844);
        d = ii(d, a, b, c, k[7], 10, 1126891415);
        c = ii(c, d, a, b, k[14], 15, -1416354905);
        b = ii(b, c, d, a, k[5], 21, -57434055);
        a = ii(a, b, c, d, k[12], 6, 1700485571);
        d = ii(d, a, b, c, k[3], 10, -1894986606);
        c = ii(c, d, a, b, k[10], 15, -1051523);
        b = ii(b, c, d, a, k[1], 21, -2054922799);
        a = ii(a, b, c, d, k[8], 6, 1873313359);
        d = ii(d, a, b, c, k[15], 10, -30611744);
        c = ii(c, d, a, b, k[6], 15, -1560198380);
        b = ii(b, c, d, a, k[13], 21, 1309151649);
        a = ii(a, b, c, d, k[4], 6, -145523070);
        d = ii(d, a, b, c, k[11], 10, -1120210379);
        c = ii(c, d, a, b, k[2], 15, 718787259);
        b = ii(b, c, d, a, k[9], 21, -343485551);

        x[0] = add32(a, x[0]);
        x[1] = add32(b, x[1]);
        x[2] = add32(c, x[2]);
        x[3] = add32(d, x[3]);
    },

    /* there needs to be support for Unicode here,
       * unless we pretend that we can redefine the MD-5
       * algorithm for multi-byte characters (perhaps
       * by adding every four 16-bit characters and
       * shortening the sum to 32 bits). Otherwise
       * I suggest performing MD-5 as if every character
       * was two bytes--e.g., 0040 0025 = @%--but then
       * how will an ordinary MD-5 sum be matched?
       * There is no way to standardize text to something
       * like UTF-8 before transformation; speed cost is
       * utterly prohibitive. The JavaScript standard
       * itself needs to look at this: it should start
       * providing access to strings as preformed UTF-8
       * 8-bit unsigned value arrays.
       */
    md5blk = function (s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    },

    md5blk_array = function (a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    },

    md51 = function (s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    },

    md51_array = function (a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    },

    hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],

    rhex = function (n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    },

    hex = function (x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    },

    md5 = function (s) {
        return hex(md51(s));
    },



    ////////////////////////////////////////////////////////////////////////////

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */
    SparkMD5 = function () {
        // call reset to init the instance
        this.reset();
    };


    // In some cases the fast add32 function cannot be used..
    if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }


    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // converts the string to utf8 bytes if necessary
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        // then append as binary
        this.appendBinary(str);

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._state, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substr(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     * Use the raw parameter to obtain the raw result instead of the hex one.
     *
     * @param {Boolean} raw True to get the raw result, false to get the hex result
     *
     * @return {String|Array} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = !!raw ? this._state : hex(this._state);

        this.reset();

        return ret;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._state, tail);
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = "";
        this._length = 0;
        this._state = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other aditional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._state;
        delete this._buff;
        delete this._length;
    };


    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw result, false to get the hex result
     *
     * @return {String|Array} The result
     */
    SparkMD5.hash = function (str, raw) {
        // converts the string to utf8 bytes if necessary
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        var hash = md51(str);

        return !!raw ? hash : hex(hash);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw result, false to get the hex result
     *
     * @return {String|Array} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content);

        return !!raw ? hash : hex(hash);
    };

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    ////////////////////////////////////////////////////////////////////////////

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        // TODO: we could avoid the concatenation here but the algorithm would be more complex
        //       if you find yourself needing extra performance, please make a PR.
        var buff = this._concatArrayBuffer(this._buff, arr),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._state, md5blk_array(buff.subarray(i - 64, i)));
        }

        // Avoids IE10 weirdness (documented above)
        this._buff = (i - 64) < length ? buff.subarray(i - 64) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     * Use the raw parameter to obtain the raw result instead of the hex one.
     *
     * @param {Boolean} raw True to get the raw result, false to get the hex result
     *
     * @return {String|Array} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = !!raw ? this._state : hex(this._state);

        this.reset();

        return ret;
    };

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._state = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other aditional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    /**
     * Concats two array buffers, returning a new one.
     *
     * @param  {ArrayBuffer} first  The first array buffer
     * @param  {ArrayBuffer} second The second array buffer
     *
     * @return {ArrayBuffer} The new array buffer
     */
    SparkMD5.ArrayBuffer.prototype._concatArrayBuffer = function (first, second) {
        var firstLength = first.length,
            result = new Uint8Array(firstLength + second.byteLength);

        result.set(first);
        result.set(new Uint8Array(second), firstLength);

        return result;
    };

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw result, false to get the hex result
     *
     * @return {String|Array} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr));

        return !!raw ? hash : hex(hash);
    };

    return SparkMD5;
}));

},{}],61:[function(_dereq_,module,exports){
'use strict';

/**
 * Stringify/parse functions that don't operate
 * recursively, so they avoid call stack exceeded
 * errors.
 */
exports.stringify = function stringify(input) {
  var queue = [];
  queue.push({obj: input});

  var res = '';
  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
  while ((next = queue.pop())) {
    obj = next.obj;
    prefix = next.prefix || '';
    val = next.val || '';
    res += prefix;
    if (val) {
      res += val;
    } else if (typeof obj !== 'object') {
      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
    } else if (obj === null) {
      res += 'null';
    } else if (Array.isArray(obj)) {
      queue.push({val: ']'});
      for (i = obj.length - 1; i >= 0; i--) {
        arrayPrefix = i === 0 ? '' : ',';
        queue.push({obj: obj[i], prefix: arrayPrefix});
      }
      queue.push({val: '['});
    } else { // object
      keys = [];
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          keys.push(k);
        }
      }
      queue.push({val: '}'});
      for (i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        value = obj[key];
        objPrefix = (i > 0 ? ',' : '');
        objPrefix += JSON.stringify(key) + ':';
        queue.push({obj: value, prefix: objPrefix});
      }
      queue.push({val: '{'});
    }
  }
  return res;
};

// Convenience function for the parse function.
// This pop function is basically copied from
// pouchCollate.parseIndexableString
function pop(obj, stack, metaStack) {
  var lastMetaElement = metaStack[metaStack.length - 1];
  if (obj === lastMetaElement.element) {
    // popping a meta-element, e.g. an object whose value is another object
    metaStack.pop();
    lastMetaElement = metaStack[metaStack.length - 1];
  }
  var element = lastMetaElement.element;
  var lastElementIndex = lastMetaElement.index;
  if (Array.isArray(element)) {
    element.push(obj);
  } else if (lastElementIndex === stack.length - 2) { // obj with key+value
    var key = stack.pop();
    element[key] = obj;
  } else {
    stack.push(obj); // obj with key only
  }
}

exports.parse = function (str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;
  var collationIndex,parsedNum,numChar;
  var parsedString,lastCh,numConsecutiveSlashes,ch;
  var arrayElement, objElement;
  while (true) {
    collationIndex = str[i++];
    if (collationIndex === '}' ||
        collationIndex === ']' ||
        typeof collationIndex === 'undefined') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack.pop(), stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case ' ':
      case '\t':
      case '\n':
      case ':':
      case ',':
        break;
      case 'n':
        i += 3; // 'ull'
        pop(null, stack, metaStack);
        break;
      case 't':
        i += 3; // 'rue'
        pop(true, stack, metaStack);
        break;
      case 'f':
        i += 4; // 'alse'
        pop(false, stack, metaStack);
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        parsedNum = '';
        i--;
        while (true) {
          numChar = str[i++];
          if (/[\d\.\-e\+]/.test(numChar)) {
            parsedNum += numChar;
          } else {
            i--;
            break;
          }
        }
        pop(parseFloat(parsedNum), stack, metaStack);
        break;
      case '"':
        parsedString = '';
        lastCh = void 0;
        numConsecutiveSlashes = 0;
        while (true) {
          ch = str[i++];
          if (ch !== '"' || (lastCh === '\\' &&
              numConsecutiveSlashes % 2 === 1)) {
            parsedString += ch;
            lastCh = ch;
            if (lastCh === '\\') {
              numConsecutiveSlashes++;
            } else {
              numConsecutiveSlashes = 0;
            }
          } else {
            break;
          }
        }
        pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
        break;
      case '[':
        arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '{':
        objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      default:
        throw new Error(
          'unexpectedly reached end of input: ' + collationIndex);
    }
  }
};

},{}]},{},[20])
(20)
});
}, {}],
13: [function(require, module, exports) {

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

}, {}],
14: [function(require, module, exports) {
/**
 * Export `uid`
 */

module.exports = uid;

/**
 * Create a `uid`
 *
 * @param {String} len
 * @return {String} uid
 */

function uid(len) {
  len = len || 7;
  return Math.random().toString(35).substr(2, len);
}

}, {}],
15: [function(require, module, exports) {
'use strict';
var Emitter = require('component/emitter');
var uid = require('matthewmueller/uid');
var Todo;

/**
 * Initialize `Todo` with `attrs`
 * @param {Object} attrs
 */
Todo = function Todo(attrs) {
    if (!(this instanceof Todo)) return new Todo(attrs);
    attrs = attrs || {};
    this._id = attrs._id || uid();
    this.complete = attrs.complete || false;
    this.title = attrs.title || '';
    this.timestamp = new Date().getTime();
};

/**
 * Mixins
 */
Emitter(Todo.prototype);

/**
 * Retrieve the attributes of a todo
 * @return {Object} attributes
 */
Todo.prototype.attrs = function attrs() {
    var props = {};
    if (this._id) props._id = this._id;
    if (this._rev !== -1) props._rev = this._rev;
    props.complete = this.complete;
    props.title = this.title;
    return props;
};

Todo.prototype.set = function set(attrs) {
    for (var key in attrs) {
        this[key] = attrs[key];
        this.emit('change');
        this.emit('change ' + key, this[key]);
    };
};

Todo.prototype.get = function get(attr) {
    return this[attr];
};

module.exports = Todo;
}, {"component/emitter":13,"matthewmueller/uid":14}],
3: [function(require, module, exports) {
var assert = require('component/assert');
var Todo = require('/lib/list/lib/todo');

describe('Todo', function () {
    it('returns a new todo', function () {
        var todo = Todo();
        assert(todo !== Todo());
    });
});

describe('Todo#attrs', function () {
    it('returns the attributes of the todo', function () {
        var todo = Todo({title: 'Foo'});
        assert(todo.attrs().title === 'Foo');
    });
});

describe('Todo#set', function () {
    it('sets a property on the todo', function () {
        var todo = Todo();
        assert(todo.complete === false);
        todo.set({complete: true});
        assert(todo.complete === true);
    });
});

describe('Todo#get', function () {
    it('gets a property on the todo', function () {
        var todo = Todo();
        assert(todo.get('complete') === false);
        todo.set({complete: true});
        assert(todo.get('complete') === true);
    });
});
}, {"component/assert":6,"/lib/list/lib/todo":15}],
4: [function(require, module, exports) {
'use strict';
var assert = require('component/assert');
var month = require('anthonyshort/date-month');
var suffixed = require('anthonyshort/date-suffix');
var classes = require('component/classes');
var ListView = require('../lib/list-view');
var List = require('../lib/list');

describe('ListView', function () {
    it('returns a new view', function () {
        var list = List();
        var view = ListView(list);
        assert(view !== ListView(list));
    });
    it('creates title element on initialization', function () {
        var list = List();
        var view = ListView(list);
        var elMonth = month(list.timestamp).full();
        var elSuffixed = suffixed(list.timestamp);
        var titleText = view.el.querySelector('.List-title').innerHTML;
        assert(titleText === elMonth + ' ' + elSuffixed);
    });
    it('creates todo elements on initialization', function () {
        var list = List();
        list.createTodo({title: 'Foo'});
        list.createTodo({title: 'Bar'});
        list.createTodo({title: 'Baz'});
        var view = ListView(list);
        assert(view.todoViews.length === 3);
        assert(view.listEl.children.length === 3);
    });
    it('creates todo elements when model emits `create todo`', function () {
        var list = List();
        var view = ListView(list);
        list.createTodo({title: 'Foo'});
        assert(view.todoViews.length === 1);
        assert(view.listEl.children.length === 1);
        assert(view.listEl.querySelector('.Todo-title').innerHTML === 'Foo');
    });
});

describe('ListView#filter', function() {
    it('adds u-hidden class to filtered todo elements', function () {
        var list = List();
        var view = ListView(list);
        list.createTodo({title: 'Foo', complete: false});
        list.createTodo({title: 'Bar', complete: true});
        view.filter('complete', true);
        assert(view.listEl.children[0].classList.contains('u-hidden'));
        assert(!(view.listEl.children[1].classList.contains('u-hidden')));
    });
});
}, {"component/assert":6,"anthonyshort/date-month":16,"anthonyshort/date-suffix":17,"component/classes":18,"../lib/list-view":19,"../lib/list":7}],
16: [function(require, module, exports) {
var months = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December'
];

var short = [
  'Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec'
];

var double = [
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '10',
  '11',
  '12'
];

var single = [
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  '10',
  '11',
  '12'
];

module.exports = function(date) {
  var month = date.getMonth();
  return {
    full: function(){
      return months[month];
    },
    short: function(){
      return short[month];
    },
    double: function(){
      return double[month];
    },
    single: function(){
      return single[month];
    }
  };
};
}, {}],
17: [function(require, module, exports) {
module.exports = function(date) {
  var num = date.getDate();
  if ( num % 100 >= 10 && num % 100 <= 19 ) {
    return num + 'th';
  }
  switch ( num % 10 ) {
    case 1: return num + 'st';
    case 2: return num + 'nd';
    case 3: return num + 'rd';
  }
  return num + 'th';
};
}, {}],
18: [function(require, module, exports) {
/**
 * Module dependencies.
 */

var index = require('indexof');

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var str = this.el.className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};

}, {"indexof":20}],
20: [function(require, module, exports) {
module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
}, {}],
19: [function(require, module, exports) {
'use strict';
var Emitter = require('component/emitter');
var month = require('anthonyshort/date-month');
var suffixed = require('anthonyshort/date-suffix');
var move = require('visionmedia/move.js');
var domify = require('component/domify');
var template = require('./template.html');
var TodoView = require('./lib/todo-view');
var ListView;

/**
 * Initialize `ListView` with `model`
 * @param {List} model
 */
ListView = function ListView(model) {
    if (!(this instanceof ListView)) return new ListView(model);
    model = model || {};
    var self = this;
    this.model = model;
    this.el = domify(template);
    this.listEl = this.el.querySelector('.List-todos');
    this.todoViews = [];
    this.createTitle();

    this.model.todos.forEach(function (todo) {
        self.createTodo(todo);
    });

    this.model.on('create todo', function (todo) {
        self.createTodo(todo);
    });
};

/**
 * Mixins
 */
Emitter(ListView.prototype);

/**
 * Create title element
 * @api private
 */
ListView.prototype.createTitle = function createTitle() {
    var titleEl = this.el.querySelector('.List-title');
    var titleMonth = month(this.model.timestamp).full();
    var titleSuffixed =  suffixed(this.model.timestamp);
    titleEl.innerHTML = titleMonth + ' ' + titleSuffixed;
};

/**
 * Create a new todo element with `todo` model
 * and animate it
 * @param  {Todo} todo
 * @api private
 */
ListView.prototype.createTodo = function createTodo(todo) {
    var view = TodoView(todo);
    this.todoViews.push(view);
    this.listEl.appendChild(view.el);
    view.el.style.display = 'none';
    view.el.style.display = 'block';
    move(view.el).y(1000).end();
    move(view.el).y(0).end();
};

/**
 * Hide/show the todo elements by `todo` model properties
 * @param  {String} key model property name
 * @param  {Mixed} val model property value
 * @api public
 */
ListView.prototype.filter = function filter(key, val) {
    this.todoViews.forEach(function (view) {
        if (view.model[key] === val) return view.show();
        view.hide();
    });
};

module.exports = ListView;
}, {"component/emitter":13,"anthonyshort/date-month":16,"anthonyshort/date-suffix":17,"visionmedia/move.js":21,"component/domify":22,"./template.html":23,"./lib/todo-view":24}],
21: [function(require, module, exports) {
/**
 * Module Dependencies.
 */

var after = require('after-transition');
var has3d = require('has-translate3d');
var Emitter = require('emitter');
var ease = require('css-ease');
var query = require('query');

/**
 * CSS Translate
 */

var translate = has3d
  ? ['translate3d(', ', 0)']
  : ['translate(', ')'];

/**
 * Export `Move`
 */

module.exports = Move;

/**
 * Get computed style.
 */

var style = window.getComputedStyle
  || window.currentStyle;

/**
 * Library version.
 */

Move.version = '0.3.2';

/**
 * Export `ease`
 */

Move.ease = ease;

/**
 * Defaults.
 *
 *   `duration` - default duration of 500ms
 *
 */

Move.defaults = {
  duration: 500
};

/**
 * Default element selection utilized by `move(selector)`.
 *
 * Override to implement your own selection, for example
 * with jQuery one might write:
 *
 *     move.select = function(selector) {
 *       return jQuery(selector).get(0);
 *     };
 *
 * @param {Object|String} selector
 * @return {Element}
 * @api public
 */

Move.select = function(selector){
  if ('string' != typeof selector) return selector;
  return query(selector);
};

/**
 * Initialize a new `Move` with the given `el`.
 *
 * @param {Element} el
 * @api public
 */

function Move(el) {
  if (!(this instanceof Move)) return new Move(el);
  if ('string' == typeof el) el = query(el);
  if (!el) throw new TypeError('Move must be initialized with element or selector');
  this.el = el;
  this._props = {};
  this._rotate = 0;
  this._transitionProps = [];
  this._transforms = [];
  this.duration(Move.defaults.duration)
};


/**
 * Inherit from `EventEmitter.prototype`.
 */

Emitter(Move.prototype);

/**
 * Buffer `transform`.
 *
 * @param {String} transform
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transform = function(transform){
  this._transforms.push(transform);
  return this;
};

/**
 * Skew `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skew = function(x, y){
  return this.transform('skew('
    + x + 'deg, '
    + (y || 0)
    + 'deg)');
};

/**
 * Skew x by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewX = function(n){
  return this.transform('skewX(' + n + 'deg)');
};

/**
 * Skew y by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewY = function(n){
  return this.transform('skewY(' + n + 'deg)');
};

/**
 * Translate `x` and `y` axis.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translate =
Move.prototype.to = function(x, y){
  return this.transform(translate.join(''
    + x +'px, '
    + (y || 0)
    + 'px'));
};

/**
 * Translate on the x axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateX =
Move.prototype.x = function(n){
  return this.transform('translateX(' + n + 'px)');
};

/**
 * Translate on the y axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateY =
Move.prototype.y = function(n){
  return this.transform('translateY(' + n + 'px)');
};

/**
 * Scale the x and y axis by `x`, or
 * individually scale `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scale = function(x, y){
  return this.transform('scale('
    + x + ', '
    + (y || x)
    + ')');
};

/**
 * Scale x axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleX = function(n){
  return this.transform('scaleX(' + n + ')')
};

/**
 * Apply a matrix transformation
 *
 * @param {Number} m11 A matrix coefficient
 * @param {Number} m12 A matrix coefficient
 * @param {Number} m21 A matrix coefficient
 * @param {Number} m22 A matrix coefficient
 * @param {Number} m31 A matrix coefficient
 * @param {Number} m32 A matrix coefficient
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.matrix = function(m11, m12, m21, m22, m31, m32){
  return this.transform('matrix(' + [m11,m12,m21,m22,m31,m32].join(',') + ')');
};

/**
 * Scale y axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleY = function(n){
  return this.transform('scaleY(' + n + ')')
};

/**
 * Rotate `n` degrees.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.rotate = function(n){
  return this.transform('rotate(' + n + 'deg)');
};

/**
 * Set transition easing function to to `fn` string.
 *
 * When:
 *
 *   - null "ease" is used
 *   - "in" "ease-in" is used
 *   - "out" "ease-out" is used
 *   - "in-out" "ease-in-out" is used
 *
 * @param {String} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.ease = function(fn){
  fn = ease[fn] || fn || 'ease';
  return this.setVendorProperty('transition-timing-function', fn);
};

/**
 * Set animation properties
 *
 * @param {String} name
 * @param {Object} props
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.animate = function(name, props){
  for (var i in props){
    if (props.hasOwnProperty(i)){
      this.setVendorProperty('animation-' + i, props[i])
    }
  }
  return this.setVendorProperty('animation-name', name);
}

/**
 * Set duration to `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.duration = function(n){
  n = this._duration = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-duration', n + 'ms');
};

/**
 * Delay the animation by `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.delay = function(n){
  n = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-delay', n + 'ms');
};

/**
 * Set `prop` to `val`, deferred until `.end()` is invoked.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setProperty = function(prop, val){
  this._props[prop] = val;
  return this;
};

/**
 * Set a vendor prefixed `prop` with the given `val`.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setVendorProperty = function(prop, val){
  this.setProperty('-webkit-' + prop, val);
  this.setProperty('-moz-' + prop, val);
  this.setProperty('-ms-' + prop, val);
  this.setProperty('-o-' + prop, val);
  return this;
};

/**
 * Set `prop` to `value`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.set = function(prop, val){
  this.transition(prop);
  this._props[prop] = val;
  return this;
};

/**
 * Increment `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.add = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr + val + 'px');
  });
};

/**
 * Decrement `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.sub = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr - val + 'px');
  });
};

/**
 * Get computed or "current" value of `prop`.
 *
 * @param {String} prop
 * @return {String}
 * @api public
 */

Move.prototype.current = function(prop){
  return style(this.el).getPropertyValue(prop);
};

/**
 * Add `prop` to the list of internal transition properties.
 *
 * @param {String} prop
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transition = function(prop){
  if (!this._transitionProps.indexOf(prop)) return this;
  this._transitionProps.push(prop);
  return this;
};

/**
 * Commit style properties, aka apply them to `el.style`.
 *
 * @return {Move} for chaining
 * @see Move#end()
 * @api private
 */

Move.prototype.applyProperties = function(){
  for (var prop in this._props) {
    this.el.style.setProperty(prop, this._props[prop], '');
  }
  return this;
};

/**
 * Re-select element via `selector`, replacing
 * the current element.
 *
 * @param {String} selector
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.move =
Move.prototype.select = function(selector){
  this.el = Move.select(selector);
  return this;
};

/**
 * Defer the given `fn` until the animation
 * is complete. `fn` may be one of the following:
 *
 *   - a function to invoke
 *   - an instanceof `Move` to call `.end()`
 *   - nothing, to return a clone of this `Move` instance for chaining
 *
 * @param {Function|Move} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.then = function(fn){
  // invoke .end()
  if (fn instanceof Move) {
    this.on('end', function(){
      fn.end();
    });
  // callback
  } else if ('function' == typeof fn) {
    this.on('end', fn);
  // chain
  } else {
    var clone = new Move(this.el);
    clone._transforms = this._transforms.slice(0);
    this.then(clone);
    clone.parent = this;
    return clone;
  }

  return this;
};

/**
 * Pop the move context.
 *
 * @return {Move} parent Move
 * @api public
 */

Move.prototype.pop = function(){
  return this.parent;
};

/**
 * Reset duration.
 *
 * @return {Move}
 * @api public
 */

Move.prototype.reset = function(){
  this.el.style.webkitTransitionDuration =
  this.el.style.mozTransitionDuration =
  this.el.style.msTransitionDuration =
  this.el.style.oTransitionDuration = '';
  return this;
};

/**
 * Start animation, optionally calling `fn` when complete.
 *
 * @param {Function} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.end = function(fn){
  var self = this;

  // emit "start" event
  this.emit('start');

  // transforms
  if (this._transforms.length) {
    this.setVendorProperty('transform', this._transforms.join(' '));
  }

  // transition properties
  this.setVendorProperty('transition-properties', this._transitionProps.join(', '));
  this.applyProperties();

  // callback given
  if (fn) this.then(fn);

  // emit "end" when complete
  after.once(this.el, function(){
    self.reset();
    self.emit('end');
  });

  return this;
};

}, {"after-transition":25,"has-translate3d":26,"emitter":13,"css-ease":27,"query":28}],
25: [function(require, module, exports) {

/**
 * dependencies
 */

var has = require('has-transitions')
  , emitter = require('css-emitter')
  , once = require('once');

/**
 * Transition support.
 */

var supported = has();

/**
 * Export `after`
 */

module.exports = after;

/**
 * Invoke the given `fn` after transitions
 *
 * It will be invoked only if the browser
 * supports transitions __and__
 * the element has transitions
 * set in `.style` or css.
 *
 * @param {Element} el
 * @param {Function} fn
 * @return {Function} fn
 * @api public
 */

function after(el, fn){
  if (!supported || !has(el)) return fn();
  emitter(el).bind(fn);
  return fn;
};

/**
 * Same as `after()` only the function is invoked once.
 *
 * @param {Element} el
 * @param {Function} fn
 * @return {Function}
 * @api public
 */

after.once = function(el, fn){
  var callback = once(fn);
  after(el, fn = function(){
    emitter(el).unbind(fn);
    callback();
  });
};

}, {"has-transitions":29,"css-emitter":30,"once":31}],
29: [function(require, module, exports) {

/**
 * Check if `el` or browser supports transitions.
 *
 * @param {Element} el
 * @return {Boolean}
 * @api public
 */

exports = module.exports = function(el){
  switch (arguments.length) {
    case 0: return bool;
    case 1: return bool
      ? transitions(el)
      : bool;
  }
};

/**
 * Check if the given `el` has transitions.
 *
 * @param {Element} el
 * @return {Boolean}
 * @api private
 */

function transitions(el, styl){
  if (el.transition) return true;
  styl = window.getComputedStyle(el);
  return !! styl.transition;
}

/**
 * Style.
 */

var styl = document.body.style;

/**
 * Export support.
 */

var bool = 'transition' in styl
  || 'webkitTransition' in styl
  || 'MozTransition' in styl
  || 'msTransition' in styl;

}, {}],
30: [function(require, module, exports) {
/**
 * Module Dependencies
 */

var events = require('event');

// CSS events

var watch = [
  'transitionend'
, 'webkitTransitionEnd'
, 'oTransitionEnd'
, 'MSTransitionEnd'
, 'animationend'
, 'webkitAnimationEnd'
, 'oAnimationEnd'
, 'MSAnimationEnd'
];

/**
 * Expose `CSSnext`
 */

module.exports = CssEmitter;

/**
 * Initialize a new `CssEmitter`
 *
 */

function CssEmitter(element){
  if (!(this instanceof CssEmitter)) return new CssEmitter(element);
  this.el = element;
}

/**
 * Bind CSS events.
 *
 * @api public
 */

CssEmitter.prototype.bind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.bind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Unbind CSS events
 * 
 * @api public
 */

CssEmitter.prototype.unbind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.unbind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Fire callback only once
 * 
 * @api public
 */

CssEmitter.prototype.once = function(fn){
  var self = this;
  function on(){
    self.unbind(on);
    fn.apply(self.el, arguments);
  }
  self.bind(on);
  return this;
};


}, {"event":32}],
32: [function(require, module, exports) {
var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};
}, {}],
31: [function(require, module, exports) {

/**
 * Identifier.
 */

var n = 0;

/**
 * Global.
 */

var global = (function(){ return this })();

/**
 * Make `fn` callable only once.
 *
 * @param {Function} fn
 * @return {Function}
 * @api public
 */

module.exports = function(fn) {
  var id = n++;

  function once(){
    // no receiver
    if (this == global) {
      if (once.called) return;
      once.called = true;
      return fn.apply(this, arguments);
    }

    // receiver
    var key = '__called_' + id + '__';
    if (this[key]) return;
    this[key] = true;
    return fn.apply(this, arguments);
  }

  return once;
};

}, {}],
26: [function(require, module, exports) {

var prop = require('transform-property');

// IE <=8 doesn't have `getComputedStyle`
if (!prop || !window.getComputedStyle) {
  module.exports = false;

} else {
  var map = {
    webkitTransform: '-webkit-transform',
    OTransform: '-o-transform',
    msTransform: '-ms-transform',
    MozTransform: '-moz-transform',
    transform: 'transform'
  };

  // from: https://gist.github.com/lorenzopolidori/3794226
  var el = document.createElement('div');
  el.style[prop] = 'translate3d(1px,1px,1px)';
  document.body.insertBefore(el, null);
  var val = getComputedStyle(el).getPropertyValue(map[prop]);
  document.body.removeChild(el);
  module.exports = null != val && val.length && 'none' != val;
}

}, {"transform-property":33}],
33: [function(require, module, exports) {

var styles = [
  'webkitTransform',
  'MozTransform',
  'msTransform',
  'OTransform',
  'transform'
];

var el = document.createElement('p');
var style;

for (var i = 0; i < styles.length; i++) {
  style = styles[i];
  if (null != el.style[style]) {
    module.exports = style;
    break;
  }
}

}, {}],
27: [function(require, module, exports) {

/**
 * CSS Easing functions
 */

module.exports = {
    'in':                'ease-in'
  , 'out':               'ease-out'
  , 'in-out':            'ease-in-out'
  , 'snap':              'cubic-bezier(0,1,.5,1)'
  , 'linear':            'cubic-bezier(0.250, 0.250, 0.750, 0.750)'
  , 'ease-in-quad':      'cubic-bezier(0.550, 0.085, 0.680, 0.530)'
  , 'ease-in-cubic':     'cubic-bezier(0.550, 0.055, 0.675, 0.190)'
  , 'ease-in-quart':     'cubic-bezier(0.895, 0.030, 0.685, 0.220)'
  , 'ease-in-quint':     'cubic-bezier(0.755, 0.050, 0.855, 0.060)'
  , 'ease-in-sine':      'cubic-bezier(0.470, 0.000, 0.745, 0.715)'
  , 'ease-in-expo':      'cubic-bezier(0.950, 0.050, 0.795, 0.035)'
  , 'ease-in-circ':      'cubic-bezier(0.600, 0.040, 0.980, 0.335)'
  , 'ease-in-back':      'cubic-bezier(0.600, -0.280, 0.735, 0.045)'
  , 'ease-out-quad':     'cubic-bezier(0.250, 0.460, 0.450, 0.940)'
  , 'ease-out-cubic':    'cubic-bezier(0.215, 0.610, 0.355, 1.000)'
  , 'ease-out-quart':    'cubic-bezier(0.165, 0.840, 0.440, 1.000)'
  , 'ease-out-quint':    'cubic-bezier(0.230, 1.000, 0.320, 1.000)'
  , 'ease-out-sine':     'cubic-bezier(0.390, 0.575, 0.565, 1.000)'
  , 'ease-out-expo':     'cubic-bezier(0.190, 1.000, 0.220, 1.000)'
  , 'ease-out-circ':     'cubic-bezier(0.075, 0.820, 0.165, 1.000)'
  , 'ease-out-back':     'cubic-bezier(0.175, 0.885, 0.320, 1.275)'
  , 'ease-out-quad':     'cubic-bezier(0.455, 0.030, 0.515, 0.955)'
  , 'ease-out-cubic':    'cubic-bezier(0.645, 0.045, 0.355, 1.000)'
  , 'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'
  , 'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'
  , 'ease-in-out-sine':  'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
  , 'ease-in-out-expo':  'cubic-bezier(1.000, 0.000, 0.000, 1.000)'
  , 'ease-in-out-circ':  'cubic-bezier(0.785, 0.135, 0.150, 0.860)'
  , 'ease-in-out-back':  'cubic-bezier(0.680, -0.550, 0.265, 1.550)'
};

}, {}],
28: [function(require, module, exports) {
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

}, {}],
22: [function(require, module, exports) {

/**
 * Expose `parse`.
 */

module.exports = parse;

/**
 * Tests for browser support.
 */

var div = document.createElement('div');
// Setup
div.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
// Make sure that link elements get serialized correctly by innerHTML
// This requires a wrapper element in IE
var innerHTMLBug = !div.getElementsByTagName('link').length;
div = undefined;

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.text =
map.circle =
map.ellipse =
map.line =
map.path =
map.polygon =
map.polyline =
map.rect = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return a DOM Node instance, which could be a TextNode,
 * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
 * instance, depending on the contents of the `html` string.
 *
 * @param {String} html - HTML string to "domify"
 * @param {Document} doc - The `document` instance to create the Node for
 * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
 * @api private
 */

function parse(html, doc) {
  if ('string' != typeof html) throw new TypeError('String expected');

  // default to the global `document` object
  if (!doc) doc = document;

  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return doc.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = doc.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

}, {}],
23: [function(require, module, exports) {
module.exports = '<div class="List">\n    <h1 class="List-title"></h1>\n    <ul class="List-todos"></ul>\n</div>';
}, {}],
24: [function(require, module, exports) {
'use strict';
var domify = require('component/domify');
var events = require('component/event');
var delegate = require('component/delegate');
var classes = require('component/classes');
var template = require('./template.html');
var View;

/**
 * Initialize `View` with `model`
 * @param {Todo} model
 */
View = function View(model) {
    if (!(this instanceof View)) return new View(model);
    var self = this;
    this.editing = false;
    this.model = model;

    this.el = domify(template);
    this.titleEl = this.el.querySelector('.Todo-title');
    this.checkboxEl = this.el.querySelector('[name=complete]');
    this.destroyEl = this.el.querySelector('.Icon--delete');

    this.titleEl.contentEditable = false;
    this.titleEl.innerHTML = this.model.title;
    this.checkboxEl.checked = model.get('complete');
    this.checkboxEl.id = 'todo-' + this.model._id;
    this.classes = classes(this.el);

    events.bind(this.titleEl, 'blur', this.toggleEditing.bind(this));
    events.bind(this.titleEl, 'click', this.toggleEditing.bind(this));
    events.bind(this.checkboxEl, 'click', this.toggleComplete.bind(this));
    events.bind(this.destroyEl, 'click', this.destroy.bind(this));

    this.el.querySelector('label').htmlFor = 'todo-' + this.model._id;
};

/**
 * Toggle editing mode
 * @api private
 */
View.prototype.toggleEditing = function toggleEditing(event) {
    if (this.titleEl.contentEditable.toString() === 'false') {
        this.titleEl.contentEditable = true;
        this.titleEl.focus();
        classes(this.titleEl).add('is-editing');
        return;
    }
    if (event && event.type === 'click') return;
    this.titleEl.blur();
    classes(this.titleEl).remove('is-editing');
    this.titleEl.contentEditable = false;
};

/**
 * Toggle model's `complete` property
 * @api private
 */
View.prototype.toggleComplete = function toggleComplete() {
    var status = this.checkboxEl.checked;
    this.model.set({complete: status});
    if (this.model.get('complete')) return this.classes.add('complete');
    this.classes.remove('complete');
};

/**
 * Add `hidden` class to `this.el`
 * @api public
 */
View.prototype.hide = function hide() {
    this.classes.add('u-hidden');
};

/**
 * Remove `hidden` class from `this.el`
 * @api public
 */
View.prototype.show = function show() {
    this.classes.remove('u-hidden');
};

/**
 * Emit `destroyed` on model and remove element
 * @api private
 */
View.prototype.destroy = function destroy() {
    this.model.emit('destroy');
    this.el.parentElement.removeChild(this.el);
};

module.exports = View;
}, {"component/domify":22,"component/event":32,"component/delegate":34,"component/classes":18,"./template.html":35}],
34: [function(require, module, exports) {
/**
 * Module dependencies.
 */

var closest = require('closest')
  , event = require('event');

/**
 * Delegate event `type` to `selector`
 * and invoke `fn(e)`. A callback function
 * is returned which may be passed to `.unbind()`.
 *
 * @param {Element} el
 * @param {String} selector
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, selector, type, fn, capture){
  return event.bind(el, type, function(e){
    var target = e.target || e.srcElement;
    e.delegateTarget = closest(target, selector, true, el);
    if (e.delegateTarget) fn.call(el, e);
  }, capture);
};

/**
 * Unbind event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  event.unbind(el, type, fn, capture);
};

}, {"closest":36,"event":32}],
36: [function(require, module, exports) {
var matches = require('matches-selector')

module.exports = function (element, selector, checkYoSelf, root) {
  element = checkYoSelf ? {parentNode: element} : element

  root = root || document

  // Make sure `element !== document` and `element != null`
  // otherwise we get an illegal invocation
  while ((element = element.parentNode) && element !== document) {
    if (matches(element, selector))
      return element
    // After `matches` on the edge case that
    // the selector matches the root
    // (when the root is not the document)
    if (element === root)
      return
  }
}

}, {"matches-selector":37}],
37: [function(require, module, exports) {
/**
 * Module dependencies.
 */

var query = require('query');

/**
 * Element prototype.
 */

var proto = Element.prototype;

/**
 * Vendor function.
 */

var vendor = proto.matches
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

/**
 * Expose `match()`.
 */

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (!el || el.nodeType !== 1) return false;
  if (vendor) return vendor.call(el, selector);
  var nodes = query.all(selector, el.parentNode);
  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i] == el) return true;
  }
  return false;
}

}, {"query":28}],
35: [function(require, module, exports) {
module.exports = '<li class="Todo">\n    <input class="Todo-checkbox" style="display:none" type="checkbox" id="" value="None" name="complete"/>\n    <label for=""></label>\n    <div class="Todo-titleContainer">\n        <div class="Todo-title u-sizeFill" contentEditable></div>\n    </div>\n    <span class="Todo-icon">\n        <span class="Icon Icon--delete">\n            <?xml version="1.0" encoding="iso-8859-1"?>\n            <!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n            <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n            <svg version="1.1" class="Icon--deleteSVG" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n                 viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve">\n                    <path style="fill-rule:evenodd;clip-rule:evenodd;" d="M21.987,11.44c-0.015-0.363-0.15-0.723-0.428-1\n                        c-0.277-0.277-0.637-0.413-1-0.428c-0.404-0.017-0.813,0.119-1.121,0.428L16,13.879l-3.438-3.439\n                        c-0.309-0.309-0.717-0.444-1.121-0.428c-0.363,0.015-0.723,0.15-1,0.428c-0.277,0.277-0.413,0.637-0.428,1\n                        c-0.017,0.404,0.119,0.812,0.428,1.121L13.879,16l-3.438,3.438c-0.309,0.309-0.444,0.717-0.428,1.121\n                        c0.015,0.363,0.15,0.723,0.428,1c0.277,0.277,0.637,0.413,1,0.428c0.404,0.017,0.812-0.119,1.121-0.428L16,18.121l3.439,3.439\n                        c0.309,0.309,0.717,0.444,1.121,0.428c0.363-0.015,0.723-0.15,1-0.428c0.277-0.277,0.413-0.637,0.428-1\n                        c0.017-0.404-0.119-0.812-0.428-1.121L18.121,16l3.438-3.438C21.868,12.253,22.004,11.845,21.987,11.44z M16,0\n                        C7.164,0,0,7.164,0,16c0,8.836,7.164,16,16,16c8.836,0,16-7.164,16-16C32,7.164,24.836,0,16,0z M16,29C8.832,29,3,23.168,3,16\n                        C3,8.832,8.832,3,16,3s13,5.832,13,13C29,23.168,23.168,29,16,29z"/>\n            </svg>\n        </span>\n    </span>\n</li>';
}, {}],
5: [function(require, module, exports) {
'use strict';
var assert = require('component/assert');
var View = require('/lib/list-view/lib/todo-view');
var Todo = require('/lib/list/lib/todo');

describe('TodoView', function () {
    it('returns a new view', function () {
        var todo = Todo();
        var view = View(todo);
        assert(view !== View(todo));
    });
    it('creates todo element', function () {
        var todo = Todo({title: 'Foo'});
        var view = View(todo);
        var title = view.el.querySelector('.Todo-title').innerHTML;
        var checkboxId = view.el.querySelector('[name=complete]').id;
        var labelFor = view.el.querySelector('label').htmlFor;
        assert(title === 'Foo');
        assert(checkboxId === 'todo-' + todo._id);
        assert(labelFor === 'todo-' + todo._id);
    });
});

describe('TodoView#toggleEditing', function () {
    it('sets contenteditable to true', function () {
        var todo = Todo();
        var view = View(todo);
        assert(view.titleEl.contentEditable === 'false');
        view.toggleEditing();
        assert(view.titleEl.contentEditable.toString() === 'true');
    });
    it('adds `is-editing` class to todo element', function () {
        var todo = Todo();
        var view = View(todo);
        assert(!(view.titleEl.classList.contains('is-editing')));
        view.toggleEditing();
        assert(view.titleEl.classList.contains('is-editing'));
    });
    it('removes `is-editing` class from todo element', function () {
        var todo = Todo();
        var view = View(todo);
        assert(!(view.titleEl.classList.contains('is-editing')));
        view.toggleEditing();
        assert(view.titleEl.classList.contains('is-editing'));
        view.toggleEditing();
        assert(!(view.titleEl.classList.contains('is-editing')));
    });
});

describe('TodoView#toggleComplete', function () {
    it('toggles model\'s `complete` property', function () {
        var todo = Todo();
        var view = View(todo);
        assert(view.model.get('complete') === false);
        view.checkboxEl.checked = true;
        view.toggleComplete();
        assert(view.model.get('complete') === true);
    });
    it('adds `complete` class to element', function () {
        var todo = Todo();
        var view = View(todo);
        assert(!(view.el.classList.contains('complete')));
        view.checkboxEl.checked = true;
        view.toggleComplete();
        assert(view.el.classList.contains('complete'));
    });
    it('removes `complete` class from element', function () {
        var todo = Todo();
        var view = View(todo);
        assert(!(view.el.classList.contains('complete')));
        view.checkboxEl.checked = true;
        view.toggleComplete();
        assert(view.el.classList.contains('complete'));
        view.checkboxEl.checked = false;
        view.toggleComplete();
        assert(!(view.el.classList.contains('complete')));
    });
});

describe('TodoView#hide', function () {
    it('adds `u-hidden` class to todo element', function () {
        var todo = Todo();
        var view = View(todo);
        assert(!(view.el.classList.contains('u-hidden')));
        view.hide();
        assert(view.el.classList.contains('u-hidden'));
    });
});

describe('TodoView#show', function () {
    it('removes `u-hidden` class from todo element', function () {
        var todo = Todo();
        var view = View(todo);
        assert(!(view.el.classList.contains('u-hidden')));
        view.hide();
        assert(view.el.classList.contains('u-hidden'));
        view.show();
        assert(!(view.el.classList.contains('u-hidden')));
    });
});

describe('TodoView#destroy', function () {
    it('causes model to emit `destroy`', function (done) {
        var todo = Todo();
        var view = View(todo);
        todo.on('destroy', function () {
            assert(true);
            done();
        });
        view.destroy();
    });
    it('removes the element from the page', function () {
        var el = document.createElement('div');
        var todo = Todo();
        var view = View(todo);
        el.appendChild(view.el);
        assert(el.children.length === 1);
        assert(el.children[0] === view.el);
        view.destroy();
        assert(!el.children.length);
    });
});
}, {"component/assert":6,"/lib/list-view/lib/todo-view":24,"/lib/list/lib/todo":15}]}, {}, {"1":""})

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcXVpcmUuanMiLCJ0ZXN0L2luZGV4LmpzIiwidGVzdC9saXN0LmpzIiwiY29tcG9uZW50cy9jb21wb25lbnQtYXNzZXJ0QDAuNS4wL2luZGV4LmpzIiwiY29tcG9uZW50cy9qa3Jvc28tZXF1YWxzQDEuMC4wL2luZGV4LmpzIiwiY29tcG9uZW50cy9qa3Jvc28tdHlwZUAxLjEuMC9pbmRleC5qcyIsImNvbXBvbmVudHMveWllbGRzLWZtdEAwLjAuMi9pbmRleC5qcyIsImNvbXBvbmVudHMvY29tcG9uZW50LXN0YWNrQDAuMC4xL2luZGV4LmpzIiwibGliL2xpc3QvaW5kZXguanMiLCJjb21wb25lbnRzL3BvdWNoZGItcG91Y2hkYkAzLjEuMC9kaXN0L3BvdWNoZGIuanMiLCJjb21wb25lbnRzL2NvbXBvbmVudC1lbWl0dGVyQDEuMS4zL2luZGV4LmpzIiwiY29tcG9uZW50cy9tYXR0aGV3bXVlbGxlci11aWRAMC4wLjIvaW5kZXguanMiLCJsaWIvbGlzdC9saWIvdG9kby9pbmRleC5qcyIsInRlc3QvdG9kby5qcyIsInRlc3QvbGlzdC12aWV3LmpzIiwiY29tcG9uZW50cy9hbnRob255c2hvcnQtZGF0ZS1tb250aEAwLjAuMS9pbmRleC5qcyIsImNvbXBvbmVudHMvYW50aG9ueXNob3J0LWRhdGUtc3VmZml4QDAuMC4yL2luZGV4LmpzIiwiY29tcG9uZW50cy9jb21wb25lbnQtY2xhc3Nlc0AxLjIuMy9pbmRleC5qcyIsImNvbXBvbmVudHMvY29tcG9uZW50LWluZGV4b2ZAMC4wLjMvaW5kZXguanMiLCJsaWIvbGlzdC12aWV3L2luZGV4LmpzIiwiY29tcG9uZW50cy92aXNpb25tZWRpYS1tb3ZlLmpzQDAuNC4wL2luZGV4LmpzIiwiY29tcG9uZW50cy95aWVsZHMtYWZ0ZXItdHJhbnNpdGlvbkAwLjAuMS9pbmRleC5qcyIsImNvbXBvbmVudHMveWllbGRzLWhhcy10cmFuc2l0aW9uc0AwLjAuMS9pbmRleC5qcyIsImNvbXBvbmVudHMvZWNhcnRlci1jc3MtZW1pdHRlckAwLjAuMS9pbmRleC5qcyIsImNvbXBvbmVudHMvY29tcG9uZW50LWV2ZW50QDAuMS40L2luZGV4LmpzIiwiY29tcG9uZW50cy9jb21wb25lbnQtb25jZUAwLjAuMS9pbmRleC5qcyIsImNvbXBvbmVudHMvY29tcG9uZW50LWhhcy10cmFuc2xhdGUzZEAwLjAuMy9pbmRleC5qcyIsImNvbXBvbmVudHMvY29tcG9uZW50LXRyYW5zZm9ybS1wcm9wZXJ0eUAwLjAuMS9pbmRleC5qcyIsImNvbXBvbmVudHMveWllbGRzLWNzcy1lYXNlQDAuMC4xL2luZGV4LmpzIiwiY29tcG9uZW50cy9jb21wb25lbnQtcXVlcnlAMC4wLjMvaW5kZXguanMiLCJjb21wb25lbnRzL2NvbXBvbmVudC1kb21pZnlAMS4zLjEvaW5kZXguanMiLCJsaWIvbGlzdC12aWV3L3RlbXBsYXRlLmh0bWwiLCJsaWIvbGlzdC12aWV3L2xpYi90b2RvLXZpZXcvaW5kZXguanMiLCJjb21wb25lbnRzL2NvbXBvbmVudC1kZWxlZ2F0ZUAwLjIuMy9pbmRleC5qcyIsImNvbXBvbmVudHMvY29tcG9uZW50LWNsb3Nlc3RAMC4xLjQvaW5kZXguanMiLCJjb21wb25lbnRzL2NvbXBvbmVudC1tYXRjaGVzLXNlbGVjdG9yQDAuMS41L2luZGV4LmpzIiwibGliL2xpc3Qtdmlldy9saWIvdG9kby12aWV3L3RlbXBsYXRlLmh0bWwiLCJ0ZXN0L3RvZG8tdmlldy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNHQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBvdXRlcihtb2R1bGVzLCBjYWNoZSwgZW50cmllcyl7XG5cbiAgLyoqXG4gICAqIEdsb2JhbFxuICAgKi9cblxuICB2YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KSgpO1xuXG4gIC8qKlxuICAgKiBSZXF1aXJlIGBuYW1lYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBqdW1wZWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVxdWlyZShuYW1lLCBqdW1wZWQpe1xuICAgIGlmIChjYWNoZVtuYW1lXSkgcmV0dXJuIGNhY2hlW25hbWVdLmV4cG9ydHM7XG4gICAgaWYgKG1vZHVsZXNbbmFtZV0pIHJldHVybiBjYWxsKG5hbWUsIHJlcXVpcmUpO1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGZpbmQgbW9kdWxlIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIG1vZHVsZSBgaWRgIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsKGlkLCByZXF1aXJlKXtcbiAgICB2YXIgbSA9IGNhY2hlW2lkXSA9IHsgZXhwb3J0czoge30gfTtcbiAgICB2YXIgbW9kID0gbW9kdWxlc1tpZF07XG4gICAgdmFyIG5hbWUgPSBtb2RbMl07XG4gICAgdmFyIGZuID0gbW9kWzBdO1xuXG4gICAgZm4uY2FsbChtLmV4cG9ydHMsIGZ1bmN0aW9uKHJlcSl7XG4gICAgICB2YXIgZGVwID0gbW9kdWxlc1tpZF1bMV1bcmVxXTtcbiAgICAgIHJldHVybiByZXF1aXJlKGRlcCA/IGRlcCA6IHJlcSk7XG4gICAgfSwgbSwgbS5leHBvcnRzLCBvdXRlciwgbW9kdWxlcywgY2FjaGUsIGVudHJpZXMpO1xuXG4gICAgLy8gZXhwb3NlIGFzIGBuYW1lYC5cbiAgICBpZiAobmFtZSkgY2FjaGVbbmFtZV0gPSBjYWNoZVtpZF07XG5cbiAgICByZXR1cm4gY2FjaGVbaWRdLmV4cG9ydHM7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZSBhbGwgZW50cmllcyBleHBvc2luZyB0aGVtIG9uIGdsb2JhbCBpZiBuZWVkZWQuXG4gICAqL1xuXG4gIGZvciAodmFyIGlkIGluIGVudHJpZXMpIHtcbiAgICBpZiAoZW50cmllc1tpZF0pIHtcbiAgICAgIGdsb2JhbFtlbnRyaWVzW2lkXV0gPSByZXF1aXJlKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWlyZShpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIER1byBmbGFnLlxuICAgKi9cblxuICByZXF1aXJlLmR1byA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBjYWNoZS5cbiAgICovXG5cbiAgcmVxdWlyZS5jYWNoZSA9IGNhY2hlO1xuXG4gIC8qKlxuICAgKiBFeHBvc2UgbW9kdWxlc1xuICAgKi9cblxuICByZXF1aXJlLm1vZHVsZXMgPSBtb2R1bGVzO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gbmV3ZXN0IHJlcXVpcmUuXG4gICAqL1xuXG4gICByZXR1cm4gcmVxdWlyZTtcbn0pIiwicmVxdWlyZSgnLi9saXN0LmpzJyk7XG5yZXF1aXJlKCcuL3RvZG8uanMnKTtcbnJlcXVpcmUoJy4vbGlzdC12aWV3LmpzJyk7XG5yZXF1aXJlKCcuL3RvZG8tdmlldy5qcycpOyIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdjb21wb25lbnQvYXNzZXJ0Jyk7XG52YXIgTGlzdCA9IHJlcXVpcmUoJy9saWIvbGlzdCcpO1xuXG5kZXNjcmliZSgnTGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpdCgncmV0dXJucyBhIG5ldyBsaXN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdCA9IExpc3QoKTtcbiAgICAgICAgYXNzZXJ0KGxpc3QgIT09IExpc3QoKSk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0xpc3QjY3JlYXRlVG9kbycsIGZ1bmN0aW9uICgpIHtcbiAgICBpdCgnY3JlYXRlcyBhIG5ldyB0b2RvJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdCA9IExpc3QoKTtcbiAgICAgICAgbGlzdC5jcmVhdGVUb2RvKHt0aXRsZTogJ0Zvbyd9KTtcbiAgICAgICAgYXNzZXJ0KGxpc3QudG9kb3NbMF0udGl0bGUgPT09ICdGb28nKTtcbiAgICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnTGlzdCNyZW1vdmVUb2RvJywgZnVuY3Rpb24gKCkge1xuICAgIGl0KCdyZW1vdmVzIGEgdG9kbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBMaXN0KCk7XG4gICAgICAgIGxpc3QuY3JlYXRlVG9kbyh7dGl0bGU6ICdGb28nfSk7XG4gICAgICAgIGFzc2VydChsaXN0LnRvZG9zWzBdLnRpdGxlID09PSAnRm9vJyk7XG4gICAgICAgIGxpc3QucmVtb3ZlVG9kbyhsaXN0LnRvZG9zWzBdLl9pZCk7XG4gICAgICAgIGFzc2VydChsaXN0LnRvZG9zLmxlbmd0aCA9PT0gMCk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0xpc3QjYXR0cnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3JldHVybnMgdGhlIGxpc3RcXCdzIGF0dHJpYnV0ZXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaXN0ID0gTGlzdCgpO1xuICAgICAgICBsaXN0LmNyZWF0ZVRvZG8oe3RpdGxlOiAnRm9vJ30pO1xuICAgICAgICBhc3NlcnQobGlzdC5hdHRycygpLl9pZCA9PT0gbGlzdC5faWQpO1xuICAgIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdMaXN0LnRvZGF5KCknLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3JldHVybnMgdG9kYXlcXCdzIGxpc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ZXN0ZXJkYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB5ZXN0ZXJkYXkuc2V0RGF0ZSh5ZXN0ZXJkYXkuZ2V0RGF0ZSgpLTEpO1xuICAgICAgICB2YXIgbGlzdDEgPSBMaXN0KCk7XG4gICAgICAgIHZhciBsaXN0MiA9IExpc3QoKTtcbiAgICAgICAgbGlzdDEuY3JlYXRlVG9kbyh7dGl0bGU6ICdGb28nfSk7XG4gICAgICAgIGxpc3QyLmNyZWF0ZVRvZG8oe3RpdGxlOiAnQmFyJ30pO1xuICAgICAgICBsaXN0MS5zYXZlKCk7XG4gICAgICAgIGxpc3QyLnRpbWVzdGFtcCA9IHllc3RlcmRheTtcbiAgICAgICAgbGlzdDIuc2F2ZSgpO1xuICAgICAgICBMaXN0LnRvZGF5KGZ1bmN0aW9uIChlcnIsIGxpc3QpIHtcbiAgICAgICAgICAgIGFzc2VydChlcnIgPT09IG51bGwpO1xuICAgICAgICAgICAgYXNzZXJ0KGxpc3QudG9kb3MubGVuZ3RoID09PSAxKTtcbiAgICAgICAgICAgIGFzc2VydChsaXN0LnRvZG9zWzBdLnRpdGxlID09PSAnRm9vJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdMaXN0Lnllc3RlcmRheSgpJywgZnVuY3Rpb24gKCkge1xuICAgIGl0KCdyZXR1cm5zIHllc3RlcmRheVxcJ3MgbGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHllc3RlcmRheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHllc3RlcmRheS5zZXREYXRlKHllc3RlcmRheS5nZXREYXRlKCktMSk7XG4gICAgICAgIHZhciBsaXN0MSA9IExpc3QoKTtcbiAgICAgICAgdmFyIGxpc3QyID0gTGlzdCgpO1xuICAgICAgICBsaXN0MS5jcmVhdGVUb2RvKHt0aXRsZTogJ0Zvbyd9KTtcbiAgICAgICAgbGlzdDIuY3JlYXRlVG9kbyh7dGl0bGU6ICdCYXInfSk7XG4gICAgICAgIGxpc3QxLnNhdmUoKTtcbiAgICAgICAgbGlzdDIudGltZXN0YW1wID0geWVzdGVyZGF5O1xuICAgICAgICBsaXN0Mi5zYXZlKCk7XG4gICAgICAgIExpc3QueWVzdGVyZGF5KGZ1bmN0aW9uIChlcnIsIGxpc3QpIHtcbiAgICAgICAgICAgIGFzc2VydChlcnIgPT09IG51bGwpO1xuICAgICAgICAgICAgYXNzZXJ0KGxpc3QudG9kb3MubGVuZ3RoID09PSAxKTtcbiAgICAgICAgICAgIGFzc2VydChsaXN0LnRvZG9zWzBdLnRpdGxlID09PSAnQmFyJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7IiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVxdWFscyA9IHJlcXVpcmUoJ2VxdWFscycpO1xudmFyIGZtdCA9IHJlcXVpcmUoJ2ZtdCcpO1xudmFyIHN0YWNrID0gcmVxdWlyZSgnc3RhY2snKTtcblxuLyoqXG4gKiBBc3NlcnQgYGV4cHJgIHdpdGggb3B0aW9uYWwgZmFpbHVyZSBgbXNnYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBleHByXG4gKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKGV4cHIsIG1zZykge1xuICBpZiAoZXhwcikgcmV0dXJuO1xuICB0aHJvdyBlcnJvcihtc2cgfHwgbWVzc2FnZSgpKTtcbn07XG5cbi8qKlxuICogQXNzZXJ0IGBhY3R1YWxgIGlzIHdlYWsgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5lcXVhbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkgcmV0dXJuO1xuICB0aHJvdyBlcnJvcihtc2cgfHwgZm10KCdFeHBlY3RlZCAlbyB0byBlcXVhbCAlby4nLCBhY3R1YWwsIGV4cGVjdGVkKSwgYWN0dWFsLCBleHBlY3RlZCk7XG59O1xuXG4vKipcbiAqIEFzc2VydCBgYWN0dWFsYCBpcyBub3Qgd2VhayBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm5vdEVxdWFsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZykge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSByZXR1cm47XG4gIHRocm93IGVycm9yKG1zZyB8fCBmbXQoJ0V4cGVjdGVkICVvIG5vdCB0byBlcXVhbCAlby4nLCBhY3R1YWwsIGV4cGVjdGVkKSk7XG59O1xuXG4vKipcbiAqIEFzc2VydCBgYWN0dWFsYCBpcyBkZWVwIGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICogQHBhcmFtIHtTdHJpbmd9IFttc2ddXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZykge1xuICBpZiAoZXF1YWxzKGFjdHVhbCwgZXhwZWN0ZWQpKSByZXR1cm47XG4gIHRocm93IGVycm9yKG1zZyB8fCBmbXQoJ0V4cGVjdGVkICVvIHRvIGRlZXBseSBlcXVhbCAlby4nLCBhY3R1YWwsIGV4cGVjdGVkKSwgYWN0dWFsLCBleHBlY3RlZCk7XG59O1xuXG4vKipcbiAqIEFzc2VydCBgYWN0dWFsYCBpcyBub3QgZGVlcCBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgaWYgKCFlcXVhbHMoYWN0dWFsLCBleHBlY3RlZCkpIHJldHVybjtcbiAgdGhyb3cgZXJyb3IobXNnIHx8IGZtdCgnRXhwZWN0ZWQgJW8gbm90IHRvIGRlZXBseSBlcXVhbCAlby4nLCBhY3R1YWwsIGV4cGVjdGVkKSk7XG59O1xuXG4vKipcbiAqIEFzc2VydCBgYWN0dWFsYCBpcyBzdHJpY3QgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHJldHVybjtcbiAgdGhyb3cgZXJyb3IobXNnIHx8IGZtdCgnRXhwZWN0ZWQgJW8gdG8gc3RyaWN0bHkgZXF1YWwgJW8uJywgYWN0dWFsLCBleHBlY3RlZCksIGFjdHVhbCwgZXhwZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBBc3NlcnQgYGFjdHVhbGAgaXMgbm90IHN0cmljdCBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZykge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkgcmV0dXJuO1xuICB0aHJvdyBlcnJvcihtc2cgfHwgZm10KCdFeHBlY3RlZCAlbyBub3QgdG8gc3RyaWN0bHkgZXF1YWwgJW8uJywgYWN0dWFsLCBleHBlY3RlZCkpO1xufTtcblxuLyoqXG4gKiBBc3NlcnQgYGJsb2NrYCB0aHJvd3MgYW4gYGVycm9yYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBibG9ja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXVxuICogQHBhcmFtIHtTdHJpbmd9IFttc2ddXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudGhyb3dzID0gZnVuY3Rpb24gKGJsb2NrLCBlcnIsIG1zZykge1xuICB2YXIgdGhyZXc7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocmV3ID0gZTtcbiAgfVxuXG4gIGlmICghdGhyZXcpIHRocm93IGVycm9yKG1zZyB8fCBmbXQoJ0V4cGVjdGVkICVzIHRvIHRocm93IGFuIGVycm9yLicsIGJsb2NrLnRvU3RyaW5nKCkpKTtcbiAgaWYgKGVyciAmJiAhKHRocmV3IGluc3RhbmNlb2YgZXJyKSkge1xuICAgIHRocm93IGVycm9yKG1zZyB8fCBmbXQoJ0V4cGVjdGVkICVzIHRvIHRocm93IGFuICVvLicsIGJsb2NrLnRvU3RyaW5nKCksIGVycikpO1xuICB9XG59O1xuXG4vKipcbiAqIEFzc2VydCBgYmxvY2tgIGRvZXNuJ3QgdGhyb3cgYW4gYGVycm9yYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBibG9ja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXVxuICogQHBhcmFtIHtTdHJpbmd9IFttc2ddXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gKGJsb2NrLCBlcnIsIG1zZykge1xuICB2YXIgdGhyZXc7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocmV3ID0gZTtcbiAgfVxuXG4gIGlmICh0aHJldykgdGhyb3cgZXJyb3IobXNnIHx8IGZtdCgnRXhwZWN0ZWQgJXMgbm90IHRvIHRocm93IGFuIGVycm9yLicsIGJsb2NrLnRvU3RyaW5nKCkpKTtcbiAgaWYgKGVyciAmJiAodGhyZXcgaW5zdGFuY2VvZiBlcnIpKSB7XG4gICAgdGhyb3cgZXJyb3IobXNnIHx8IGZtdCgnRXhwZWN0ZWQgJXMgbm90IHRvIHRocm93IGFuICVvLicsIGJsb2NrLnRvU3RyaW5nKCksIGVycikpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG1lc3NhZ2UgZnJvbSB0aGUgY2FsbCBzdGFjay5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtZXNzYWdlKCkge1xuICBpZiAoIUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSByZXR1cm4gJ2Fzc2VydGlvbiBmYWlsZWQnO1xuICB2YXIgY2FsbHNpdGUgPSBzdGFjaygpWzJdO1xuICB2YXIgZm4gPSBjYWxsc2l0ZS5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgdmFyIGZpbGUgPSBjYWxsc2l0ZS5nZXRGaWxlTmFtZSgpO1xuICB2YXIgbGluZSA9IGNhbGxzaXRlLmdldExpbmVOdW1iZXIoKSAtIDE7XG4gIHZhciBjb2wgPSBjYWxsc2l0ZS5nZXRDb2x1bW5OdW1iZXIoKSAtIDE7XG4gIHZhciBzcmMgPSBnZXQoZmlsZSk7XG4gIGxpbmUgPSBzcmMuc3BsaXQoJ1xcbicpW2xpbmVdLnNsaWNlKGNvbCk7XG4gIHZhciBtID0gbGluZS5tYXRjaCgvYXNzZXJ0XFwoKC4qKVxcKS8pO1xuICByZXR1cm4gbSAmJiBtWzFdLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBMb2FkIGNvbnRlbnRzIG9mIGBzY3JpcHRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzY3JpcHRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldChzY3JpcHQpIHtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgeGhyLm9wZW4oJ0dFVCcsIHNjcmlwdCwgZmFsc2UpO1xuICB4aHIuc2VuZChudWxsKTtcbiAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG59XG5cbi8qKlxuICogRXJyb3Igd2l0aCBgbXNnYCwgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICogQHJldHVybiB7RXJyb3J9XG4gKi9cblxuZnVuY3Rpb24gZXJyb3IobXNnLCBhY3R1YWwsIGV4cGVjdGVkKXtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc2hvd0RpZmYgPSAzID09IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICByZXR1cm4gZXJyO1xufVxuIiwidmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlJylcblxuLy8gKGFueSwgYW55LCBbYXJyYXldKSAtPiBib29sZWFuXG5mdW5jdGlvbiBlcXVhbChhLCBiLCBtZW1vcyl7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZVxuICB2YXIgZm5BID0gdHlwZXNbdHlwZShhKV1cbiAgdmFyIGZuQiA9IHR5cGVzW3R5cGUoYildXG4gIHJldHVybiBmbkEgJiYgZm5BID09PSBmbkJcbiAgICA/IGZuQShhLCBiLCBtZW1vcylcbiAgICA6IGZhbHNlXG59XG5cbnZhciB0eXBlcyA9IHt9XG5cbi8vIChOdW1iZXIpIC0+IGJvb2xlYW5cbnR5cGVzLm51bWJlciA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiLypOYW4gY2hlY2sqL1xufVxuXG4vLyAoZnVuY3Rpb24sIGZ1bmN0aW9uLCBhcnJheSkgLT4gYm9vbGVhblxudHlwZXNbJ2Z1bmN0aW9uJ10gPSBmdW5jdGlvbihhLCBiLCBtZW1vcyl7XG4gIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKVxuICAgIC8vIEZ1bmN0aW9ucyBjYW4gYWN0IGFzIG9iamVjdHNcbiAgICAmJiB0eXBlcy5vYmplY3QoYSwgYiwgbWVtb3MpXG4gICAgJiYgZXF1YWwoYS5wcm90b3R5cGUsIGIucHJvdG90eXBlKVxufVxuXG4vLyAoZGF0ZSwgZGF0ZSkgLT4gYm9vbGVhblxudHlwZXMuZGF0ZSA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gK2EgPT09ICtiXG59XG5cbi8vIChyZWdleHAsIHJlZ2V4cCkgLT4gYm9vbGVhblxudHlwZXMucmVnZXhwID0gZnVuY3Rpb24oYSwgYil7XG4gIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKVxufVxuXG4vLyAoRE9NRWxlbWVudCwgRE9NRWxlbWVudCkgLT4gYm9vbGVhblxudHlwZXMuZWxlbWVudCA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gYS5vdXRlckhUTUwgPT09IGIub3V0ZXJIVE1MXG59XG5cbi8vICh0ZXh0bm9kZSwgdGV4dG5vZGUpIC0+IGJvb2xlYW5cbnR5cGVzLnRleHRub2RlID0gZnVuY3Rpb24oYSwgYil7XG4gIHJldHVybiBhLnRleHRDb250ZW50ID09PSBiLnRleHRDb250ZW50XG59XG5cbi8vIGRlY29yYXRlIGBmbmAgdG8gcHJldmVudCBpdCByZS1jaGVja2luZyBvYmplY3RzXG4vLyAoZnVuY3Rpb24pIC0+IGZ1bmN0aW9uXG5mdW5jdGlvbiBtZW1vR2F1cmQoZm4pe1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYiwgbWVtb3Mpe1xuICAgIGlmICghbWVtb3MpIHJldHVybiBmbihhLCBiLCBbXSlcbiAgICB2YXIgaSA9IG1lbW9zLmxlbmd0aCwgbWVtb1xuICAgIHdoaWxlIChtZW1vID0gbWVtb3NbLS1pXSkge1xuICAgICAgaWYgKG1lbW9bMF0gPT09IGEgJiYgbWVtb1sxXSA9PT0gYikgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZuKGEsIGIsIG1lbW9zKVxuICB9XG59XG5cbnR5cGVzWydhcmd1bWVudHMnXSA9XG50eXBlcy5hcnJheSA9IG1lbW9HYXVyZChhcnJheUVxdWFsKVxuXG4vLyAoYXJyYXksIGFycmF5LCBhcnJheSkgLT4gYm9vbGVhblxuZnVuY3Rpb24gYXJyYXlFcXVhbChhLCBiLCBtZW1vcyl7XG4gIHZhciBpID0gYS5sZW5ndGhcbiAgaWYgKGkgIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgbWVtb3MucHVzaChbYSwgYl0pXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0sIG1lbW9zKSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxudHlwZXMub2JqZWN0ID0gbWVtb0dhdXJkKG9iamVjdEVxdWFsKVxuXG4vLyAob2JqZWN0LCBvYmplY3QsIGFycmF5KSAtPiBib29sZWFuXG5mdW5jdGlvbiBvYmplY3RFcXVhbChhLCBiLCBtZW1vcykge1xuICBpZiAodHlwZW9mIGEuZXF1YWwgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG1lbW9zLnB1c2goW2EsIGJdKVxuICAgIHJldHVybiBhLmVxdWFsKGIsIG1lbW9zKVxuICB9XG4gIHZhciBrYSA9IGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKGEpXG4gIHZhciBrYiA9IGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKGIpXG4gIHZhciBpID0ga2EubGVuZ3RoXG5cbiAgLy8gc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICBpZiAoaSAhPT0ga2IubGVuZ3RoKSByZXR1cm4gZmFsc2VcblxuICAvLyBhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXJcbiAga2Euc29ydCgpXG4gIGtiLnNvcnQoKVxuXG4gIC8vIGNoZWFwIGtleSB0ZXN0XG4gIHdoaWxlIChpLS0pIGlmIChrYVtpXSAhPT0ga2JbaV0pIHJldHVybiBmYWxzZVxuXG4gIC8vIHJlbWVtYmVyXG4gIG1lbW9zLnB1c2goW2EsIGJdKVxuXG4gIC8vIGl0ZXJhdGUgYWdhaW4gdGhpcyB0aW1lIGRvaW5nIGEgdGhvcm91Z2ggY2hlY2tcbiAgaSA9IGthLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGthW2ldXG4gICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSwgbWVtb3MpKSByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIChvYmplY3QpIC0+IGFycmF5XG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyAob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IgKHZhciBrIGluIG9iamVjdCkgaWYgKGsgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICByZXN1bHQucHVzaChrKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbFxuIiwiXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZ1xudmFyIERvbU5vZGUgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnXG4gID8gd2luZG93Lk5vZGVcbiAgOiBGdW5jdGlvblxuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24oeCl7XG4gIHZhciB0eXBlID0gdHlwZW9mIHhcbiAgaWYgKHR5cGUgIT0gJ29iamVjdCcpIHJldHVybiB0eXBlXG4gIHR5cGUgPSB0eXBlc1t0b1N0cmluZy5jYWxsKHgpXVxuICBpZiAodHlwZSkgcmV0dXJuIHR5cGVcbiAgaWYgKHggaW5zdGFuY2VvZiBEb21Ob2RlKSBzd2l0Y2ggKHgubm9kZVR5cGUpIHtcbiAgICBjYXNlIDE6ICByZXR1cm4gJ2VsZW1lbnQnXG4gICAgY2FzZSAzOiAgcmV0dXJuICd0ZXh0LW5vZGUnXG4gICAgY2FzZSA5OiAgcmV0dXJuICdkb2N1bWVudCdcbiAgICBjYXNlIDExOiByZXR1cm4gJ2RvY3VtZW50LWZyYWdtZW50J1xuICAgIGRlZmF1bHQ6IHJldHVybiAnZG9tLW5vZGUnXG4gIH1cbn1cblxudmFyIHR5cGVzID0gZXhwb3J0cy50eXBlcyA9IHtcbiAgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJyxcbiAgJ1tvYmplY3QgRGF0ZV0nOiAnZGF0ZScsXG4gICdbb2JqZWN0IFJlZ0V4cF0nOiAncmVnZXhwJyxcbiAgJ1tvYmplY3QgQXJndW1lbnRzXSc6ICdhcmd1bWVudHMnLFxuICAnW29iamVjdCBBcnJheV0nOiAnYXJyYXknLFxuICAnW29iamVjdCBTdHJpbmddJzogJ3N0cmluZycsXG4gICdbb2JqZWN0IE51bGxdJzogJ251bGwnLFxuICAnW29iamVjdCBVbmRlZmluZWRdJzogJ3VuZGVmaW5lZCcsXG4gICdbb2JqZWN0IE51bWJlcl0nOiAnbnVtYmVyJyxcbiAgJ1tvYmplY3QgQm9vbGVhbl0nOiAnYm9vbGVhbicsXG4gICdbb2JqZWN0IE9iamVjdF0nOiAnb2JqZWN0JyxcbiAgJ1tvYmplY3QgVGV4dF0nOiAndGV4dC1ub2RlJyxcbiAgJ1tvYmplY3QgVWludDhBcnJheV0nOiAnYml0LWFycmF5JyxcbiAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogJ2JpdC1hcnJheScsXG4gICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6ICdiaXQtYXJyYXknLFxuICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiAnYml0LWFycmF5JyxcbiAgJ1tvYmplY3QgRXJyb3JdJzogJ2Vycm9yJyxcbiAgJ1tvYmplY3QgRm9ybURhdGFdJzogJ2Zvcm0tZGF0YScsXG4gICdbb2JqZWN0IEZpbGVdJzogJ2ZpbGUnLFxuICAnW29iamVjdCBCbG9iXSc6ICdibG9iJ1xufVxuIiwiXG4vKipcbiAqIEV4cG9ydCBgZm10YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZm10O1xuXG4vKipcbiAqIEZvcm1hdHRlcnNcbiAqL1xuXG5mbXQubyA9IEpTT04uc3RyaW5naWZ5O1xuZm10LnMgPSBTdHJpbmc7XG5mbXQuZCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIEZvcm1hdCB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHsuLi59IGFyZ3NcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm10KHN0cil7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgaiA9IDA7XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8lKFthLXpdKS9naSwgZnVuY3Rpb24oXywgZil7XG4gICAgcmV0dXJuIGZtdFtmXVxuICAgICAgPyBmbXRbZl0oYXJnc1tqKytdKVxuICAgICAgOiBfICsgZjtcbiAgfSk7XG59XG4iLCJcbi8qKlxuICogRXhwb3NlIGBzdGFjaygpYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrO1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RhY2suXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHN0YWNrKCkge1xuICB2YXIgb3JpZyA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uKF8sIHN0YWNrKXsgcmV0dXJuIHN0YWNrOyB9O1xuICB2YXIgZXJyID0gbmV3IEVycm9yO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFyZ3VtZW50cy5jYWxsZWUpO1xuICB2YXIgc3RhY2sgPSBlcnIuc3RhY2s7XG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gb3JpZztcbiAgcmV0dXJuIHN0YWNrO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciBQb3VjaERCID0gcmVxdWlyZSgncG91Y2hkYi9wb3VjaGRiQDMuMS4wJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC9lbWl0dGVyJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnbWF0dGhld211ZWxsZXIvdWlkJyk7XG52YXIgVG9kbyA9IHJlcXVpcmUoJy4vbGliL3RvZG8nKTtcbnZhciBMaXN0O1xudmFyIGRiO1xuXG5kYiA9IG5ldyBQb3VjaERCKCdkYWlseV90b2RvX2xpc3RzJyk7XG5cbmZ1bmN0aW9uIGlzVG9kYXkodGQpIHtcbiAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gICAgaWYgKGlzTmFOKHRkLmdldFRpbWUoKSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGQuZ2V0RGF0ZSgpID09IGQuZ2V0RGF0ZSgpICYmIHRkLmdldE1vbnRoKCkgPT0gZC5nZXRNb250aCgpICYmIHRkLmdldEZ1bGxZZWFyKCkgPT0gZC5nZXRGdWxsWWVhcigpO1xufTtcblxuZnVuY3Rpb24gaXNZZXN0ZXJkYXkoeWQpIHtcbiAgICB2YXIgeSA9IG5ldyBEYXRlKCk7XG4gICAgeS5zZXREYXRlKHkuZ2V0RGF0ZSgpLTEpO1xuICAgIHJldHVybiB5ZC5nZXREYXRlKCkgPT0geS5nZXREYXRlKCkgJiYgeWQuZ2V0TW9udGgoKSA9PSB5LmdldE1vbnRoKCkgJiYgeWQuZ2V0RnVsbFllYXIoKSA9PSB5LmdldEZ1bGxZZWFyKCk7XG59O1xuXG5MaXN0ID0gZnVuY3Rpb24gTGlzdChhdHRycykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaXN0KSkgcmV0dXJuIG5ldyBMaXN0KGF0dHJzKTtcbiAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdG1wVG9kb3MgPSBhdHRycy50b2RvcyB8fCBbXTtcbiAgICB0aGlzLl9pZCA9IGF0dHJzLl9pZCB8fCB1aWQoKTtcbiAgICB0aGlzLl9yZXYgPSBhdHRycy5fcmV2IHx8IC0xO1xuICAgIHRoaXMudGltZXN0YW1wID0gYXR0cnMudGltZXN0YW1wID8gbmV3IERhdGUoYXR0cnMudGltZXN0YW1wKSA6IG5ldyBEYXRlKCk7XG4gICAgdGhpcy50b2RvcyA9IFtdO1xuICAgIHRtcFRvZG9zLmZvckVhY2goZnVuY3Rpb24gKHRvZG8sIGluZGV4KSB7XG4gICAgICAgIHNlbGYuY3JlYXRlVG9kbyh0b2RvKTtcbiAgICB9KTtcbn07XG5cbkVtaXR0ZXIoTGlzdC5wcm90b3R5cGUpO1xuXG5MaXN0LmFsbCA9IGZ1bmN0aW9uIGFsbCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBbXTtcbiAgICBkYi5hbGxEb2NzKHtpbmNsdWRlX2RvY3M6IHRydWV9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIGlmIChyZXMucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5yb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChuZXcgTGlzdChyb3cpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYihjb2xsZWN0aW9uKTtcbiAgICB9KTtcbn07XG5cbkxpc3QudG9kYXkgPSBmdW5jdGlvbiB0b2RheShjYikge1xuICAgIGRiLnF1ZXJ5KGZ1bmN0aW9uIChkb2MsIGVtaXQpIHtcbiAgICAgICAgaWYgKGlzVG9kYXkobmV3IERhdGUoZG9jLnRpbWVzdGFtcCkpKSB7XG4gICAgICAgICAgICBlbWl0KGRvYyk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIGlmIChyZXMucm93cy5sZW5ndGggPD0gMCkgcmV0dXJuIGNiKG51bGwsIExpc3QoKSk7XG4gICAgICAgIHJldHVybiBjYihudWxsLCBMaXN0KHJlcy5yb3dzWzBdLmtleSkpO1xuICAgIH0pO1xufTtcblxuTGlzdC55ZXN0ZXJkYXkgPSBmdW5jdGlvbiB5ZXN0ZXJkYXkoY2IpIHtcbiAgICBkYi5xdWVyeShmdW5jdGlvbiAoZG9jLCBlbWl0KSB7XG4gICAgICAgIGlmIChpc1llc3RlcmRheShuZXcgRGF0ZShkb2MudGltZXN0YW1wKSkpIHtcbiAgICAgICAgICAgIGVtaXQoZG9jKTtcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgaWYgKHJlcy5yb3dzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCktMSk7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbmV3IExpc3Qoe3RpbWVzdGFtcDogZGF0ZX0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgbmV3IExpc3QocmVzLnJvd3NbMF0ua2V5KSk7XG4gICAgfSk7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5hdHRycyA9IGZ1bmN0aW9uIGF0dHJzKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIGlmICh0aGlzLl9pZCkgcHJvcHMuX2lkID0gdGhpcy5faWQ7XG4gICAgaWYgKHRoaXMuX3JldiAhPT0gLTEpIHByb3BzLl9yZXYgPSB0aGlzLl9yZXY7XG4gICAgcHJvcHMudGltZXN0YW1wID0gdGhpcy50aW1lc3RhbXA7XG4gICAgcHJvcHMudG9kb3MgPSBbXTtcbiAgICB0aGlzLnRvZG9zLmZvckVhY2goZnVuY3Rpb24gKHRvZG8pIHtcbiAgICAgICAgcHJvcHMudG9kb3MucHVzaCh0b2RvLmF0dHJzKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9wcztcbn07XG5cbkxpc3QucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGRiLnB1dCh0aGlzLmF0dHJzKCksIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuICAgICAgICBpZiAoZXJyICYmIGNiKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgICBzZWxmLl9yZXYgPSBkb2MucmV2O1xuICAgICAgICBpZiAoY2IpIHJldHVybiBjYigpO1xuICAgIH0pO1xufTtcblxuTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGNiKSB7XG4gICAgZGIucmVtb3ZlKHRoaXMuYXR0cnMoKSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHRocm93IGVycjtcbiAgICAgICAgaWYgKGNiKSByZXR1cm4gY2IobnVsbCwgcmVzKTtcbiAgICB9KTtcbn07XG5cblxuTGlzdC5wcm90b3R5cGUuY3JlYXRlVG9kbyA9IGZ1bmN0aW9uIGNyZWF0ZVRvZG8oYXR0cnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRvZG8gPSBuZXcgVG9kbyhhdHRycyk7XG4gICAgdG9kby5vbignY2hhbmdlJywgZnVuY3Rpb24gKHByb3AsIHZhbCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2NoYW5nZSB0b2RvJywgdG9kbywgcHJvcCwgdmFsKTtcbiAgICB9KTtcblxuICAgIHRvZG8ub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gdGhpcztcbiAgICAgICAgdmFyIGluZGV4ID0gc2VsZi50b2Rvcy5pbmRleE9mKHRvZG8pO1xuICAgICAgICBzZWxmLnRvZG9zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHNlbGYuc2F2ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMudG9kb3MucHVzaCh0b2RvKTtcbiAgICB0aGlzLmVtaXQoJ2NyZWF0ZSB0b2RvJywgdG9kbyk7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5yZW1vdmVUb2RvID0gZnVuY3Rpb24gcmVtb3ZlVG9kbyhfaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy50b2Rvcy5mb3JFYWNoKGZ1bmN0aW9uICh0b2RvLCBpbmRleCkge1xuICAgICAgICBpZiAodG9kby5faWQgPT09IF9pZCkge1xuICAgICAgICAgICAgc2VsZi50b2Rvcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdyZW1vdmUgdG9kbycsIHRvZG8pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3Q7IiwiLy8gICAgUG91Y2hEQiAzLjEuMFxuLy8gICAgXG4vLyAgICAoYykgMjAxMi0yMDE0IERhbGUgSGFydmV5IGFuZCB0aGUgUG91Y2hEQiB0ZWFtXG4vLyAgICBQb3VjaERCIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEFwYWNoZSBsaWNlbnNlLCB2ZXJzaW9uIDIuMC5cbi8vICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgIGh0dHA6Ly9wb3VjaGRiLmNvbVxuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuUG91Y2hEQj1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWxzJyk7XG52YXIgbWVyZ2UgPSBfZGVyZXFfKCcuL21lcmdlJyk7XG52YXIgZXJyb3JzID0gX2RlcmVxXygnLi9kZXBzL2Vycm9ycycpO1xudmFyIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1cHNlcnQgPSBfZGVyZXFfKCcuL2RlcHMvdXBzZXJ0Jyk7XG52YXIgQ2hhbmdlcyA9IF9kZXJlcV8oJy4vY2hhbmdlcycpO1xudmFyIFByb21pc2UgPSB1dGlscy5Qcm9taXNlO1xuXG4vKlxuICogQSBnZW5lcmljIHBvdWNoIGFkYXB0ZXJcbiAqL1xuXG4vLyByZXR1cm5zIGZpcnN0IGVsZW1lbnQgb2YgYXJyIHNhdGlzZnlpbmcgY2FsbGJhY2sgcHJlZGljYXRlXG5mdW5jdGlvbiBhcnJheUZpcnN0KGFyciwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGFycltpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBXcmFwcGVyIGZvciBmdW5jdGlvbnMgdGhhdCBjYWxsIHRoZSBidWxrZG9jcyBhcGkgd2l0aCBhIHNpbmdsZSBkb2MsXG4vLyBpZiB0aGUgZmlyc3QgcmVzdWx0IGlzIGFuIGVycm9yLCByZXR1cm4gYW4gZXJyb3JcbmZ1bmN0aW9uIHlhbmtFcnJvcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgIGlmIChlcnIgfHwgKHJlc3VsdHNbMF0gJiYgcmVzdWx0c1swXS5lcnJvcikpIHtcbiAgICAgIGNhbGxiYWNrKGVyciB8fCByZXN1bHRzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cy5sZW5ndGggPyByZXN1bHRzWzBdICA6IHJlc3VsdHMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gZm9yIGV2ZXJ5IG5vZGUgaW4gYSByZXZpc2lvbiB0cmVlIGNvbXB1dGVzIGl0cyBkaXN0YW5jZSBmcm9tIHRoZSBjbG9zZXN0XG4vLyBsZWFmXG5mdW5jdGlvbiBjb21wdXRlSGVpZ2h0KHJldnMpIHtcbiAgdmFyIGhlaWdodCA9IHt9O1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgbWVyZ2UudHJhdmVyc2VSZXZUcmVlKHJldnMsIGZ1bmN0aW9uIChpc0xlYWYsIHBvcywgaWQsIHBybnQpIHtcbiAgICB2YXIgcmV2ID0gcG9zICsgXCItXCIgKyBpZDtcbiAgICBpZiAoaXNMZWFmKSB7XG4gICAgICBoZWlnaHRbcmV2XSA9IDA7XG4gICAgfVxuICAgIGlmIChwcm50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVkZ2VzLnB1c2goe2Zyb206IHBybnQsIHRvOiByZXZ9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldjtcbiAgfSk7XG5cbiAgZWRnZXMucmV2ZXJzZSgpO1xuICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgaWYgKGhlaWdodFtlZGdlLmZyb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlaWdodFtlZGdlLmZyb21dID0gMSArIGhlaWdodFtlZGdlLnRvXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0W2VkZ2UuZnJvbV0gPSBNYXRoLm1pbihoZWlnaHRbZWRnZS5mcm9tXSwgMSArIGhlaWdodFtlZGdlLnRvXSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhlaWdodDtcbn1cblxuZnVuY3Rpb24gYWxsRG9jc0tleXNRdWVyeShhcGksIG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBrZXlzID0gICgnbGltaXQnIGluIG9wdHMpID9cbiAgICAgIG9wdHMua2V5cy5zbGljZShvcHRzLnNraXAsIG9wdHMubGltaXQgKyBvcHRzLnNraXApIDpcbiAgICAgIChvcHRzLnNraXAgPiAwKSA/IG9wdHMua2V5cy5zbGljZShvcHRzLnNraXApIDogb3B0cy5rZXlzO1xuICBpZiAob3B0cy5kZXNjZW5kaW5nKSB7XG4gICAga2V5cy5yZXZlcnNlKCk7XG4gIH1cbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBhcGkuX2FsbERvY3Moe2xpbWl0OiAwfSwgY2FsbGJhY2spO1xuICB9XG4gIHZhciBmaW5hbFJlc3VsdHMgPSB7XG4gICAgb2Zmc2V0OiBvcHRzLnNraXBcbiAgfTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGtleXMubWFwKGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICB2YXIgc3ViT3B0cyA9IHV0aWxzLmV4dGVuZCh0cnVlLCB7a2V5OiBrZXksIGRlbGV0ZWQ6ICdvayd9LCBvcHRzKTtcbiAgICBbJ2xpbWl0JywgJ3NraXAnLCAna2V5cyddLmZvckVhY2goZnVuY3Rpb24gKG9wdEtleSkge1xuICAgICAgZGVsZXRlIHN1Yk9wdHNbb3B0S2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXBpLl9hbGxEb2NzKHN1Yk9wdHMsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsUmVzdWx0cy50b3RhbF9yb3dzID0gcmVzLnRvdGFsX3Jvd3M7XG4gICAgICAgIHJlc29sdmUocmVzLnJvd3NbMF0gfHwge2tleToga2V5LCBlcnJvcjogJ25vdF9mb3VuZCd9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgIGZpbmFsUmVzdWx0cy5yb3dzID0gcmVzdWx0cztcbiAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICB9KTtcbn1cblxudXRpbHMuaW5oZXJpdHMoQWJzdHJhY3RQb3VjaERCLCBFdmVudEVtaXR0ZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFBvdWNoREI7XG5cbmZ1bmN0aW9uIEFic3RyYWN0UG91Y2hEQigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgc2VsZi5hdXRvQ29tcGFjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIGh0dHAgZG9lc24ndCBoYXZlIGF1dG8tY29tcGFjdGlvblxuICAgIGlmICghc2VsZi5hdXRvX2NvbXBhY3Rpb24gfHwgc2VsZi50eXBlKCkgPT09ICdodHRwJykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY291bnQgPSByZXMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVjQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICAgICAgICAgIGlmIChkb2Mub2sgJiYgZG9jLmlkKSB7IC8vIGlmIG5vIGlkLCB0aGVuIGl0IHdhcyBhIGxvY2FsIGRvY1xuICAgICAgICAgICAgLy8gVE9ETzogd2UgbmVlZCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgIHNlbGYuY29tcGFjdERvY3VtZW50KGRvYy5pZCwgMCwgZGVjQ291bnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWNDb3VudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJzID0gMCwgY2hhbmdlcztcbiAgdmFyIGV2ZW50TmFtZXMgPSBbJ2NoYW5nZScsICdkZWxldGUnLCAnY3JlYXRlJywgJ3VwZGF0ZSddO1xuICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICBpZiAofmV2ZW50TmFtZXMuaW5kZXhPZihldmVudE5hbWUpKSB7XG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVycysrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lcnMrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGFzdENoYW5nZSA9IDA7XG4gICAgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyh7XG4gICAgICBjb25mbGljdHM6IHRydWUsXG4gICAgICBpbmNsdWRlX2RvY3M6IHRydWUsXG4gICAgICBjb250aW51b3VzOiB0cnVlLFxuICAgICAgc2luY2U6ICdub3cnLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5zZXEgPD0gbGFzdENoYW5nZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2hhbmdlID0gY2hhbmdlLnNlcTtcbiAgICAgICAgc2VsZi5lbWl0KCdjaGFuZ2UnLCBjaGFuZ2UpO1xuICAgICAgICBpZiAoY2hhbmdlLmRvYy5fZGVsZXRlZCkge1xuICAgICAgICAgIHNlbGYuZW1pdCgnZGVsZXRlJywgY2hhbmdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UuZG9jLl9yZXYuc3BsaXQoJy0nKVswXSA9PT0gJzEnKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KCdjcmVhdGUnLCBjaGFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgaWYgKH5ldmVudE5hbWVzLmluZGV4T2YoZXZlbnROYW1lKSkge1xuICAgICAgbGlzdGVuZXJzLS07XG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjaGFuZ2VzLmNhbmNlbCgpO1xuICB9KTtcbn1cblxuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5wb3N0ID1cbiAgdXRpbHMuYWRhcHRlckZ1bigncG9zdCcsIGZ1bmN0aW9uIChkb2MsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiBkb2MgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZG9jKSkge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuTk9UX0FOX09CSkVDVCk7XG4gIH1cbiAgdGhpcy5idWxrRG9jcyh7ZG9jczogW2RvY119LCBvcHRzLFxuICAgICAgdGhpcy5hdXRvQ29tcGFjdCh5YW5rRXJyb3IoY2FsbGJhY2spKSk7XG59KTtcblxuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5wdXQgPVxuICB1dGlscy5hZGFwdGVyRnVuKCdwdXQnLCB1dGlscy5nZXRBcmd1bWVudHMoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgdmFyIHRlbXAsIHRlbXB0eXBlLCBvcHRzLCBjYWxsYmFjaztcbiAgdmFyIGRvYyA9IGFyZ3Muc2hpZnQoKTtcbiAgdmFyIGlkID0gJ19pZCcgaW4gZG9jO1xuICBpZiAodHlwZW9mIGRvYyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShkb2MpKSB7XG4gICAgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuTk9UX0FOX09CSkVDVCk7XG4gIH1cbiAgZG9jID0gdXRpbHMuY2xvbmUoZG9jKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0ZW1wID0gYXJncy5zaGlmdCgpO1xuICAgIHRlbXB0eXBlID0gdHlwZW9mIHRlbXA7XG4gICAgaWYgKHRlbXB0eXBlID09PSBcInN0cmluZ1wiICYmICFpZCkge1xuICAgICAgZG9jLl9pZCA9IHRlbXA7XG4gICAgICBpZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0ZW1wdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBpZCAmJiAhKCdfcmV2JyBpbiBkb2MpKSB7XG4gICAgICBkb2MuX3JldiA9IHRlbXA7XG4gICAgfSBlbHNlIGlmICh0ZW1wdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3B0cyA9IHRlbXA7XG4gICAgfSBlbHNlIGlmICh0ZW1wdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IHRlbXA7XG4gICAgfVxuICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIGVycm9yID0gdXRpbHMuaW52YWxpZElkRXJyb3IoZG9jLl9pZCk7XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gIH1cbiAgaWYgKHV0aWxzLmlzTG9jYWxJZChkb2MuX2lkKSAmJiB0eXBlb2YgdGhpcy5fcHV0TG9jYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZG9jLl9kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlTG9jYWwoZG9jLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXRMb2NhbChkb2MsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5idWxrRG9jcyh7ZG9jczogW2RvY119LCBvcHRzLFxuICAgICAgdGhpcy5hdXRvQ29tcGFjdCh5YW5rRXJyb3IoY2FsbGJhY2spKSk7XG59KSk7XG5cbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUucHV0QXR0YWNobWVudCA9XG4gIHV0aWxzLmFkYXB0ZXJGdW4oJ3B1dEF0dGFjaG1lbnQnLCBmdW5jdGlvbiAoZG9jSWQsIGF0dGFjaG1lbnRJZCwgcmV2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2IsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhcGkgPSB0aGlzO1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHR5cGU7XG4gICAgdHlwZSA9IGJsb2I7XG4gICAgYmxvYiA9IHJldjtcbiAgICByZXYgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0eXBlID0gYmxvYjtcbiAgICBibG9iID0gcmV2O1xuICAgIHJldiA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBdHRhY2htZW50KGRvYykge1xuICAgIGRvYy5fYXR0YWNobWVudHMgPSBkb2MuX2F0dGFjaG1lbnRzIHx8IHt9O1xuICAgIGRvYy5fYXR0YWNobWVudHNbYXR0YWNobWVudElkXSA9IHtcbiAgICAgIGNvbnRlbnRfdHlwZTogdHlwZSxcbiAgICAgIGRhdGE6IGJsb2JcbiAgICB9O1xuICAgIHJldHVybiBhcGkucHV0KGRvYyk7XG4gIH1cblxuICByZXR1cm4gYXBpLmdldChkb2NJZCkudGhlbihmdW5jdGlvbiAoZG9jKSB7XG4gICAgaWYgKGRvYy5fcmV2ICE9PSByZXYpIHtcbiAgICAgIHRocm93IGVycm9ycy5SRVZfQ09ORkxJQ1Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUF0dGFjaG1lbnQoZG9jKTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAvLyBjcmVhdGUgbmV3IGRvY1xuICAgIGlmIChlcnIuZXJyb3IgPT09IGVycm9ycy5NSVNTSU5HX0RPQy5lcnJvcikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUF0dGFjaG1lbnQoe19pZDogZG9jSWR9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSk7XG59KTtcblxuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5yZW1vdmVBdHRhY2htZW50ID1cbiAgdXRpbHMuYWRhcHRlckZ1bigncmVtb3ZlQXR0YWNobWVudCcsIGZ1bmN0aW9uIChkb2NJZCwgYXR0YWNobWVudElkLCByZXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmdldChkb2NJZCwgZnVuY3Rpb24gKGVyciwgb2JqKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9iai5fcmV2ICE9PSByZXYpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9ycy5SRVZfQ09ORkxJQ1QpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9iai5fYXR0YWNobWVudHMpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBkZWxldGUgb2JqLl9hdHRhY2htZW50c1thdHRhY2htZW50SWRdO1xuICAgIGlmIChPYmplY3Qua2V5cyhvYmouX2F0dGFjaG1lbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSBvYmouX2F0dGFjaG1lbnRzO1xuICAgIH1cbiAgICBzZWxmLnB1dChvYmosIGNhbGxiYWNrKTtcbiAgfSk7XG59KTtcblxuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5yZW1vdmUgPVxuICB1dGlscy5hZGFwdGVyRnVuKCdyZW1vdmUnLCBmdW5jdGlvbiAoZG9jT3JJZCwgb3B0c09yUmV2LCBvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgZG9jO1xuICBpZiAodHlwZW9mIG9wdHNPclJldiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCwgcmV2LCBvcHRzLCBjYWxsYmFjayBzdHlsZVxuICAgIGRvYyA9IHtcbiAgICAgIF9pZDogZG9jT3JJZCxcbiAgICAgIF9yZXY6IG9wdHNPclJldlxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRvYywgb3B0cywgY2FsbGJhY2sgc3R5bGVcbiAgICBkb2MgPSBkb2NPcklkO1xuICAgIGlmICh0eXBlb2Ygb3B0c09yUmV2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHNPclJldjtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgICAgb3B0cyA9IG9wdHNPclJldjtcbiAgICB9XG4gIH1cbiAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMgfHwge30pO1xuICBvcHRzLndhc19kZWxldGUgPSB0cnVlO1xuICB2YXIgbmV3RG9jID0ge19pZDogZG9jLl9pZCwgX3JldjogKGRvYy5fcmV2IHx8IG9wdHMucmV2KX07XG4gIG5ld0RvYy5fZGVsZXRlZCA9IHRydWU7XG4gIGlmICh1dGlscy5pc0xvY2FsSWQobmV3RG9jLl9pZCkgJiYgdHlwZW9mIHRoaXMuX3JlbW92ZUxvY2FsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW92ZUxvY2FsKGRvYywgY2FsbGJhY2spO1xuICB9XG4gIHRoaXMuYnVsa0RvY3Moe2RvY3M6IFtuZXdEb2NdfSwgb3B0cywgeWFua0Vycm9yKGNhbGxiYWNrKSk7XG59KTtcblxuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5yZXZzRGlmZiA9XG4gIHV0aWxzLmFkYXB0ZXJGdW4oJ3JldnNEaWZmJywgZnVuY3Rpb24gKHJlcSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICBvcHRzID0gdXRpbHMuY2xvbmUob3B0cyk7XG4gIHZhciBpZHMgPSBPYmplY3Qua2V5cyhyZXEpO1xuXG4gIGlmICghaWRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7fSk7XG4gIH1cblxuICB2YXIgY291bnQgPSAwO1xuICB2YXIgbWlzc2luZyA9IG5ldyB1dGlscy5NYXAoKTtcblxuICBmdW5jdGlvbiBhZGRUb01pc3NpbmcoaWQsIHJldklkKSB7XG4gICAgaWYgKCFtaXNzaW5nLmhhcyhpZCkpIHtcbiAgICAgIG1pc3Npbmcuc2V0KGlkLCB7bWlzc2luZzogW119KTtcbiAgICB9XG4gICAgbWlzc2luZy5nZXQoaWQpLm1pc3NpbmcucHVzaChyZXZJZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRG9jKGlkLCByZXZfdHJlZSkge1xuICAgIC8vIElzIHRoaXMgZmFzdCBlbm91Z2g/IE1heWJlIHdlIHNob3VsZCBzd2l0Y2ggdG8gYSBzZXQgc2ltdWxhdGVkIGJ5IGEgbWFwXG4gICAgdmFyIG1pc3NpbmdGb3JJZCA9IHJlcVtpZF0uc2xpY2UoMCk7XG4gICAgbWVyZ2UudHJhdmVyc2VSZXZUcmVlKHJldl90cmVlLCBmdW5jdGlvbiAoaXNMZWFmLCBwb3MsIHJldkhhc2gsIGN0eCxcbiAgICAgIG9wdHMpIHtcbiAgICAgICAgdmFyIHJldiA9IHBvcyArICctJyArIHJldkhhc2g7XG4gICAgICAgIHZhciBpZHggPSBtaXNzaW5nRm9ySWQuaW5kZXhPZihyZXYpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pc3NpbmdGb3JJZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgaWYgKG9wdHMuc3RhdHVzICE9PSAnYXZhaWxhYmxlJykge1xuICAgICAgICAgIGFkZFRvTWlzc2luZyhpZCwgcmV2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAvLyBUcmF2ZXJzaW5nIHRoZSB0cmVlIGlzIHN5bmNocm9ub3VzLCBzbyBub3cgYG1pc3NpbmdGb3JJZGAgY29udGFpbnNcbiAgICAvLyByZXZpc2lvbnMgdGhhdCB3ZXJlIG5vdCBmb3VuZCBpbiB0aGUgdHJlZVxuICAgIG1pc3NpbmdGb3JJZC5mb3JFYWNoKGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgIGFkZFRvTWlzc2luZyhpZCwgcmV2KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgdGhpcy5fZ2V0UmV2aXNpb25UcmVlKGlkLCBmdW5jdGlvbiAoZXJyLCByZXZfdHJlZSkge1xuICAgICAgaWYgKGVyciAmJiBlcnIuc3RhdHVzID09PSA0MDQgJiYgZXJyLm1lc3NhZ2UgPT09ICdtaXNzaW5nJykge1xuICAgICAgICBtaXNzaW5nLnNldChpZCwge21pc3Npbmc6IHJlcVtpZF19KTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0RvYyhpZCwgcmV2X3RyZWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKytjb3VudCA9PT0gaWRzLmxlbmd0aCkge1xuICAgICAgICAvLyBjb252ZXJ0IExhenlNYXAgdG8gb2JqZWN0XG4gICAgICAgIHZhciBtaXNzaW5nT2JqID0ge307XG4gICAgICAgIG1pc3NpbmcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIG1pc3NpbmdPYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG1pc3NpbmdPYmopO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCB0aGlzKTtcbn0pO1xuXG4vLyBjb21wYWN0IG9uZSBkb2N1bWVudCBhbmQgZmlyZSBjYWxsYmFja1xuLy8gYnkgY29tcGFjdGluZyB3ZSBtZWFuIHJlbW92aW5nIGFsbCByZXZpc2lvbnMgd2hpY2hcbi8vIGFyZSBmdXJ0aGVyIGZyb20gdGhlIGxlYWYgaW4gcmV2aXNpb24gdHJlZSB0aGFuIG1heF9oZWlnaHRcbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUuY29tcGFjdERvY3VtZW50ID1cbiAgdXRpbHMuYWRhcHRlckZ1bignY29tcGFjdERvY3VtZW50JywgZnVuY3Rpb24gKGRvY0lkLCBtYXhIZWlnaHQsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fZ2V0UmV2aXNpb25UcmVlKGRvY0lkLCBmdW5jdGlvbiAoZXJyLCByZXZUcmVlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIHZhciBoZWlnaHQgPSBjb21wdXRlSGVpZ2h0KHJldlRyZWUpO1xuICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgdmFyIHJldnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhoZWlnaHQpLmZvckVhY2goZnVuY3Rpb24gKHJldikge1xuICAgICAgaWYgKGhlaWdodFtyZXZdID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChyZXYpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWVyZ2UudHJhdmVyc2VSZXZUcmVlKHJldlRyZWUsIGZ1bmN0aW9uIChpc0xlYWYsIHBvcywgcmV2SGFzaCwgY3R4LCBvcHRzKSB7XG4gICAgICB2YXIgcmV2ID0gcG9zICsgJy0nICsgcmV2SGFzaDtcbiAgICAgIGlmIChvcHRzLnN0YXR1cyA9PT0gJ2F2YWlsYWJsZScgJiYgY2FuZGlkYXRlcy5pbmRleE9mKHJldikgIT09IC0xKSB7XG4gICAgICAgIHJldnMucHVzaChyZXYpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYuX2RvQ29tcGFjdGlvbihkb2NJZCwgcmV2cywgY2FsbGJhY2spO1xuICB9KTtcbn0pO1xuXG4vLyBjb21wYWN0IHRoZSB3aG9sZSBkYXRhYmFzZSB1c2luZyBzaW5nbGUgZG9jdW1lbnRcbi8vIGNvbXBhY3Rpb25cbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUuY29tcGFjdCA9XG4gIHV0aWxzLmFkYXB0ZXJGdW4oJ2NvbXBhY3QnLCBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMgfHwge30pO1xuXG4gIHNlbGYuZ2V0KCdfbG9jYWwvY29tcGFjdGlvbicpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSkudGhlbihmdW5jdGlvbiAoZG9jKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmLl9jb21wYWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZG9jICYmIGRvYy5sYXN0X3NlcSkge1xuICAgICAgICBvcHRzLmxhc3Rfc2VxID0gZG9jLmxhc3Rfc2VxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuX2NvbXBhY3Qob3B0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICB9KTtcbn0pO1xuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5fY29tcGFjdCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgc3RhcnRlZCA9IDA7XG4gIHZhciBjb3B0cyA9IHtcbiAgICByZXR1cm5Eb2NzOiBmYWxzZVxuICB9O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXN0U2VxO1xuICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdXBzZXJ0KHNlbGYsICdfbG9jYWwvY29tcGFjdGlvbicsIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIGlmICghZG9jLmxhc3Rfc2VxIHx8IGRvYy5sYXN0X3NlcSA8IGxhc3RTZXEpIHtcbiAgICAgICAgZG9jLmxhc3Rfc2VxID0gbGFzdFNlcTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTsgLy8gc29tZWJvZHkgZWxzZSBnb3QgaGVyZSBmaXJzdCwgZG9uJ3QgdXBkYXRlXG4gICAgfSwgY2FsbGJhY2spO1xuICB9XG4gIGlmIChvcHRzLmxhc3Rfc2VxKSB7XG4gICAgY29wdHMuc2luY2UgPSBvcHRzLmxhc3Rfc2VxO1xuICB9XG4gIGZ1bmN0aW9uIGFmdGVyQ29tcGFjdCgpIHtcbiAgICBzdGFydGVkLS07XG4gICAgaWYgKCFzdGFydGVkICYmIGRvbmUpIHtcbiAgICAgIGZpbmlzaCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkNoYW5nZShyb3cpIHtcbiAgICBzdGFydGVkKys7XG4gICAgc2VsZi5jb21wYWN0RG9jdW1lbnQocm93LmlkLCAwKS50aGVuKGFmdGVyQ29tcGFjdCwgY2FsbGJhY2spO1xuICB9XG4gIHNlbGYuY2hhbmdlcyhjb3B0cykub24oJ2NoYW5nZScsIG9uQ2hhbmdlKS5vbignY29tcGxldGUnLCBmdW5jdGlvbiAocmVzcCkge1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIGxhc3RTZXEgPSByZXNwLmxhc3Rfc2VxO1xuICAgIGlmICghc3RhcnRlZCkge1xuICAgICAgZmluaXNoKCk7XG4gICAgfVxuICB9KS5vbignZXJyb3InLCBjYWxsYmFjayk7XG59O1xuLyogQmVnaW4gYXBpIHdyYXBwZXJzLiBTcGVjaWZpYyBmdW5jdGlvbmFsaXR5IHRvIHN0b3JhZ2UgYmVsb25ncyBpbiB0aGUgXG4gICBfW21ldGhvZF0gKi9cbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUuZ2V0ID1cbiAgdXRpbHMuYWRhcHRlckZ1bignZ2V0JywgZnVuY3Rpb24gKGlkLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JTlZBTElEX0lEKTtcbiAgfVxuICBpZiAodXRpbHMuaXNMb2NhbElkKGlkKSAmJiB0eXBlb2YgdGhpcy5fZ2V0TG9jYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TG9jYWwoaWQsIGNhbGxiYWNrKTtcbiAgfVxuICB2YXIgbGVhdmVzID0gW10sIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiBmaW5pc2hPcGVuUmV2cygpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGNvdW50ID0gbGVhdmVzLmxlbmd0aDtcbiAgICBpZiAoIWNvdW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICB9XG4gICAgLy8gb3JkZXIgd2l0aCBvcGVuX3JldnMgaXMgdW5zcGVjaWZpZWRcbiAgICBsZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAobGVhZikge1xuICAgICAgc2VsZi5nZXQoaWQsXG4gICAgICAgICAgICAgICB7cmV2OiBsZWFmLCByZXZzOiBvcHRzLnJldnMsIGF0dGFjaG1lbnRzOiBvcHRzLmF0dGFjaG1lbnRzfSxcbiAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtvazogZG9jfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe21pc3Npbmc6IGxlYWZ9KTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudC0tO1xuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAob3B0cy5vcGVuX3JldnMpIHtcbiAgICBpZiAob3B0cy5vcGVuX3JldnMgPT09IFwiYWxsXCIpIHtcbiAgICAgIHRoaXMuX2dldFJldmlzaW9uVHJlZShpZCwgZnVuY3Rpb24gKGVyciwgcmV2X3RyZWUpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gc3VjaCBkb2N1bWVudCB3ZSBzaG91bGQgdHJlYXQgdGhpc1xuICAgICAgICAgIC8vIHNpdHVhdGlvbiB0aGUgc2FtZSB3YXkgYXMgaWYgcmV2aXNpb24gdHJlZSB3YXMgZW1wdHlcbiAgICAgICAgICByZXZfdHJlZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGxlYXZlcyA9IG1lcmdlLmNvbGxlY3RMZWF2ZXMocmV2X3RyZWUpLm1hcChmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgIHJldHVybiBsZWFmLnJldjtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmlzaE9wZW5SZXZzKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5vcGVuX3JldnMpKSB7XG4gICAgICAgIGxlYXZlcyA9IG9wdHMub3Blbl9yZXZzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsID0gbGVhdmVzW2ldO1xuICAgICAgICAgIC8vIGxvb2tzIGxpa2UgaXQncyB0aGUgb25seSB0aGluZyBjb3VjaGRiIGNoZWNrc1xuICAgICAgICAgIGlmICghKHR5cGVvZihsKSA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcZCstLy50ZXN0KGwpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5lcnJvcihlcnJvcnMuQkFEX1JFUVVFU1QsXG4gICAgICAgICAgICAgIFwiSW52YWxpZCByZXYgZm9ybWF0XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoT3BlblJldnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuZXJyb3IoZXJyb3JzLlVOS05PV05fRVJST1IsXG4gICAgICAgICAgJ2Z1bmN0aW9uX2NsYXVzZScpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuOyAvLyBvcGVuX3JldnMgZG9lcyBub3QgbGlrZSBvdGhlciBvcHRpb25zXG4gIH1cblxuICByZXR1cm4gdGhpcy5fZ2V0KGlkLCBvcHRzLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICBvcHRzID0gdXRpbHMuY2xvbmUob3B0cyk7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHJlc3VsdC5kb2M7XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIC8vIGEgc21va2UgdGVzdCBmb3Igc29tZXRoaW5nIGJlaW5nIHZlcnkgd3JvbmdcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ25vIGRvYyEnKSk7XG4gICAgfVxuICAgIHZhciBtZXRhZGF0YSA9IHJlc3VsdC5tZXRhZGF0YTtcbiAgICB2YXIgY3R4ID0gcmVzdWx0LmN0eDtcblxuICAgIGlmIChvcHRzLmNvbmZsaWN0cykge1xuICAgICAgdmFyIGNvbmZsaWN0cyA9IG1lcmdlLmNvbGxlY3RDb25mbGljdHMobWV0YWRhdGEpO1xuICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9jLl9jb25mbGljdHMgPSBjb25mbGljdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2cyB8fCBvcHRzLnJldnNfaW5mbykge1xuICAgICAgdmFyIHBhdGhzID0gbWVyZ2Uucm9vdFRvTGVhZihtZXRhZGF0YS5yZXZfdHJlZSk7XG4gICAgICB2YXIgcGF0aCA9IGFycmF5Rmlyc3QocGF0aHMsIGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyci5pZHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KVxuICAgICAgICAgIC5pbmRleE9mKGRvYy5fcmV2LnNwbGl0KCctJylbMV0pICE9PSAtMTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaW5kZXhPZlJldiA9IHBhdGguaWRzLm1hcChmdW5jdGlvbiAoeCkge3JldHVybiB4LmlkOyB9KVxuICAgICAgICAuaW5kZXhPZihkb2MuX3Jldi5zcGxpdCgnLScpWzFdKSArIDE7XG4gICAgICB2YXIgaG93TWFueSA9IHBhdGguaWRzLmxlbmd0aCAtIGluZGV4T2ZSZXY7XG4gICAgICBwYXRoLmlkcy5zcGxpY2UoaW5kZXhPZlJldiwgaG93TWFueSk7XG4gICAgICBwYXRoLmlkcy5yZXZlcnNlKCk7XG5cbiAgICAgIGlmIChvcHRzLnJldnMpIHtcbiAgICAgICAgZG9jLl9yZXZpc2lvbnMgPSB7XG4gICAgICAgICAgc3RhcnQ6IChwYXRoLnBvcyArIHBhdGguaWRzLmxlbmd0aCkgLSAxLFxuICAgICAgICAgIGlkczogcGF0aC5pZHMubWFwKGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgICAgICAgIHJldHVybiByZXYuaWQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnJldnNfaW5mbykge1xuICAgICAgICB2YXIgcG9zID0gIHBhdGgucG9zICsgcGF0aC5pZHMubGVuZ3RoO1xuICAgICAgICBkb2MuX3JldnNfaW5mbyA9IHBhdGguaWRzLm1hcChmdW5jdGlvbiAocmV2KSB7XG4gICAgICAgICAgcG9zLS07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJldjogcG9zICsgJy0nICsgcmV2LmlkLFxuICAgICAgICAgICAgc3RhdHVzOiByZXYub3B0cy5zdGF0dXNcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbF9zZXEpIHtcbiAgICAgIGRvYy5fbG9jYWxfc2VxID0gcmVzdWx0Lm1ldGFkYXRhLnNlcTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5hdHRhY2htZW50cyAmJiBkb2MuX2F0dGFjaG1lbnRzKSB7XG4gICAgICB2YXIgYXR0YWNobWVudHMgPSBkb2MuX2F0dGFjaG1lbnRzO1xuICAgICAgdmFyIGNvdW50ID0gT2JqZWN0LmtleXMoYXR0YWNobWVudHMpLmxlbmd0aDtcbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZG9jKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKGF0dGFjaG1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5fZ2V0QXR0YWNobWVudChhdHRhY2htZW50c1trZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtlbmNvZGU6IHRydWUsIGN0eDogY3R4fSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgIHZhciBhdHQgPSBkb2MuX2F0dGFjaG1lbnRzW2tleV07XG4gICAgICAgICAgYXR0LmRhdGEgPSBkYXRhO1xuICAgICAgICAgIGRlbGV0ZSBhdHQuc3R1YjtcbiAgICAgICAgICBkZWxldGUgYXR0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIS0tY291bnQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIHNlbGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9jLl9hdHRhY2htZW50cykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZG9jLl9hdHRhY2htZW50cykge1xuICAgICAgICAgIGlmIChkb2MuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGRvYy5fYXR0YWNobWVudHNba2V5XS5zdHViID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5BYnN0cmFjdFBvdWNoREIucHJvdG90eXBlLmdldEF0dGFjaG1lbnQgPVxuICB1dGlscy5hZGFwdGVyRnVuKCdnZXRBdHRhY2htZW50JywgZnVuY3Rpb24gKGRvY0lkLCBhdHRhY2htZW50SWQsIG9wdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAob3B0cyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICBvcHRzID0gdXRpbHMuY2xvbmUob3B0cyk7XG4gIHRoaXMuX2dldChkb2NJZCwgb3B0cywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGlmIChyZXMuZG9jLl9hdHRhY2htZW50cyAmJiByZXMuZG9jLl9hdHRhY2htZW50c1thdHRhY2htZW50SWRdKSB7XG4gICAgICBvcHRzLmN0eCA9IHJlcy5jdHg7XG4gICAgICBzZWxmLl9nZXRBdHRhY2htZW50KHJlcy5kb2MuX2F0dGFjaG1lbnRzW2F0dGFjaG1lbnRJZF0sIG9wdHMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5NSVNTSU5HX0RPQyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5BYnN0cmFjdFBvdWNoREIucHJvdG90eXBlLmFsbERvY3MgPVxuICB1dGlscy5hZGFwdGVyRnVuKCdhbGxEb2NzJywgZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICBvcHRzLnNraXAgPSB0eXBlb2Ygb3B0cy5za2lwICE9PSAndW5kZWZpbmVkJyA/IG9wdHMuc2tpcCA6IDA7XG4gIGlmICgna2V5cycgaW4gb3B0cykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRzLmtleXMpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IFR5cGVFcnJvcignb3B0aW9ucy5rZXlzIG11c3QgYmUgYW4gYXJyYXknKSk7XG4gICAgfVxuICAgIHZhciBpbmNvbXBhdGlibGVPcHQgPVxuICAgICAgWydzdGFydGtleScsICdlbmRrZXknLCAna2V5J10uZmlsdGVyKGZ1bmN0aW9uIChpbmNvbXBhdGlibGVPcHQpIHtcbiAgICAgIHJldHVybiBpbmNvbXBhdGlibGVPcHQgaW4gb3B0cztcbiAgICB9KVswXTtcbiAgICBpZiAoaW5jb21wYXRpYmxlT3B0KSB7XG4gICAgICBjYWxsYmFjayhlcnJvcnMuZXJyb3IoZXJyb3JzLlFVRVJZX1BBUlNFX0VSUk9SLFxuICAgICAgICAnUXVlcnkgcGFyYW1ldGVyIGAnICsgaW5jb21wYXRpYmxlT3B0ICtcbiAgICAgICAgJ2AgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBtdWx0aS1nZXQnXG4gICAgICApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSgpICE9PSAnaHR0cCcpIHtcbiAgICAgIHJldHVybiBhbGxEb2NzS2V5c1F1ZXJ5KHRoaXMsIG9wdHMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5fYWxsRG9jcyhvcHRzLCBjYWxsYmFjayk7XG59KTtcblxuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5jaGFuZ2VzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIG5ldyBDaGFuZ2VzKHRoaXMsIG9wdHMsIGNhbGxiYWNrKTtcbn07XG5cbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUuY2xvc2UgPVxuICB1dGlscy5hZGFwdGVyRnVuKCdjbG9zZScsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcy5fY2xvc2UoY2FsbGJhY2spO1xufSk7XG5cbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUuaW5mbyA9IHV0aWxzLmFkYXB0ZXJGdW4oJ2luZm8nLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9pbmZvKGZ1bmN0aW9uIChlcnIsIGluZm8pIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgLy8gYXNzdW1lIHdlIGtub3cgYmV0dGVyIHRoYW4gdGhlIGFkYXB0ZXIsIHVubGVzcyBpdCBpbmZvcm1zIHVzXG4gICAgaW5mby5kYl9uYW1lID0gaW5mby5kYl9uYW1lIHx8IHNlbGYuX2RiX25hbWU7XG4gICAgaW5mby5hdXRvX2NvbXBhY3Rpb24gPSAhIShzZWxmLl9hdXRvX2NvbXBhY3Rpb24gJiYgc2VsZi50eXBlKCkgIT09ICdodHRwJyk7XG4gICAgY2FsbGJhY2sobnVsbCwgaW5mbyk7XG4gIH0pO1xufSk7XG5cbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUuaWQgPSB1dGlscy5hZGFwdGVyRnVuKCdpZCcsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5faWQoY2FsbGJhY2spO1xufSk7XG5cbkFic3RyYWN0UG91Y2hEQi5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0eXBlb2YgdGhpcy5fdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl90eXBlKCkgOiB0aGlzLmFkYXB0ZXI7XG59O1xuXG5BYnN0cmFjdFBvdWNoREIucHJvdG90eXBlLmJ1bGtEb2NzID1cbiAgdXRpbHMuYWRhcHRlckZ1bignYnVsa0RvY3MnLCBmdW5jdGlvbiAocmVxLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHJlcSkpIHtcbiAgICByZXEgPSB7XG4gICAgICBkb2NzOiByZXFcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFyZXEgfHwgIXJlcS5kb2NzIHx8ICFBcnJheS5pc0FycmF5KHJlcS5kb2NzKSkge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuTUlTU0lOR19CVUxLX0RPQ1MpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXEuZG9jcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgcmVxLmRvY3NbaV0gIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkocmVxLmRvY3NbaV0pKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLk5PVF9BTl9PQkpFQ1QpO1xuICAgIH1cbiAgfVxuXG4gIHJlcSA9IHV0aWxzLmNsb25lKHJlcSk7XG4gIGlmICghKCduZXdfZWRpdHMnIGluIG9wdHMpKSB7XG4gICAgaWYgKCduZXdfZWRpdHMnIGluIHJlcSkge1xuICAgICAgb3B0cy5uZXdfZWRpdHMgPSByZXEubmV3X2VkaXRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLm5ld19lZGl0cyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRzLm5ld19lZGl0cyAmJiB0aGlzLnR5cGUoKSAhPT0gJ2h0dHAnKSB7XG4gICAgLy8gZW5zdXJlIHJldmlzaW9ucyBvZiB0aGUgc2FtZSBkb2MgYXJlIHNvcnRlZCwgc28gdGhhdFxuICAgIC8vIHRoZSBsb2NhbCBhZGFwdGVyIHByb2Nlc3NlcyB0aGVtIGNvcnJlY3RseSAoIzI5MzUpXG4gICAgcmVxLmRvY3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGlkQ29tcGFyZSA9IHV0aWxzLmNvbXBhcmUoYS5faWQsIGIuX2lkKTtcbiAgICAgIGlmIChpZENvbXBhcmUgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGlkQ29tcGFyZTtcbiAgICAgIH1cbiAgICAgIHZhciBhU3RhcnQgPSBhLl9yZXZpc2lvbnMgPyBhLl9yZXZpc2lvbnMuc3RhcnQgOiAwO1xuICAgICAgdmFyIGJTdGFydCA9IGIuX3JldmlzaW9ucyA/IGIuX3JldmlzaW9ucy5zdGFydCA6IDA7XG4gICAgICByZXR1cm4gdXRpbHMuY29tcGFyZShhU3RhcnQsIGJTdGFydCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fYnVsa0RvY3MocmVxLCBvcHRzLCB0aGlzLmF1dG9Db21wYWN0KGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBpZiAoIW9wdHMubmV3X2VkaXRzKSB7XG4gICAgICAvLyB0aGlzIGlzIHdoYXQgY291Y2ggZG9lcyB3aGVuIG5ld19lZGl0cyBpcyBmYWxzZVxuICAgICAgcmVzID0gcmVzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5lcnJvcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICB9KSk7XG59KTtcblxuQWJzdHJhY3RQb3VjaERCLnByb3RvdHlwZS5yZWdpc3RlckRlcGVuZGVudERhdGFiYXNlID1cbiAgdXRpbHMuYWRhcHRlckZ1bigncmVnaXN0ZXJEZXBlbmRlbnREYXRhYmFzZScsIGZ1bmN0aW9uIChkZXBlbmRlbnREYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaykge1xuICB2YXIgb3B0cyA9IHt9O1xuICBpZiAodGhpcy5fX29wdHMuZGIpIHtcbiAgICBvcHRzLmRiID0gdGhpcy5fX29wdHMuZGI7XG4gIH1cbiAgaWYgKHRoaXMuX2FkYXB0ZXIpIHtcbiAgICBvcHRzLmFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICB9XG5cbiAgdmFyIGRlcERCID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZGVwZW5kZW50RGIsIG9wdHMpO1xuXG4gIGZ1bmN0aW9uIGRpZmZGdW4oZG9jKSB7XG4gICAgZG9jLmRlcGVuZGVudERicyA9IGRvYy5kZXBlbmRlbnREYnMgfHwge307XG4gICAgaWYgKGRvYy5kZXBlbmRlbnREYnNbZGVwZW5kZW50RGJdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIG5vIHVwZGF0ZSByZXF1aXJlZFxuICAgIH1cbiAgICBkb2MuZGVwZW5kZW50RGJzW2RlcGVuZGVudERiXSA9IHRydWU7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICB1cHNlcnQodGhpcywgJ19sb2NhbC9fcG91Y2hfZGVwZW5kZW50RGJzJywgZGlmZkZ1biwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge2RiOiBkZXBEQn0pO1xuICB9KTtcbn0pO1xuXG59LHtcIi4vY2hhbmdlc1wiOjYsXCIuL2RlcHMvZXJyb3JzXCI6MTIsXCIuL2RlcHMvdXBzZXJ0XCI6MTYsXCIuL21lcmdlXCI6MjEsXCIuL3V0aWxzXCI6MjYsXCJldmVudHNcIjozMH1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ0hBTkdFU19CQVRDSF9TSVpFID0gMjU7XG5cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzJyk7XG52YXIgZXJyb3JzID0gX2RlcmVxXygnLi4vZGVwcy9lcnJvcnMnKTtcblxuZnVuY3Rpb24gZW5jb2RlRG9jSWQoaWQpIHtcbiAgaWYgKC9eXyhkZXNpZ258bG9jYWwpLy50ZXN0KGlkKSkge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc0F0dGFjaG1lbnRzKGRvYykge1xuICBpZiAoIWRvYy5fYXR0YWNobWVudHMgfHwgIU9iamVjdC5rZXlzKGRvYy5fYXR0YWNobWVudHMpKSB7XG4gICAgcmV0dXJuIHV0aWxzLlByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLlByb21pc2UuYWxsKE9iamVjdC5rZXlzKGRvYy5fYXR0YWNobWVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGF0dGFjaG1lbnQgPSBkb2MuX2F0dGFjaG1lbnRzW2tleV07XG4gICAgaWYgKGF0dGFjaG1lbnQuZGF0YSAmJiB0eXBlb2YgYXR0YWNobWVudC5kYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSB1bmRlZmluZWQgfHwgcHJvY2Vzcy5icm93c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgdXRpbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHV0aWxzLnJlYWRBc0JpbmFyeVN0cmluZyhhdHRhY2htZW50LmRhdGEsIGZ1bmN0aW9uIChiaW5hcnkpIHtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQuZGF0YSA9IHV0aWxzLmJ0b2EoYmluYXJ5KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRhY2htZW50LmRhdGEgPSBhdHRhY2htZW50LmRhdGEudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xufVxuXG4vLyBHZXQgYWxsIHRoZSBpbmZvcm1hdGlvbiB5b3UgcG9zc2libHkgY2FuIGFib3V0IHRoZSBVUkkgZ2l2ZW4gYnkgbmFtZSBhbmRcbi8vIHJldHVybiBpdCBhcyBhIHN1aXRhYmxlIG9iamVjdC5cbmZ1bmN0aW9uIGdldEhvc3QobmFtZSwgb3B0cykge1xuICAvLyBJZiB0aGUgZ2l2ZW4gbmFtZSBjb250YWlucyBcImh0dHA6XCJcbiAgaWYgKC9odHRwKHM/KTovLnRlc3QobmFtZSkpIHtcbiAgICAvLyBQcmFzZSB0aGUgVVJJIGludG8gYWxsIGl0cyBsaXR0bGUgYml0c1xuICAgIHZhciB1cmkgPSB1dGlscy5wYXJzZVVyaShuYW1lKTtcblxuICAgIC8vIFN0b3JlIHRoZSBmYWN0IHRoYXQgaXQgaXMgYSByZW1vdGUgVVJJXG4gICAgdXJpLnJlbW90ZSA9IHRydWU7XG5cbiAgICAvLyBTdG9yZSB0aGUgdXNlciBhbmQgcGFzc3dvcmQgYXMgYSBzZXBhcmF0ZSBhdXRoIG9iamVjdFxuICAgIGlmICh1cmkudXNlciB8fCB1cmkucGFzc3dvcmQpIHtcbiAgICAgIHVyaS5hdXRoID0ge3VzZXJuYW1lOiB1cmkudXNlciwgcGFzc3dvcmQ6IHVyaS5wYXNzd29yZH07XG4gICAgfVxuXG4gICAgLy8gU3BsaXQgdGhlIHBhdGggcGFydCBvZiB0aGUgVVJJIGludG8gcGFydHMgdXNpbmcgJy8nIGFzIHRoZSBkZWxpbWl0ZXJcbiAgICAvLyBhZnRlciByZW1vdmluZyBhbnkgbGVhZGluZyAnLycgYW5kIGFueSB0cmFpbGluZyAnLydcbiAgICB2YXIgcGFydHMgPSB1cmkucGF0aC5yZXBsYWNlKC8oXlxcL3xcXC8kKS9nLCAnJykuc3BsaXQoJy8nKTtcblxuICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBwYXJ0IGFzIHRoZSBkYXRhYmFzZSBuYW1lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcGFydHNcbiAgICAvLyBhcnJheVxuICAgIHVyaS5kYiA9IHBhcnRzLnBvcCgpO1xuXG4gICAgLy8gUmVzdG9yZSB0aGUgcGF0aCBieSBqb2luaW5nIGFsbCB0aGUgcmVtYWluaW5nIHBhcnRzIChhbGwgdGhlIHBhcnRzXG4gICAgLy8gZXhjZXB0IGZvciB0aGUgZGF0YWJhc2UgbmFtZSkgd2l0aCAnLydzXG4gICAgdXJpLnBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIHVyaS5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuXG4gICAgaWYgKG9wdHMuYXV0aCB8fCB1cmkuYXV0aCkge1xuICAgICAgdmFyIG5BdXRoID0gb3B0cy5hdXRoIHx8IHVyaS5hdXRoO1xuICAgICAgdmFyIHRva2VuID0gdXRpbHMuYnRvYShuQXV0aC51c2VybmFtZSArICc6JyArIG5BdXRoLnBhc3N3b3JkKTtcbiAgICAgIHVyaS5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIHRva2VuO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlYWRlcnMpIHtcbiAgICAgIHVyaS5oZWFkZXJzID0gb3B0cy5oZWFkZXJzO1xuICAgIH1cblxuICAgIHJldHVybiB1cmk7XG4gIH1cblxuICAvLyBJZiB0aGUgZ2l2ZW4gbmFtZSBkb2VzIG5vdCBjb250YWluICdodHRwOicgdGhlbiByZXR1cm4gYSB2ZXJ5IGJhc2ljIG9iamVjdFxuICAvLyB3aXRoIG5vIGhvc3QsIHRoZSBjdXJyZW50IHBhdGgsIHRoZSBnaXZlbiBuYW1lIGFzIHRoZSBkYXRhYmFzZSBuYW1lIGFuZCBub1xuICAvLyB1c2VybmFtZS9wYXNzd29yZFxuICByZXR1cm4ge2hvc3Q6ICcnLCBwYXRoOiAnLycsIGRiOiBuYW1lLCBhdXRoOiBmYWxzZX07XG59XG5cbi8vIEdlbmVyYXRlIGEgVVJMIHdpdGggdGhlIGhvc3QgZGF0YSBnaXZlbiBieSBvcHRzIGFuZCB0aGUgZ2l2ZW4gcGF0aFxuZnVuY3Rpb24gZ2VuREJVcmwob3B0cywgcGF0aCkge1xuICByZXR1cm4gZ2VuVXJsKG9wdHMsIG9wdHMuZGIgKyAnLycgKyBwYXRoKTtcbn1cblxuLy8gR2VuZXJhdGUgYSBVUkwgd2l0aCB0aGUgaG9zdCBkYXRhIGdpdmVuIGJ5IG9wdHMgYW5kIHRoZSBnaXZlbiBwYXRoXG5mdW5jdGlvbiBnZW5Vcmwob3B0cywgcGF0aCkge1xuICBpZiAob3B0cy5yZW1vdGUpIHtcbiAgICAvLyBJZiB0aGUgaG9zdCBhbHJlYWR5IGhhcyBhIHBhdGgsIHRoZW4gd2UgbmVlZCB0byBoYXZlIGEgcGF0aCBkZWxpbWl0ZXJcbiAgICAvLyBPdGhlcndpc2UsIHRoZSBwYXRoIGRlbGltaXRlciBpcyB0aGUgZW1wdHkgc3RyaW5nXG4gICAgdmFyIHBhdGhEZWwgPSAhb3B0cy5wYXRoID8gJycgOiAnLyc7XG5cbiAgICAvLyBJZiB0aGUgaG9zdCBhbHJlYWR5IGhhcyBhIHBhdGgsIHRoZW4gd2UgbmVlZCB0byBoYXZlIGEgcGF0aCBkZWxpbWl0ZXJcbiAgICAvLyBPdGhlcndpc2UsIHRoZSBwYXRoIGRlbGltaXRlciBpcyB0aGUgZW1wdHkgc3RyaW5nXG4gICAgcmV0dXJuIG9wdHMucHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdCArICc6JyArIG9wdHMucG9ydCArICcvJyArXG4gICAgICAgICAgIG9wdHMucGF0aCArIHBhdGhEZWwgKyBwYXRoO1xuICB9XG5cbiAgcmV0dXJuICcvJyArIHBhdGg7XG59XG4vLyBJbXBsZW1lbnRzIHRoZSBQb3VjaERCIEFQSSBmb3IgZGVhbGluZyB3aXRoIENvdWNoREIgaW5zdGFuY2VzIG92ZXIgSFRUUFxuZnVuY3Rpb24gSHR0cFBvdWNoKG9wdHMsIGNhbGxiYWNrKSB7XG4gIC8vIFRoZSBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIHB1YmxpY2x5IGF2YWlsYWJsZSBmb3IgSHR0cFBvdWNoXG4gIHZhciBhcGkgPSB0aGlzO1xuICBhcGkuZ2V0SG9zdCA9IG9wdHMuZ2V0SG9zdCA/IG9wdHMuZ2V0SG9zdCA6IGdldEhvc3Q7XG5cbiAgLy8gUGFyc2UgdGhlIFVSSSBnaXZlbiBieSBvcHRzLm5hbWUgaW50byBhbiBlYXN5LXRvLXVzZSBvYmplY3RcbiAgdmFyIGhvc3QgPSBhcGkuZ2V0SG9zdChvcHRzLm5hbWUsIG9wdHMpO1xuXG4gIC8vIEdlbmVyYXRlIHRoZSBkYXRhYmFzZSBVUkwgYmFzZWQgb24gdGhlIGhvc3RcbiAgdmFyIGRiVXJsID0gZ2VuREJVcmwoaG9zdCwgJycpO1xuXG4gIGFwaS5nZXRVcmwgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIGRiVXJsOyB9O1xuICBhcGkuZ2V0SGVhZGVycyA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdXRpbHMuY2xvbmUoaG9zdC5oZWFkZXJzKTsgfTtcblxuICB2YXIgYWpheE9wdHMgPSBvcHRzLmFqYXggfHwge307XG4gIG9wdHMgPSB1dGlscy5jbG9uZShvcHRzKTtcbiAgZnVuY3Rpb24gYWpheChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB1dGlscy5hamF4KHV0aWxzLmV4dGVuZCh7fSwgYWpheE9wdHMsIG9wdGlvbnMpLCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgQ291Y2hEQiBkYXRhYmFzZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3B0c1xuICB2YXIgY3JlYXRlREIgPSBmdW5jdGlvbiAoKSB7XG4gICAgYWpheCh7aGVhZGVyczogaG9zdC5oZWFkZXJzLCBtZXRob2Q6ICdQVVQnLCB1cmw6IGRiVXJsfSxcbiAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJldCkge1xuICAgICAgLy8gSWYgd2UgZ2V0IGFuIFwiVW5hdXRob3JpemVkXCIgZXJyb3JcbiAgICAgIGlmIChlcnIgJiYgZXJyLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIC8vIFRlc3QgaWYgdGhlIGRhdGFiYXNlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGFqYXgoe2hlYWRlcnM6IGhvc3QuaGVhZGVycywgbWV0aG9kOiAnSEVBRCcsIHVybDogZGJVcmx9LFxuICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJldCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHN0aWxsIGFuIGVycm9yXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy8gR2l2ZSB0aGUgZXJyb3IgdG8gdGhlIGNhbGxiYWNrIHRvIGRlYWwgd2l0aFxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udGludWUgYXMgaWYgdGhlcmUgaGFkIGJlZW4gbm8gZXJyb3JzXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBhcGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIHdlcmUgbm8gZXJycm9zIG9yIGlmIHRoZSBvbmx5IGVycm9yIGlzIFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiXG4gICAgICAgIC8vIChub3RlOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIiBvY2N1cnMgd2hlbiB3ZSB0cnkgdG8gY3JlYXRlIGEgZGF0YWJhc2VcbiAgICAgICAgLy8gdGhhdCBhbHJlYWR5IGV4aXN0cylcbiAgICAgIH0gZWxzZSBpZiAoIWVyciB8fCBlcnIuc3RhdHVzID09PSA0MTIpIHtcbiAgICAgICAgLy8gQ29udGludWUgYXMgaWYgdGhlcmUgaGFkIGJlZW4gbm8gZXJyb3JzXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGFwaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBpZiAoIW9wdHMuc2tpcFNldHVwKSB7XG4gICAgYWpheCh7aGVhZGVyczogaG9zdC5oZWFkZXJzLCBtZXRob2Q6ICdHRVQnLCB1cmw6IGRiVXJsfSxcbiAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJldCkge1xuICAgICAgLy9jaGVjayBpZiB0aGUgZGIgZXhpc3RzXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICB1dGlscy5leHBsYWluNDA0KFxuICAgICAgICAgICAgJ1BvdWNoREIgaXMganVzdCBkZXRlY3RpbmcgaWYgdGhlIHJlbW90ZSBEQiBleGlzdHMuJyk7XG4gICAgICAgICAgLy9pZiBpdCBkb2Vzbid0LCBjcmVhdGUgaXRcbiAgICAgICAgICBjcmVhdGVEQigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZ28gZG8gc3R1ZmYgd2l0aCB0aGUgZGJcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYXBpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwaS50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnaHR0cCc7XG4gIH07XG5cbiAgYXBpLmlkID0gdXRpbHMuYWRhcHRlckZ1bignaWQnLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBhamF4KHtcbiAgICAgIGhlYWRlcnM6IGhvc3QuaGVhZGVycyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6IGdlblVybChob3N0LCAnJylcbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgIHZhciB1dWlkID0gKHJlc3VsdCAmJiByZXN1bHQudXVpZCkgP1xuICAgICAgICByZXN1bHQudXVpZCArIGhvc3QuZGIgOiBnZW5EQlVybChob3N0LCAnJyk7XG4gICAgICBjYWxsYmFjayhudWxsLCB1dWlkKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgYXBpLnJlcXVlc3QgPSB1dGlscy5hZGFwdGVyRnVuKCdyZXF1ZXN0JywgZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gaG9zdC5oZWFkZXJzO1xuICAgIG9wdGlvbnMudXJsID0gZ2VuREJVcmwoaG9zdCwgb3B0aW9ucy51cmwpO1xuICAgIGFqYXgob3B0aW9ucywgY2FsbGJhY2spO1xuICB9KTtcblxuICAvLyBTZW5kcyBhIFBPU1QgcmVxdWVzdCB0byB0aGUgaG9zdCBjYWxsaW5nIHRoZSBjb3VjaGRiIF9jb21wYWN0IGZ1bmN0aW9uXG4gIC8vICAgIHZlcnNpb246IFRoZSB2ZXJzaW9uIG9mIENvdWNoREIgaXQgaXMgcnVubmluZ1xuICBhcGkuY29tcGFjdCA9IHV0aWxzLmFkYXB0ZXJGdW4oJ2NvbXBhY3QnLCBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIGFqYXgoe1xuICAgICAgaGVhZGVyczogaG9zdC5oZWFkZXJzLFxuICAgICAgdXJsOiBnZW5EQlVybChob3N0LCAnX2NvbXBhY3QnKSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gcGluZygpIHtcbiAgICAgICAgYXBpLmluZm8oZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgaWYgKCFyZXMuY29tcGFjdF9ydW5uaW5nKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBpbmcsIG9wdHMuaW50ZXJ2YWwgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gUGluZyB0aGUgaHR0cCBpZiBpdCdzIGZpbmlzaGVkIGNvbXBhY3Rpb25cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwaW5nKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENhbGxzIEdFVCBvbiB0aGUgaG9zdCwgd2hpY2ggZ2V0cyBiYWNrIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZ1xuICAvLyAgICBjb3VjaGRiOiBBIHdlbGNvbWUgc3RyaW5nXG4gIC8vICAgIHZlcnNpb246IFRoZSB2ZXJzaW9uIG9mIENvdWNoREIgaXQgaXMgcnVubmluZ1xuICBhcGkuX2luZm8gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBhamF4KHtcbiAgICAgIGhlYWRlcnM6IGhvc3QuaGVhZGVycyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6IGdlbkRCVXJsKGhvc3QsICcnKVxuICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLmhvc3QgPSBnZW5EQlVybChob3N0LCAnJyk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBpZCBmcm9tIHRoZSBkYXRhYmFzZSBnaXZlbiBieSBob3N0LlxuICAvLyBUaGUgaWQgY291bGQgYmUgc29sZWx5IHRoZSBfaWQgaW4gdGhlIGRhdGFiYXNlLCBvciBpdCBtYXkgYmUgYVxuICAvLyBfZGVzaWduL0lEIG9yIF9sb2NhbC9JRCBwYXRoXG4gIGFwaS5nZXQgPSB1dGlscy5hZGFwdGVyRnVuKCdnZXQnLCBmdW5jdGlvbiAoaWQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgLy8gSWYgbm8gb3B0aW9ucyB3ZXJlIGdpdmVuLCBzZXQgdGhlIGNhbGxiYWNrIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIG9wdHMgPSB1dGlscy5jbG9uZShvcHRzKTtcbiAgICBpZiAob3B0cy5hdXRvX2VuY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRzLmF1dG9fZW5jb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IG9mIHBhcmFtZXRlcnMgdG8gYWRkIHRvIHRoZSBHRVQgcmVxdWVzdFxuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIC8vIElmIGl0IGV4aXN0cywgYWRkIHRoZSBvcHRzLnJldnMgdmFsdWUgdG8gdGhlIGxpc3Qgb2YgcGFyYW1ldGVycy5cbiAgICAvLyBJZiByZXZzPXRydWUgdGhlbiB0aGUgcmVzdWx0aW5nIEpTT04gd2lsbCBpbmNsdWRlIGEgZmllbGRcbiAgICAvLyBfcmV2aXNpb25zIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgdGhlIHJldmlzaW9uIElEcy5cbiAgICBpZiAob3B0cy5yZXZzKSB7XG4gICAgICBwYXJhbXMucHVzaCgncmV2cz10cnVlJyk7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQgZXhpc3RzLCBhZGQgdGhlIG9wdHMucmV2c19pbmZvIHZhbHVlIHRvIHRoZSBsaXN0IG9mIHBhcmFtZXRlcnMuXG4gICAgLy8gSWYgcmV2c19pbmZvPXRydWUgdGhlbiB0aGUgcmVzdWx0aW5nIEpTT04gd2lsbCBpbmNsdWRlIHRoZSBmaWVsZFxuICAgIC8vIF9yZXZzX2luZm8gY29udGFpbmluZyBhbiBhcnJheSBvZiBvYmplY3RzIGluIHdoaWNoIGVhY2ggb2JqZWN0XG4gICAgLy8gcmVwcmVzZW50aW5nIGFuIGF2YWlsYWJsZSByZXZpc2lvbi5cbiAgICBpZiAob3B0cy5yZXZzX2luZm8pIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdyZXZzX2luZm89dHJ1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmxvY2FsX3NlcSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2xvY2FsX3NlcT10cnVlJyk7XG4gICAgfVxuICAgIC8vIElmIGl0IGV4aXN0cywgYWRkIHRoZSBvcHRzLm9wZW5fcmV2cyB2YWx1ZSB0byB0aGUgbGlzdCBvZiBwYXJhbWV0ZXJzLlxuICAgIC8vIElmIG9wZW5fcmV2cz1hbGwgdGhlbiB0aGUgcmVzdWx0aW5nIEpTT04gd2lsbCBpbmNsdWRlIGFsbCB0aGUgbGVhZlxuICAgIC8vIHJldmlzaW9ucy4gSWYgb3Blbl9yZXZzPVtcInJldjFcIiwgXCJyZXYyXCIsLi4uXSB0aGVuIHRoZSByZXN1bHRpbmcgSlNPTlxuICAgIC8vIHdpbGwgY29udGFpbiBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgZGF0YSBvZiBhbGwgcmV2aXNpb25zXG4gICAgaWYgKG9wdHMub3Blbl9yZXZzKSB7XG4gICAgICBpZiAob3B0cy5vcGVuX3JldnMgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgb3B0cy5vcGVuX3JldnMgPSBKU09OLnN0cmluZ2lmeShvcHRzLm9wZW5fcmV2cyk7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaCgnb3Blbl9yZXZzPScgKyBvcHRzLm9wZW5fcmV2cyk7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQgZXhpc3RzLCBhZGQgdGhlIG9wdHMuYXR0YWNobWVudHMgdmFsdWUgdG8gdGhlIGxpc3Qgb2YgcGFyYW1ldGVycy5cbiAgICAvLyBJZiBhdHRhY2htZW50cz10cnVlIHRoZSByZXN1bHRpbmcgSlNPTiB3aWxsIGluY2x1ZGUgdGhlIGJhc2U2NC1lbmNvZGVkXG4gICAgLy8gY29udGVudHMgaW4gdGhlIFwiZGF0YVwiIHByb3BlcnR5IG9mIGVhY2ggYXR0YWNobWVudC5cbiAgICBpZiAob3B0cy5hdHRhY2htZW50cykge1xuICAgICAgcGFyYW1zLnB1c2goJ2F0dGFjaG1lbnRzPXRydWUnKTtcbiAgICB9XG5cbiAgICAvLyBJZiBpdCBleGlzdHMsIGFkZCB0aGUgb3B0cy5yZXYgdmFsdWUgdG8gdGhlIGxpc3Qgb2YgcGFyYW1ldGVycy5cbiAgICAvLyBJZiByZXYgaXMgZ2l2ZW4gYSByZXZpc2lvbiBudW1iZXIgdGhlbiBnZXQgdGhlIHNwZWNpZmllZCByZXZpc2lvbi5cbiAgICBpZiAob3B0cy5yZXYpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdyZXY9JyArIG9wdHMucmV2KTtcbiAgICB9XG5cbiAgICAvLyBJZiBpdCBleGlzdHMsIGFkZCB0aGUgb3B0cy5jb25mbGljdHMgdmFsdWUgdG8gdGhlIGxpc3Qgb2YgcGFyYW1ldGVycy5cbiAgICAvLyBJZiBjb25mbGljdHM9dHJ1ZSB0aGVuIHRoZSByZXN1bHRpbmcgSlNPTiB3aWxsIGluY2x1ZGUgdGhlIGZpZWxkXG4gICAgLy8gX2NvbmZsaWN0cyBjb250YWluaW5nIGFsbCB0aGUgY29uZmxpY3RpbmcgcmV2aXNpb25zLlxuICAgIGlmIChvcHRzLmNvbmZsaWN0cykge1xuICAgICAgcGFyYW1zLnB1c2goJ2NvbmZsaWN0cz0nICsgb3B0cy5jb25mbGljdHMpO1xuICAgIH1cblxuICAgIC8vIEZvcm1hdCB0aGUgbGlzdCBvZiBwYXJhbWV0ZXJzIGludG8gYSB2YWxpZCBVUkkgcXVlcnkgc3RyaW5nXG4gICAgcGFyYW1zID0gcGFyYW1zLmpvaW4oJyYnKTtcbiAgICBwYXJhbXMgPSBwYXJhbXMgPT09ICcnID8gJycgOiAnPycgKyBwYXJhbXM7XG5cbiAgICBpZiAob3B0cy5hdXRvX2VuY29kZSkge1xuICAgICAgaWQgPSBlbmNvZGVEb2NJZChpZCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBvcHRpb25zIGZvciB0aGUgYWpheCBjYWxsXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBoZWFkZXJzOiBob3N0LmhlYWRlcnMsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiBnZW5EQlVybChob3N0LCBpZCArIHBhcmFtcylcbiAgICB9O1xuXG4gICAgLy8gSWYgdGhlIGdpdmVuIGlkIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSAnLycgYW5kIHRoZSBwYXJ0IGJlZm9yZSB0aGUgJy8nXG4gICAgLy8gaXMgTk9UIFwiX2Rlc2lnblwiIGFuZCBpcyBOT1QgXCJfbG9jYWxcIlxuICAgIC8vIE9SXG4gICAgLy8gSWYgdGhlIGdpdmVuIGlkIGNvbnRhaW5zIGF0IGxlYXN0IHR3byAnLycgYW5kIHRoZSBwYXJ0IGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyAnLycgaXMgXCJfZGVzaWduXCIuXG4gICAgLy8gVE9ETyBUaGlzIHNlY29uZCBjb25kaXRpb24gc2VlbXMgc3RyYW5nZSBzaW5jZSBpZiBwYXJ0c1swXSA9PT0gJ19kZXNpZ24nXG4gICAgLy8gdGhlbiB3ZSBhbHJlYWR5IGtub3cgdGhhdCBwYXJ0c1swXSAhPT0gJ19sb2NhbCcuXG4gICAgdmFyIHBhcnRzID0gaWQuc3BsaXQoJy8nKTtcbiAgICBpZiAoKHBhcnRzLmxlbmd0aCA+IDEgJiYgcGFydHNbMF0gIT09ICdfZGVzaWduJyAmJiBwYXJ0c1swXSAhPT0gJ19sb2NhbCcpIHx8XG4gICAgICAgIChwYXJ0cy5sZW5ndGggPiAyICYmIHBhcnRzWzBdID09PSAnX2Rlc2lnbicgJiYgcGFydHNbMF0gIT09ICdfbG9jYWwnKSkge1xuICAgICAgLy8gQmluYXJ5IGlzIGV4cGVjdGVkIGJhY2sgZnJvbSB0aGUgc2VydmVyXG4gICAgICBvcHRpb25zLmJpbmFyeSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBkb2N1bWVudFxuICAgIGFqYXgob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZG9jLCB4aHIpIHtcbiAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBleGlzdCwgc2VuZCBhbiBlcnJvciB0byB0aGUgY2FsbGJhY2tcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbmQgdGhlIGRvY3VtZW50IHRvIHRoZSBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sobnVsbCwgZG9jLCB4aHIpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBEZWxldGUgdGhlIGRvY3VtZW50IGdpdmVuIGJ5IGRvYyBmcm9tIHRoZSBkYXRhYmFzZSBnaXZlbiBieSBob3N0LlxuICBhcGkucmVtb3ZlID0gdXRpbHMuYWRhcHRlckZ1bigncmVtb3ZlJyxcbiAgICAgIGZ1bmN0aW9uIChkb2NPcklkLCBvcHRzT3JSZXYsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRvYztcbiAgICBpZiAodHlwZW9mIG9wdHNPclJldiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGlkLCByZXYsIG9wdHMsIGNhbGxiYWNrIHN0eWxlXG4gICAgICBkb2MgPSB7XG4gICAgICAgIF9pZDogZG9jT3JJZCxcbiAgICAgICAgX3Jldjogb3B0c09yUmV2XG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2MsIG9wdHMsIGNhbGxiYWNrIHN0eWxlXG4gICAgICBkb2MgPSBkb2NPcklkO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzT3JSZXYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRzT3JSZXY7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgICAgb3B0cyA9IG9wdHNPclJldjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV2ID0gKGRvYy5fcmV2IHx8IG9wdHMucmV2KTtcblxuICAgIC8vIERlbGV0ZSB0aGUgZG9jdW1lbnRcbiAgICBhamF4KHtcbiAgICAgIGhlYWRlcnM6IGhvc3QuaGVhZGVycyxcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICB1cmw6IGdlbkRCVXJsKGhvc3QsIGVuY29kZURvY0lkKGRvYy5faWQpKSArICc/cmV2PScgKyByZXZcbiAgICB9LCBjYWxsYmFjayk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuY29kZUF0dGFjaG1lbnRJZChhdHRhY2htZW50SWQpIHtcbiAgICByZXR1cm4gYXR0YWNobWVudElkLnNwbGl0KFwiL1wiKS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiL1wiKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgYXR0YWNobWVudFxuICBhcGkuZ2V0QXR0YWNobWVudCA9XG4gICAgdXRpbHMuYWRhcHRlckZ1bignZ2V0QXR0YWNobWVudCcsIGZ1bmN0aW9uIChkb2NJZCwgYXR0YWNobWVudElkLCBvcHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIGlmIChvcHRzLmF1dG9fZW5jb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdHMuYXV0b19lbmNvZGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5hdXRvX2VuY29kZSkge1xuICAgICAgZG9jSWQgPSBlbmNvZGVEb2NJZChkb2NJZCk7XG4gICAgfVxuICAgIG9wdHMuYXV0b19lbmNvZGUgPSBmYWxzZTtcbiAgICBhcGkuZ2V0KGRvY0lkICsgJy8nICsgZW5jb2RlQXR0YWNobWVudElkKGF0dGFjaG1lbnRJZCksIG9wdHMsIGNhbGxiYWNrKTtcbiAgfSk7XG5cbiAgLy8gUmVtb3ZlIHRoZSBhdHRhY2htZW50IGdpdmVuIGJ5IHRoZSBpZCBhbmQgcmV2XG4gIGFwaS5yZW1vdmVBdHRhY2htZW50ID1cbiAgICB1dGlscy5hZGFwdGVyRnVuKCdyZW1vdmVBdHRhY2htZW50JywgZnVuY3Rpb24gKGRvY0lkLCBhdHRhY2htZW50SWQsIHJldixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgdXJsID0gZ2VuREJVcmwoaG9zdCwgZW5jb2RlRG9jSWQoZG9jSWQpICsgJy8nICtcbiAgICAgIGVuY29kZUF0dGFjaG1lbnRJZChhdHRhY2htZW50SWQpKSArICc/cmV2PScgKyByZXY7XG5cbiAgICBhamF4KHtcbiAgICAgIGhlYWRlcnM6IGhvc3QuaGVhZGVycyxcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICB1cmw6IHVybFxuICAgIH0sIGNhbGxiYWNrKTtcbiAgfSk7XG5cbiAgLy8gQWRkIHRoZSBhdHRhY2htZW50IGdpdmVuIGJ5IGJsb2IgYW5kIGl0cyBjb250ZW50VHlwZSBwcm9wZXJ0eVxuICAvLyB0byB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gaWQsIHRoZSByZXZpc2lvbiBnaXZlbiBieSByZXYsIGFuZFxuICAvLyBhZGQgaXQgdG8gdGhlIGRhdGFiYXNlIGdpdmVuIGJ5IGhvc3QuXG4gIGFwaS5wdXRBdHRhY2htZW50ID1cbiAgICB1dGlscy5hZGFwdGVyRnVuKCdwdXRBdHRhY2htZW50JywgZnVuY3Rpb24gKGRvY0lkLCBhdHRhY2htZW50SWQsIHJldiwgYmxvYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHR5cGU7XG4gICAgICB0eXBlID0gYmxvYjtcbiAgICAgIGJsb2IgPSByZXY7XG4gICAgICByZXYgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0eXBlID0gYmxvYjtcbiAgICAgIGJsb2IgPSByZXY7XG4gICAgICByZXYgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgaWQgPSBlbmNvZGVEb2NJZChkb2NJZCkgKyAnLycgKyBlbmNvZGVBdHRhY2htZW50SWQoYXR0YWNobWVudElkKTtcbiAgICB2YXIgdXJsID0gZ2VuREJVcmwoaG9zdCwgaWQpO1xuICAgIGlmIChyZXYpIHtcbiAgICAgIHVybCArPSAnP3Jldj0nICsgcmV2O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJsb2IgPSB1dGlscy5hdG9iKGJsb2IpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGl0J3Mgbm90IGJhc2U2NC1lbmNvZGVkLCBzbyB0aHJvdyBlcnJvclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodXRpbHMuZXh0ZW5kKHt9LCBlcnJvcnMuQkFEX0FSRyxcbiAgICAgICAgICB7cmVhc29uOiBcIkF0dGFjaG1lbnRzIG5lZWQgdG8gYmUgYmFzZTY0IGVuY29kZWRcIn0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGhlYWRlcnM6IHV0aWxzLmNsb25lKGhvc3QuaGVhZGVycyksXG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXG4gICAgICBib2R5OiBibG9iLFxuICAgICAgdGltZW91dDogNjAwMDBcbiAgICB9O1xuICAgIG9wdHMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB0eXBlO1xuICAgIC8vIEFkZCB0aGUgYXR0YWNobWVudFxuICAgIGFqYXgob3B0cywgY2FsbGJhY2spO1xuICB9KTtcblxuICAvLyBBZGQgdGhlIGRvY3VtZW50IGdpdmVuIGJ5IGRvYyAoaW4gSlNPTiBzdHJpbmcgZm9ybWF0KSB0byB0aGUgZGF0YWJhc2VcbiAgLy8gZ2l2ZW4gYnkgaG9zdC4gVGhpcyBmYWlscyBpZiB0aGUgZG9jIGhhcyBubyBfaWQgZmllbGQuXG4gIGFwaS5wdXQgPSB1dGlscy5hZGFwdGVyRnVuKCdwdXQnLCB1dGlscy5nZXRBcmd1bWVudHMoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgdGVtcCwgdGVtcHR5cGUsIG9wdHM7XG4gICAgdmFyIGRvYyA9IGFyZ3Muc2hpZnQoKTtcbiAgICB2YXIgaWQgPSAnX2lkJyBpbiBkb2M7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIGRvYyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShkb2MpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLk5PVF9BTl9PQkpFQ1QpO1xuICAgIH1cblxuICAgIGRvYyA9IHV0aWxzLmNsb25lKGRvYyk7XG5cbiAgICBwcmVwcm9jZXNzQXR0YWNobWVudHMoZG9jKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHRlbXAgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIHRlbXB0eXBlID0gdHlwZW9mIHRlbXA7XG4gICAgICAgIGlmICh0ZW1wdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhaWQpIHtcbiAgICAgICAgICBkb2MuX2lkID0gdGVtcDtcbiAgICAgICAgICBpZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGVtcHR5cGUgPT09IFwic3RyaW5nXCIgJiYgaWQgJiYgISgnX3JldicgaW4gZG9jKSkge1xuICAgICAgICAgIGRvYy5fcmV2ID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG9wdHMgPSB1dGlscy5jbG9uZSh0ZW1wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgdmFyIGVycm9yID0gdXRpbHMuaW52YWxpZElkRXJyb3IoZG9jLl9pZCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIExpc3Qgb2YgcGFyYW1ldGVyIHRvIGFkZCB0byB0aGUgUFVUIHJlcXVlc3RcbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgLy8gSWYgaXQgZXhpc3RzLCBhZGQgdGhlIG9wdHMubmV3X2VkaXRzIHZhbHVlIHRvIHRoZSBsaXN0IG9mIHBhcmFtZXRlcnMuXG4gICAgICAvLyBJZiBuZXdfZWRpdHMgPSBmYWxzZSB0aGVuIHRoZSBkYXRhYmFzZSB3aWxsIE5PVCBhc3NpZ24gdGhpcyBkb2N1bWVudCBhXG4gICAgICAvLyBuZXcgcmV2aXNpb24gbnVtYmVyXG4gICAgICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cy5uZXdfZWRpdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKCduZXdfZWRpdHM9JyArIG9wdHMubmV3X2VkaXRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9ybWF0IHRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgaW50byBhIHZhbGlkIFVSSSBxdWVyeSBzdHJpbmdcbiAgICAgIHBhcmFtcyA9IHBhcmFtcy5qb2luKCcmJyk7XG4gICAgICBpZiAocGFyYW1zICE9PSAnJykge1xuICAgICAgICBwYXJhbXMgPSAnPycgKyBwYXJhbXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgZG9jdW1lbnRcbiAgICAgIGFqYXgoe1xuICAgICAgICBoZWFkZXJzOiBob3N0LmhlYWRlcnMsXG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIHVybDogZ2VuREJVcmwoaG9zdCwgZW5jb2RlRG9jSWQoZG9jLl9pZCkpICsgcGFyYW1zLFxuICAgICAgICBib2R5OiBkb2NcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLm9rID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgIH0pO1xuICAgIH0pW1wiY2F0Y2hcIl0oY2FsbGJhY2spO1xuXG4gIH0pKTtcblxuICAvLyBBZGQgdGhlIGRvY3VtZW50IGdpdmVuIGJ5IGRvYyAoaW4gSlNPTiBzdHJpbmcgZm9ybWF0KSB0byB0aGUgZGF0YWJhc2VcbiAgLy8gZ2l2ZW4gYnkgaG9zdC4gVGhpcyBkb2VzIG5vdCBhc3N1bWUgdGhhdCBkb2MgaXMgYSBuZXcgZG9jdW1lbnQgXG4gIC8vIChpLmUuIGRvZXMgbm90IGhhdmUgYSBfaWQgb3IgYSBfcmV2IGZpZWxkLilcbiAgYXBpLnBvc3QgPSB1dGlscy5hZGFwdGVyRnVuKCdwb3N0JywgZnVuY3Rpb24gKGRvYywgb3B0cywgY2FsbGJhY2spIHtcbiAgICAvLyBJZiBubyBvcHRpb25zIHdlcmUgZ2l2ZW4sIHNldCB0aGUgY2FsbGJhY2sgdG8gYmUgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIGlmICh0eXBlb2YgZG9jICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5OT1RfQU5fT0JKRUNUKTtcbiAgICB9XG4gICAgaWYgKCEgKFwiX2lkXCIgaW4gZG9jKSkge1xuICAgICAgZG9jLl9pZCA9IHV0aWxzLnV1aWQoKTtcbiAgICB9XG4gICAgYXBpLnB1dChkb2MsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlcy5vayA9IHRydWU7XG4gICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBVcGRhdGUvY3JlYXRlIG11bHRpcGxlIGRvY3VtZW50cyBnaXZlbiBieSByZXEgaW4gdGhlIGRhdGFiYXNlXG4gIC8vIGdpdmVuIGJ5IGhvc3QuXG4gIGFwaS5fYnVsa0RvY3MgPSBmdW5jdGlvbiAocmVxLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIC8vIElmIG9wdHMubmV3X2VkaXRzIGV4aXN0cyBhZGQgaXQgdG8gdGhlIGRvY3VtZW50IGRhdGEgdG8gYmVcbiAgICAvLyBzZW5kIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAvLyBJZiBuZXdfZWRpdHM9ZmFsc2UgdGhlbiBpdCBwcmV2ZW50cyB0aGUgZGF0YWJhc2UgZnJvbSBjcmVhdGluZ1xuICAgIC8vIG5ldyByZXZpc2lvbiBudW1iZXJzIGZvciB0aGUgZG9jdW1lbnRzLiBJbnN0ZWFkIGl0IGp1c3QgdXNlc1xuICAgIC8vIHRoZSBvbGQgb25lcy4gVGhpcyBpcyB1c2VkIGluIGRhdGFiYXNlIHJlcGxpY2F0aW9uLlxuICAgIGlmICh0eXBlb2Ygb3B0cy5uZXdfZWRpdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXEubmV3X2VkaXRzID0gb3B0cy5uZXdfZWRpdHM7XG4gICAgfVxuXG4gICAgdXRpbHMuUHJvbWlzZS5hbGwocmVxLmRvY3MubWFwKHByZXByb2Nlc3NBdHRhY2htZW50cykpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVXBkYXRlL2NyZWF0ZSB0aGUgZG9jdW1lbnRzXG4gICAgICBhamF4KHtcbiAgICAgICAgaGVhZGVyczogaG9zdC5oZWFkZXJzLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgdXJsOiBnZW5EQlVybChob3N0LCAnX2J1bGtfZG9jcycpLFxuICAgICAgICBib2R5OiByZXFcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTsgLy8gc21vb3RocyBvdXQgY2xvdWRhbnQgbm90IGFkZGluZyB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH0pW1wiY2F0Y2hcIl0oY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIEdldCBhIGxpc3Rpbmcgb2YgdGhlIGRvY3VtZW50cyBpbiB0aGUgZGF0YWJhc2UgZ2l2ZW5cbiAgLy8gYnkgaG9zdCBhbmQgb3JkZXJlZCBieSBpbmNyZWFzaW5nIGlkLlxuICBhcGkuYWxsRG9jcyA9IHV0aWxzLmFkYXB0ZXJGdW4oJ2FsbERvY3MnLCBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIC8vIExpc3Qgb2YgcGFyYW1ldGVycyB0byBhZGQgdG8gdGhlIEdFVCByZXF1ZXN0XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIHZhciBib2R5O1xuICAgIHZhciBtZXRob2QgPSAnR0VUJztcblxuICAgIC8vIFRPRE8gSSBkb24ndCBzZWUgY29uZmxpY3RzIGFzIGEgdmFsaWQgcGFyYW1ldGVyIGZvciBhXG4gICAgLy8gX2FsbF9kb2NzIHJlcXVlc3QgXG4gICAgLy8gKHNlZSBodHRwOi8vd2lraS5hcGFjaGUub3JnL2NvdWNoZGIvSFRUUF9Eb2N1bWVudF9BUEkjYWxsX2RvY3MpXG4gICAgaWYgKG9wdHMuY29uZmxpY3RzKSB7XG4gICAgICBwYXJhbXMucHVzaCgnY29uZmxpY3RzPXRydWUnKTtcbiAgICB9XG5cbiAgICAvLyBJZiBvcHRzLmRlc2NlbmRpbmcgaXMgdHJ1dGh5IGFkZCBpdCB0byBwYXJhbXNcbiAgICBpZiAob3B0cy5kZXNjZW5kaW5nKSB7XG4gICAgICBwYXJhbXMucHVzaCgnZGVzY2VuZGluZz10cnVlJyk7XG4gICAgfVxuXG4gICAgLy8gSWYgb3B0cy5pbmNsdWRlX2RvY3MgZXhpc3RzLCBhZGQgdGhlIGluY2x1ZGVfZG9jcyB2YWx1ZSB0byB0aGVcbiAgICAvLyBsaXN0IG9mIHBhcmFtZXRlcnMuXG4gICAgLy8gSWYgaW5jbHVkZV9kb2NzPXRydWUgdGhlbiBpbmNsdWRlIHRoZSBhc3NvY2lhdGVkIGRvY3VtZW50IHdpdGggZWFjaFxuICAgIC8vIHJlc3VsdC5cbiAgICBpZiAob3B0cy5pbmNsdWRlX2RvY3MpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdpbmNsdWRlX2RvY3M9dHJ1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmtleSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2tleT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG9wdHMua2V5KSkpO1xuICAgIH1cblxuICAgIC8vIElmIG9wdHMuc3RhcnRrZXkgZXhpc3RzLCBhZGQgdGhlIHN0YXJ0a2V5IHZhbHVlIHRvIHRoZSBsaXN0IG9mXG4gICAgLy8gcGFyYW1ldGVycy5cbiAgICAvLyBJZiBzdGFydGtleSBpcyBnaXZlbiB0aGVuIHRoZSByZXR1cm5lZCBsaXN0IG9mIGRvY3VtZW50cyB3aWxsXG4gICAgLy8gc3RhcnQgd2l0aCB0aGUgZG9jdW1lbnQgd2hvc2UgaWQgaXMgc3RhcnRrZXkuXG4gICAgaWYgKG9wdHMuc3RhcnRrZXkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdzdGFydGtleT0nICtcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG9wdHMuc3RhcnRrZXkpKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgb3B0cy5lbmRrZXkgZXhpc3RzLCBhZGQgdGhlIGVuZGtleSB2YWx1ZSB0byB0aGUgbGlzdCBvZiBwYXJhbWV0ZXJzLlxuICAgIC8vIElmIGVuZGtleSBpcyBnaXZlbiB0aGVuIHRoZSByZXR1cm5lZCBsaXN0IG9mIGRvY3VlbW50cyB3aWxsXG4gICAgLy8gZW5kIHdpdGggdGhlIGRvY3VtZW50IHdob3NlIGlkIGlzIGVuZGtleS5cbiAgICBpZiAob3B0cy5lbmRrZXkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdlbmRrZXk9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvcHRzLmVuZGtleSkpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuaW5jbHVzaXZlX2VuZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdpbmNsdXNpdmVfZW5kPScgKyAhIW9wdHMuaW5jbHVzaXZlX2VuZCk7XG4gICAgfVxuXG4gICAgLy8gSWYgb3B0cy5saW1pdCBleGlzdHMsIGFkZCB0aGUgbGltaXQgdmFsdWUgdG8gdGhlIHBhcmFtZXRlciBsaXN0LlxuICAgIGlmICh0eXBlb2Ygb3B0cy5saW1pdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdsaW1pdD0nICsgb3B0cy5saW1pdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnNraXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJhbXMucHVzaCgnc2tpcD0nICsgb3B0cy5za2lwKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgdGhlIGxpc3Qgb2YgcGFyYW1ldGVycyBpbnRvIGEgdmFsaWQgVVJJIHF1ZXJ5IHN0cmluZ1xuICAgIHBhcmFtcyA9IHBhcmFtcy5qb2luKCcmJyk7XG4gICAgaWYgKHBhcmFtcyAhPT0gJycpIHtcbiAgICAgIHBhcmFtcyA9ICc/JyArIHBhcmFtcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMua2V5cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgdmFyIE1BWF9VUkxfTEVOR1RIID0gMjAwMDtcbiAgICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MTcxODQvNjgwNzQyLFxuICAgICAgLy8gdGhlIGRlIGZhY3RvciBVUkwgbGVuZ3RoIGxpbWl0IGlzIDIwMDAgY2hhcmFjdGVyc1xuXG4gICAgICB2YXIga2V5c0FzU3RyaW5nID1cbiAgICAgICAgJ2tleXM9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvcHRzLmtleXMpKTtcbiAgICAgIGlmIChrZXlzQXNTdHJpbmcubGVuZ3RoICsgcGFyYW1zLmxlbmd0aCArIDEgPD0gTUFYX1VSTF9MRU5HVEgpIHtcbiAgICAgICAgLy8gSWYgdGhlIGtleXMgYXJlIHNob3J0IGVub3VnaCwgZG8gYSBHRVQuIHdlIGRvIHRoaXMgdG8gd29yayBhcm91bmRcbiAgICAgICAgLy8gU2FmYXJpIG5vdCB1bmRlcnN0YW5kaW5nIDMwNHMgb24gUE9TVHMgKHNlZSBpc3N1ZSAjMTIzOSlcbiAgICAgICAgcGFyYW1zICs9IChwYXJhbXMuaW5kZXhPZignPycpICE9PSAtMSA/ICcmJyA6ICc/JykgKyBrZXlzQXNTdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBrZXlzIGFyZSB0b28gbG9uZywgaXNzdWUgYSBQT1NUIHJlcXVlc3QgdG8gY2lyY3VtdmVudCBHRVRcbiAgICAgICAgLy8gcXVlcnkgc3RyaW5nIGxpbWl0c1xuICAgICAgICAvLyBzZWUgaHR0cDovL3dpa2kuYXBhY2hlLm9yZy9jb3VjaGRiL0hUVFBfdmlld19BUEkjUXVlcnlpbmdfT3B0aW9uc1xuICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7a2V5czogb3B0cy5rZXlzfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBkb2N1bWVudCBsaXN0aW5nXG4gICAgYWpheCh7XG4gICAgICBoZWFkZXJzOiBob3N0LmhlYWRlcnMsXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogZ2VuREJVcmwoaG9zdCwgJ19hbGxfZG9jcycgKyBwYXJhbXMpLFxuICAgICAgYm9keTogYm9keVxuICAgIH0sIGNhbGxiYWNrKTtcbiAgfSk7XG5cbiAgLy8gR2V0IGEgbGlzdCBvZiBjaGFuZ2VzIG1hZGUgdG8gZG9jdW1lbnRzIGluIHRoZSBkYXRhYmFzZSBnaXZlbiBieSBob3N0LlxuICAvLyBUT0RPIEFjY29yZGluZyB0byB0aGUgUkVBRE1FLCB0aGVyZSBzaG91bGQgYmUgdHdvIG90aGVyIG1ldGhvZHMgaGVyZSxcbiAgLy8gYXBpLmNoYW5nZXMuYWRkTGlzdGVuZXIgYW5kIGFwaS5jaGFuZ2VzLnJlbW92ZUxpc3RlbmVyLlxuICBhcGkuX2NoYW5nZXMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIC8vIFdlIGludGVybmFsbHkgcGFnZSB0aGUgcmVzdWx0cyBvZiBhIGNoYW5nZXMgcmVxdWVzdCwgdGhpcyBtZWFuc1xuICAgIC8vIGlmIHRoZXJlIGlzIGEgbGFyZ2Ugc2V0IG9mIGNoYW5nZXMgdG8gYmUgcmV0dXJuZWQgd2UgY2FuIHN0YXJ0XG4gICAgLy8gcHJvY2Vzc2luZyB0aGVtIHF1aWNrZXIgaW5zdGVhZCBvZiB3YWl0aW5nIG9uIHRoZSBlbnRpcmVcbiAgICAvLyBzZXQgb2YgY2hhbmdlcyB0byByZXR1cm4gYW5kIGF0dGVtcHRpbmcgdG8gcHJvY2VzcyB0aGVtIGF0IG9uY2VcbiAgICB2YXIgYmF0Y2hTaXplID0gJ2JhdGNoX3NpemUnIGluIG9wdHMgPyBvcHRzLmJhdGNoX3NpemUgOiBDSEFOR0VTX0JBVENIX1NJWkU7XG5cbiAgICBvcHRzID0gdXRpbHMuY2xvbmUob3B0cyk7XG4gICAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IDMwICogMTAwMDtcblxuICAgIC8vIFdlIGdpdmUgYSA1IHNlY29uZCBidWZmZXIgZm9yIENvdWNoREIgY2hhbmdlcyB0byByZXNwb25kIHdpdGhcbiAgICAvLyBhbiBvayB0aW1lb3V0XG4gICAgdmFyIHBhcmFtcyA9IHsgdGltZW91dDogb3B0cy50aW1lb3V0IC0gKDUgKiAxMDAwKSB9O1xuICAgIHZhciBsaW1pdCA9ICh0eXBlb2Ygb3B0cy5saW1pdCAhPT0gJ3VuZGVmaW5lZCcpID8gb3B0cy5saW1pdCA6IGZhbHNlO1xuICAgIGlmIChsaW1pdCA9PT0gMCkge1xuICAgICAgbGltaXQgPSAxO1xuICAgIH1cbiAgICB2YXIgcmV0dXJuRG9jcztcbiAgICBpZiAoJ3JldHVybkRvY3MnIGluIG9wdHMpIHtcbiAgICAgIHJldHVybkRvY3MgPSBvcHRzLnJldHVybkRvY3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkRvY3MgPSB0cnVlO1xuICAgIH1cbiAgICAvL1xuICAgIHZhciBsZWZ0VG9GZXRjaCA9IGxpbWl0O1xuXG4gICAgaWYgKG9wdHMuc3R5bGUpIHtcbiAgICAgIHBhcmFtcy5zdHlsZSA9IG9wdHMuc3R5bGU7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaW5jbHVkZV9kb2NzIHx8IG9wdHMuZmlsdGVyICYmIHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyYW1zLmluY2x1ZGVfZG9jcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuY29udGludW91cykge1xuICAgICAgcGFyYW1zLmZlZWQgPSAnbG9uZ3BvbGwnO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmNvbmZsaWN0cykge1xuICAgICAgcGFyYW1zLmNvbmZsaWN0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZGVzY2VuZGluZykge1xuICAgICAgcGFyYW1zLmRlc2NlbmRpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmZpbHRlciAmJiB0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJhbXMuZmlsdGVyID0gb3B0cy5maWx0ZXI7XG4gICAgICBpZiAob3B0cy5maWx0ZXIgPT09ICdfdmlldycgJiZcbiAgICAgICAgICBvcHRzLnZpZXcgJiZcbiAgICAgICAgICB0eXBlb2Ygb3B0cy52aWV3ID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMudmlldyA9IG9wdHMudmlldztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBvcHRzLnF1ZXJ5X3BhcmFtcyBleGlzdHMsIHBhc3MgaXQgdGhyb3VnaCB0byB0aGUgY2hhbmdlcyByZXF1ZXN0LlxuICAgIC8vIFRoZXNlIHBhcmFtZXRlcnMgbWF5IGJlIHVzZWQgYnkgdGhlIGZpbHRlciBvbiB0aGUgc291cmNlIGRhdGFiYXNlLlxuICAgIGlmIChvcHRzLnF1ZXJ5X3BhcmFtcyAmJiB0eXBlb2Ygb3B0cy5xdWVyeV9wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBwYXJhbV9uYW1lIGluIG9wdHMucXVlcnlfcGFyYW1zKSB7XG4gICAgICAgIGlmIChvcHRzLnF1ZXJ5X3BhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbV9uYW1lKSkge1xuICAgICAgICAgIHBhcmFtc1twYXJhbV9uYW1lXSA9IG9wdHMucXVlcnlfcGFyYW1zW3BhcmFtX25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbnRpbnVvdXMgJiYgYXBpLl91c2VTU0UpIHtcbiAgICAgIHJldHVybiAgYXBpLnNzZShvcHRzLCBwYXJhbXMsIHJldHVybkRvY3MpO1xuICAgIH1cbiAgICB2YXIgeGhyO1xuICAgIHZhciBsYXN0RmV0Y2hlZFNlcTtcblxuICAgIC8vIEdldCBhbGwgdGhlIGNoYW5nZXMgc3RhcnRpbmcgd3RpaCB0aGUgb25lIGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgIC8vIHNlcXVlbmNlIG51bWJlciBnaXZlbiBieSBzaW5jZS5cbiAgICB2YXIgZmV0Y2ggPSBmdW5jdGlvbiAoc2luY2UsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAob3B0cy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcmFtcy5zaW5jZSA9IHNpbmNlO1xuICAgICAgaWYgKG9wdHMuZGVzY2VuZGluZykge1xuICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICBwYXJhbXMubGltaXQgPSBsZWZ0VG9GZXRjaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLmxpbWl0ID0gKCFsaW1pdCB8fCBsZWZ0VG9GZXRjaCA+IGJhdGNoU2l6ZSkgP1xuICAgICAgICAgIGJhdGNoU2l6ZSA6IGxlZnRUb0ZldGNoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW1TdHIgPSAnPycgKyBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayArICc9JyArIHBhcmFtc1trXTtcbiAgICAgIH0pLmpvaW4oJyYnKTtcblxuICAgICAgLy8gU2V0IHRoZSBvcHRpb25zIGZvciB0aGUgYWpheCBjYWxsXG4gICAgICB2YXIgeGhyT3B0cyA9IHtcbiAgICAgICAgaGVhZGVyczogaG9zdC5oZWFkZXJzLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6IGdlbkRCVXJsKGhvc3QsICdfY2hhbmdlcycgKyBwYXJhbVN0ciksXG4gICAgICAgIC8vIF9jaGFuZ2VzIGNhbiB0YWtlIGEgbG9uZyB0aW1lIHRvIGdlbmVyYXRlLCBlc3BlY2lhbGx5IHdoZW4gZmlsdGVyZWRcbiAgICAgICAgdGltZW91dDogb3B0cy50aW1lb3V0XG4gICAgICB9O1xuICAgICAgbGFzdEZldGNoZWRTZXEgPSBzaW5jZTtcblxuICAgICAgaWYgKG9wdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgY2hhbmdlc1xuICAgICAgeGhyID0gYWpheCh4aHJPcHRzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8vIElmIG9wdHMuc2luY2UgZXhpc3RzLCBnZXQgYWxsIHRoZSBjaGFuZ2VzIGZyb20gdGhlIHNlcXVlbmNlXG4gICAgLy8gbnVtYmVyIGdpdmVuIGJ5IG9wdHMuc2luY2UuIE90aGVyd2lzZSwgZ2V0IGFsbCB0aGUgY2hhbmdlc1xuICAgIC8vIGZyb20gdGhlIHNlcXVlbmNlIG51bWJlciAwLlxuICAgIHZhciBmZXRjaFRpbWVvdXQgPSAxMDtcbiAgICB2YXIgZmV0Y2hSZXRyeUNvdW50ID0gMDtcblxuICAgIHZhciByZXN1bHRzID0ge3Jlc3VsdHM6IFtdfTtcblxuICAgIHZhciBmZXRjaGVkID0gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICBpZiAob3B0cy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByYXdfcmVzdWx0c19sZW5ndGggPSAwO1xuICAgICAgLy8gSWYgdGhlIHJlc3VsdCBvZiB0aGUgYWpheCBjYWxsIChyZXMpIGNvbnRhaW5zIGNoYW5nZXMgKHJlcy5yZXN1bHRzKVxuICAgICAgaWYgKHJlcyAmJiByZXMucmVzdWx0cykge1xuICAgICAgICByYXdfcmVzdWx0c19sZW5ndGggPSByZXMucmVzdWx0cy5sZW5ndGg7XG4gICAgICAgIHJlc3VsdHMubGFzdF9zZXEgPSByZXMubGFzdF9zZXE7XG4gICAgICAgIC8vIEZvciBlYWNoIGNoYW5nZVxuICAgICAgICB2YXIgcmVxID0ge307XG4gICAgICAgIHJlcS5xdWVyeSA9IG9wdHMucXVlcnlfcGFyYW1zO1xuICAgICAgICByZXMucmVzdWx0cyA9IHJlcy5yZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGxlZnRUb0ZldGNoLS07XG4gICAgICAgICAgdmFyIHJldCA9IHV0aWxzLmZpbHRlckNoYW5nZShvcHRzKShjKTtcbiAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuRG9jcykge1xuICAgICAgICAgICAgICByZXN1bHRzLnJlc3VsdHMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzLmNhbGwob3B0cy5vbkNoYW5nZSwgYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciwgc3RvcCBsaXN0ZW5pbmcgZm9yIGNoYW5nZXMgYW5kIGNhbGxcbiAgICAgICAgLy8gb3B0cy5jb21wbGV0ZVxuICAgICAgICBvcHRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5jYWxsKG9wdHMuY29tcGxldGUsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNoYW5nZXMgZmVlZCBtYXkgaGF2ZSB0aW1lZCBvdXQgd2l0aCBubyByZXN1bHRzXG4gICAgICAvLyBpZiBzbyByZXVzZSBsYXN0IHVwZGF0ZSBzZXF1ZW5jZVxuICAgICAgaWYgKHJlcyAmJiByZXMubGFzdF9zZXEpIHtcbiAgICAgICAgbGFzdEZldGNoZWRTZXEgPSByZXMubGFzdF9zZXE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hlZCA9IChsaW1pdCAmJiBsZWZ0VG9GZXRjaCA8PSAwKSB8fFxuICAgICAgICAocmVzICYmIHJhd19yZXN1bHRzX2xlbmd0aCA8IGJhdGNoU2l6ZSkgfHxcbiAgICAgICAgKG9wdHMuZGVzY2VuZGluZyk7XG5cbiAgICAgIGlmICgob3B0cy5jb250aW51b3VzICYmICEobGltaXQgJiYgbGVmdFRvRmV0Y2ggPD0gMCkpIHx8ICFmaW5pc2hlZCkge1xuICAgICAgICAvLyBJbmNyZWFzZSByZXRyeSBkZWxheSBleHBvbmVudGlhbGx5IGFzIGxvbmcgYXMgZXJyb3JzIHBlcnNpc3RcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGZldGNoUmV0cnlDb3VudCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoUmV0cnlDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbWVvdXRNdWx0aXBsaWVyID0gMSA8PCBmZXRjaFJldHJ5Q291bnQ7XG4gICAgICAgIHZhciByZXRyeVdhaXQgPSBmZXRjaFRpbWVvdXQgKiB0aW1lb3V0TXVsdGlwbGllcjtcbiAgICAgICAgdmFyIG1heGltdW1XYWl0ID0gb3B0cy5tYXhpbXVtV2FpdCB8fCAzMDAwMDtcblxuICAgICAgICBpZiAocmV0cnlXYWl0ID4gbWF4aW11bVdhaXQpIHtcbiAgICAgICAgICB1dGlscy5jYWxsKG9wdHMuY29tcGxldGUsIGVyciB8fCBlcnJvcnMuVU5LTk9XTl9FUlJPUik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVldWUgYSBjYWxsIHRvIGZldGNoIGFnYWluIHdpdGggdGhlIG5ld2VzdCBzZXF1ZW5jZSBudW1iZXJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGZldGNoKGxhc3RGZXRjaGVkU2VxLCBmZXRjaGVkKTsgfSwgcmV0cnlXYWl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3JlIGRvbmUsIGNhbGwgdGhlIGNhbGxiYWNrXG4gICAgICAgIHV0aWxzLmNhbGwob3B0cy5jb21wbGV0ZSwgbnVsbCwgcmVzdWx0cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZldGNoKG9wdHMuc2luY2UgfHwgMCwgZmV0Y2hlZCk7XG5cbiAgICAvLyBSZXR1cm4gYSBtZXRob2QgdG8gY2FuY2VsIHRoaXMgbWV0aG9kIGZyb20gcHJvY2Vzc2luZyBhbnkgbW9yZVxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHhocikge1xuICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBhcGkuc3NlID0gZnVuY3Rpb24gKG9wdHMsIHBhcmFtcywgcmV0dXJuRG9jcykge1xuICAgIHBhcmFtcy5mZWVkID0gJ2V2ZW50c291cmNlJztcbiAgICBwYXJhbXMuc2luY2UgPSBvcHRzLnNpbmNlIHx8IDA7XG4gICAgcGFyYW1zLmxpbWl0ID0gb3B0cy5saW1pdDtcbiAgICBkZWxldGUgcGFyYW1zLnRpbWVvdXQ7XG4gICAgdmFyIHBhcmFtU3RyID0gJz8nICsgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBrICsgJz0nICsgcGFyYW1zW2tdO1xuICAgIH0pLmpvaW4oJyYnKTtcbiAgICB2YXIgdXJsID0gZ2VuREJVcmwoaG9zdCwgJ19jaGFuZ2VzJyArIHBhcmFtU3RyKTtcbiAgICB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKHVybCk7XG4gICAgdmFyIHJlc3VsdHMgPSB7XG4gICAgICByZXN1bHRzOiBbXSxcbiAgICAgIGxhc3Rfc2VxOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGRpc3BhdGNoZWQgPSBmYWxzZTtcbiAgICB2YXIgb3BlbiA9IGZhbHNlO1xuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbXNnSGFuZGxlciwgZmFsc2UpO1xuICAgIHNvdXJjZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBvcGVuID0gdHJ1ZTtcbiAgICB9O1xuICAgIHNvdXJjZS5vbmVycm9yID0gZXJySGFuZGxlcjtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZWQuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtc2dIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHNvdXJjZS5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbXNnSGFuZGxlcihlKSB7XG4gICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICAgIGlmIChyZXR1cm5Eb2NzKSB7XG4gICAgICAgIHJlc3VsdHMucmVzdWx0cy5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0cy5sYXN0X3NlcSA9IGRhdGEuc2VxO1xuICAgICAgdXRpbHMuY2FsbChvcHRzLm9uQ2hhbmdlLCBkYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXJySGFuZGxlcihlcnIpIHtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbXNnSGFuZGxlciwgZmFsc2UpO1xuICAgICAgaWYgKG9wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGVycm9yZWQgYmVmb3JlIGl0IG9wZW5lZFxuICAgICAgICAvLyBsaWtlbHkgZG9lc24ndCBzdXBwb3J0IEV2ZW50U291cmNlXG4gICAgICAgIGFwaS5fdXNlU1NFID0gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoZWQgPSBhcGkuX2NoYW5nZXMob3B0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5jbG9zZSgpO1xuICAgICAgdXRpbHMuY2FsbChvcHRzLmNvbXBsZXRlLCBlcnIpO1xuICAgIH1cbiAgICBcbiAgfTtcblxuICBhcGkuX3VzZVNTRSA9IGZhbHNlO1xuICAvLyBDdXJyZW50bHkgZGlzYWJsZWQgZHVlIHRvIGZhaWxpbmcgY2hyb21lIHRlc3RzIGluIHNhdWNlbGFic1xuICAvLyBhcGkuX3VzZVNTRSA9IHR5cGVvZiBnbG9iYWwuRXZlbnRTb3VyY2UgPT09ICdmdW5jdGlvbic7XG5cbiAgLy8gR2l2ZW4gYSBzZXQgb2YgZG9jdW1lbnQvcmV2aXNpb24gSURzIChnaXZlbiBieSByZXEpLCB0ZXRzIHRoZSBzdWJzZXQgb2ZcbiAgLy8gdGhvc2UgdGhhdCBkbyBOT1QgY29ycmVzcG9uZCB0byByZXZpc2lvbnMgc3RvcmVkIGluIHRoZSBkYXRhYmFzZS5cbiAgLy8gU2VlIGh0dHA6Ly93aWtpLmFwYWNoZS5vcmcvY291Y2hkYi9IdHRwUG9zdFJldnNEaWZmXG4gIGFwaS5yZXZzRGlmZiA9IHV0aWxzLmFkYXB0ZXJGdW4oJ3JldnNEaWZmJywgZnVuY3Rpb24gKHJlcSwgb3B0cywgY2FsbGJhY2spIHtcbiAgICAvLyBJZiBubyBvcHRpb25zIHdlcmUgZ2l2ZW4sIHNldCB0aGUgY2FsbGJhY2sgdG8gYmUgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIG1pc3NpbmcgZG9jdW1lbnQvcmV2aXNpb24gSURzXG4gICAgYWpheCh7XG4gICAgICBoZWFkZXJzOiBob3N0LmhlYWRlcnMsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogZ2VuREJVcmwoaG9zdCwgJ19yZXZzX2RpZmYnKSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcSlcbiAgICB9LCBjYWxsYmFjayk7XG4gIH0pO1xuXG4gIGFwaS5fY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIGFwaS5kZXN0cm95ID0gdXRpbHMuYWRhcHRlckZ1bignZGVzdHJveScsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGFqYXgoe1xuICAgICAgdXJsOiBnZW5EQlVybChob3N0LCAnJyksXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczogaG9zdC5oZWFkZXJzXG4gICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBhcGkuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBpLmVtaXQoJ2Rlc3Ryb3llZCcpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIERlbGV0ZSB0aGUgSHR0cFBvdWNoIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gbmFtZS5cbkh0dHBQb3VjaC5kZXN0cm95ID0gdXRpbHMudG9Qcm9taXNlKGZ1bmN0aW9uIChuYW1lLCBvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgaG9zdCA9IGdldEhvc3QobmFtZSwgb3B0cyk7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIG9wdHMgPSB1dGlscy5jbG9uZShvcHRzKTtcbiAgb3B0cy5oZWFkZXJzID0gaG9zdC5oZWFkZXJzO1xuICBvcHRzLm1ldGhvZCA9ICdERUxFVEUnO1xuICBvcHRzLnVybCA9IGdlbkRCVXJsKGhvc3QsICcnKTtcbiAgdmFyIGFqYXhPcHRzID0gb3B0cy5hamF4IHx8IHt9O1xuICBvcHRzID0gdXRpbHMuZXh0ZW5kKHt9LCBvcHRzLCBhamF4T3B0cyk7XG4gIHV0aWxzLmFqYXgob3B0cywgY2FsbGJhY2spO1xufSk7XG5cbi8vIEh0dHBQb3VjaCBpcyBhIHZhbGlkIGFkYXB0ZXIuXG5IdHRwUG91Y2gudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdHRwUG91Y2g7XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL1VzZXJzL2RhbGVoYXJ2ZXkvc3JjL3BvdWNoZGIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKVxufSx7XCIuLi9kZXBzL2Vycm9yc1wiOjEyLFwiLi4vdXRpbHNcIjoyNixcIi9Vc2Vycy9kYWxlaGFydmV5L3NyYy9wb3VjaGRiL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjMxfV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMnKTtcbnZhciBtZXJnZSA9IF9kZXJlcV8oJy4uL21lcmdlJyk7XG52YXIgZXJyb3JzID0gX2RlcmVxXygnLi4vZGVwcy9lcnJvcnMnKTtcbnZhciB2dXZ1emVsYSA9IF9kZXJlcV8oJ3Z1dnV6ZWxhJyk7XG5cbnZhciBjYWNoZWREQnMgPSB7fTtcbnZhciB0YXNrUXVldWUgPSB7XG4gIHJ1bm5pbmc6IGZhbHNlLFxuICBxdWV1ZTogW11cbn07XG5cbmZ1bmN0aW9uIHRyeUNvZGUoZnVuLCB0aGF0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgZnVuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnIpIHsgLy8gc2hvdWxkbid0IGhhcHBlblxuICAgIGlmICh3aW5kb3cuUG91Y2hEQikge1xuICAgICAgd2luZG93LlBvdWNoREIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5leHQoKSB7XG4gIGlmICh0YXNrUXVldWUucnVubmluZyB8fCAhdGFza1F1ZXVlLnF1ZXVlLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0YXNrUXVldWUucnVubmluZyA9IHRydWU7XG4gIHZhciBpdGVtID0gdGFza1F1ZXVlLnF1ZXVlLnNoaWZ0KCk7XG4gIGl0ZW0uYWN0aW9uKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgIHRyeUNvZGUoaXRlbS5jYWxsYmFjaywgdGhpcywgW2VyciwgcmVzXSk7XG4gICAgdGFza1F1ZXVlLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGFwcGx5TmV4dCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpZGJFcnJvcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAoZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5lcnJvciAmJlxuICAgICAgZXZlbnQudGFyZ2V0LmVycm9yLm5hbWUpIHx8IGV2ZW50LnRhcmdldDtcbiAgICBjYWxsYmFjayhlcnJvcnMuZXJyb3IoZXJyb3JzLklEQl9FUlJPUiwgbWVzc2FnZSwgZXZlbnQudHlwZSkpO1xuICB9O1xufVxuXG4vLyBVbmZvcnR1bmF0ZWx5LCB0aGUgbWV0YWRhdGEgaGFzIHRvIGJlIHN0cmluZ2lmaWVkXG4vLyB3aGVuIGl0IGlzIHB1dCBpbnRvIHRoZSBkYXRhYmFzZSwgYmVjYXVzZSBvdGhlcndpc2Vcbi8vIEluZGV4ZWREQiBjYW4gdGhyb3cgZXJyb3JzIGZvciBkZWVwbHktbmVzdGVkIG9iamVjdHMuXG4vLyBPcmlnaW5hbGx5IHdlIGp1c3QgdXNlZCBKU09OLnBhcnNlL0pTT04uc3RyaW5naWZ5OyBub3dcbi8vIHdlIHVzZSB0aGlzIGN1c3RvbSB2dXZ1emVsYSBsaWJyYXJ5IHRoYXQgYXZvaWRzIHJlY3Vyc2lvbi5cbi8vIElmIHdlIGNvdWxkIGRvIGl0IGFsbCBvdmVyIGFnYWluLCB3ZSdkIHByb2JhYmx5IHVzZSBhXG4vLyBmb3JtYXQgZm9yIHRoZSByZXZpc2lvbiB0cmVlcyBvdGhlciB0aGFuIEpTT04uXG5mdW5jdGlvbiBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSwgd2lubmluZ1JldiwgZGVsZXRlZCkge1xuICB2YXIgc3RvcmVkT2JqZWN0ID0ge2RhdGE6IHZ1dnV6ZWxhLnN0cmluZ2lmeShtZXRhZGF0YSl9O1xuICBzdG9yZWRPYmplY3Qud2lubmluZ1JldiA9IHdpbm5pbmdSZXY7XG4gIHN0b3JlZE9iamVjdC5kZWxldGVkT3JMb2NhbCA9IGRlbGV0ZWQgPyAnMScgOiAnMCc7XG4gIHN0b3JlZE9iamVjdC5pZCA9IG1ldGFkYXRhLmlkO1xuICByZXR1cm4gc3RvcmVkT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBkZWNvZGVNZXRhZGF0YShzdG9yZWRPYmplY3QpIHtcbiAgaWYgKCFzdG9yZWRPYmplY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIXN0b3JlZE9iamVjdC5kYXRhKSB7XG4gICAgLy8gb2xkIGZvcm1hdCwgd2hlbiB3ZSBkaWRuJ3Qgc3RvcmUgaXQgc3RyaW5naWZpZWRcbiAgICByZXR1cm4gc3RvcmVkT2JqZWN0O1xuICB9XG4gIHZhciBtZXRhZGF0YSA9IHZ1dnV6ZWxhLnBhcnNlKHN0b3JlZE9iamVjdC5kYXRhKTtcbiAgbWV0YWRhdGEud2lubmluZ1JldiA9IHN0b3JlZE9iamVjdC53aW5uaW5nUmV2O1xuICBtZXRhZGF0YS5kZWxldGVkT3JMb2NhbCA9IHN0b3JlZE9iamVjdC5kZWxldGVkT3JMb2NhbCA9PT0gJzEnO1xuICByZXR1cm4gbWV0YWRhdGE7XG59XG5cbmZ1bmN0aW9uIElkYlBvdWNoKG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBhcGkgPSB0aGlzO1xuXG4gIHRhc2tRdWV1ZS5xdWV1ZS5wdXNoKHtcbiAgICBhY3Rpb246IGZ1bmN0aW9uICh0aGlzQ2FsbGJhY2spIHtcbiAgICAgIGluaXQoYXBpLCBvcHRzLCB0aGlzQ2FsbGJhY2spO1xuICAgIH0sXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xuICBhcHBseU5leHQoKTtcbn1cblxuZnVuY3Rpb24gaW5pdChhcGksIG9wdHMsIGNhbGxiYWNrKSB7XG5cbiAgLy8gSW5kZXhlZERCIHJlcXVpcmVzIGEgdmVyc2lvbmVkIGRhdGFiYXNlIHN0cnVjdHVyZSwgc28gd2UgdXNlIHRoZVxuICAvLyB2ZXJzaW9uIGhlcmUgdG8gbWFuYWdlIG1pZ3JhdGlvbnMuXG4gIHZhciBBREFQVEVSX1ZFUlNJT04gPSA0O1xuXG4gIC8vIFRoZSBvYmplY3Qgc3RvcmVzIGNyZWF0ZWQgZm9yIGVhY2ggZGF0YWJhc2VcbiAgLy8gRE9DX1NUT1JFIHN0b3JlcyB0aGUgZG9jdW1lbnQgbWV0YSBkYXRhLCBpdHMgcmV2aXNpb24gaGlzdG9yeSBhbmQgc3RhdGVcbiAgLy8gS2V5ZWQgYnkgZG9jdW1lbnQgaWRcbiAgdmFyIERPQ19TVE9SRSA9ICdkb2N1bWVudC1zdG9yZSc7XG4gIC8vIEJZX1NFUV9TVE9SRSBzdG9yZXMgYSBwYXJ0aWN1bGFyIHZlcnNpb24gb2YgYSBkb2N1bWVudCwga2V5ZWQgYnkgaXRzXG4gIC8vIHNlcXVlbmNlIGlkXG4gIHZhciBCWV9TRVFfU1RPUkUgPSAnYnktc2VxdWVuY2UnO1xuICAvLyBXaGVyZSB3ZSBzdG9yZSBhdHRhY2htZW50c1xuICB2YXIgQVRUQUNIX1NUT1JFID0gJ2F0dGFjaC1zdG9yZSc7XG4gIC8vIFdoZXJlIHdlIHN0b3JlIG1hbnktdG8tbWFueSByZWxhdGlvbnNcbiAgLy8gYmV0d2VlbiBhdHRhY2htZW50IGRpZ2VzdHMgYW5kIHNlcXNcbiAgdmFyIEFUVEFDSF9BTkRfU0VRX1NUT1JFID0gJ2F0dGFjaC1zZXEtc3RvcmUnO1xuXG4gIC8vIFdoZXJlIHdlIHN0b3JlIGRhdGFiYXNlLXdpZGUgbWV0YSBkYXRhIGluIGEgc2luZ2xlIHJlY29yZFxuICAvLyBrZXllZCBieSBpZDogTUVUQV9TVE9SRVxuICB2YXIgTUVUQV9TVE9SRSA9ICdtZXRhLXN0b3JlJztcbiAgLy8gV2hlcmUgd2Ugc3RvcmUgbG9jYWwgZG9jdW1lbnRzXG4gIHZhciBMT0NBTF9TVE9SRSA9ICdsb2NhbC1zdG9yZSc7XG4gIC8vIFdoZXJlIHdlIGRldGVjdCBibG9iIHN1cHBvcnRcbiAgdmFyIERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUgPSAnZGV0ZWN0LWJsb2Itc3VwcG9ydCc7XG5cbiAgdmFyIG5hbWUgPSBvcHRzLm5hbWU7XG5cbiAgdmFyIGJsb2JTdXBwb3J0ID0gbnVsbDtcbiAgdmFyIGluc3RhbmNlSWQgPSBudWxsO1xuICB2YXIgaWRTdG9yZWQgPSBmYWxzZTtcbiAgdmFyIGlkYiA9IG51bGw7XG4gIHZhciBkb2NDb3VudCA9IC0xO1xuXG4gIC8vIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGEgZnJlc2ggbmV3IGRhdGFiYXNlXG4gIGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYShkYikge1xuICAgIHZhciBkb2NTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERPQ19TVE9SRSwge2tleVBhdGggOiAnaWQnfSk7XG4gICAgZG9jU3RvcmUuY3JlYXRlSW5kZXgoJ3NlcScsICdzZXEnLCB7dW5pcXVlOiB0cnVlfSk7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFLCB7YXV0b0luY3JlbWVudDogdHJ1ZX0pXG4gICAgICAuY3JlYXRlSW5kZXgoJ19kb2NfaWRfcmV2JywgJ19kb2NfaWRfcmV2Jywge3VuaXF1ZTogdHJ1ZX0pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKEFUVEFDSF9TVE9SRSwge2tleVBhdGg6ICdkaWdlc3QnfSk7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoTUVUQV9TVE9SRSwge2tleVBhdGg6ICdpZCcsIGF1dG9JbmNyZW1lbnQ6IGZhbHNlfSk7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSk7XG5cbiAgICAvLyBhZGRlZCBpbiB2MlxuICAgIGRvY1N0b3JlLmNyZWF0ZUluZGV4KCdkZWxldGVkT3JMb2NhbCcsICdkZWxldGVkT3JMb2NhbCcsIHt1bmlxdWUgOiBmYWxzZX0pO1xuXG4gICAgLy8gYWRkZWQgaW4gdjNcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShMT0NBTF9TVE9SRSwge2tleVBhdGg6ICdfaWQnfSlcbiAgICAgIC5jcmVhdGVJbmRleCgnX2RvY19pZF9yZXYnLCAnX2RvY19pZF9yZXYnLCB7dW5pcXVlOiB0cnVlfSk7XG5cbiAgICAvLyBhZGRlZCBpbiB2NFxuICAgIHZhciBhdHRBbmRTZXFTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKEFUVEFDSF9BTkRfU0VRX1NUT1JFLFxuICAgICAge2F1dG9JbmNyZW1lbnQ6IHRydWV9KTtcbiAgICBhdHRBbmRTZXFTdG9yZS5jcmVhdGVJbmRleCgnc2VxJywgJ3NlcScpO1xuICAgIGF0dEFuZFNlcVN0b3JlLmNyZWF0ZUluZGV4KCdkaWdlc3RTZXEnLCAnZGlnZXN0U2VxJywge3VuaXF1ZTogdHJ1ZX0pO1xuICB9XG5cbiAgLy8gbWlncmF0aW9uIHRvIHZlcnNpb24gMlxuICAvLyB1bmZvcnR1bmF0ZWx5IFwiZGVsZXRlZE9yTG9jYWxcIiBpcyBhIG1pc25vbWVyIG5vdyB0aGF0IHdlIG5vIGxvbmdlclxuICAvLyBzdG9yZSBsb2NhbCBkb2NzIGluIHRoZSBtYWluIGRvYy1zdG9yZSwgYnV0IHdoYWRkeWFnb25uYWRvXG4gIGZ1bmN0aW9uIGFkZERlbGV0ZWRPckxvY2FsSW5kZXgodHhuLCBjYWxsYmFjaykge1xuICAgIHZhciBkb2NTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuICAgIGRvY1N0b3JlLmNyZWF0ZUluZGV4KCdkZWxldGVkT3JMb2NhbCcsICdkZWxldGVkT3JMb2NhbCcsIHt1bmlxdWUgOiBmYWxzZX0pO1xuXG4gICAgZG9jU3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgdmFyIGRlbGV0ZWQgPSB1dGlscy5pc0RlbGV0ZWQobWV0YWRhdGEpO1xuICAgICAgICBtZXRhZGF0YS5kZWxldGVkT3JMb2NhbCA9IGRlbGV0ZWQgPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICBkb2NTdG9yZS5wdXQobWV0YWRhdGEpO1xuICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gbWlncmF0aW9ucyB0byBnZXQgdG8gdmVyc2lvbiAzXG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYWxTdG9yZVNjaGVtYShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKExPQ0FMX1NUT1JFLCB7a2V5UGF0aDogJ19pZCd9KVxuICAgICAgLmNyZWF0ZUluZGV4KCdfZG9jX2lkX3JldicsICdfZG9jX2lkX3JldicsIHt1bmlxdWU6IHRydWV9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pZ3JhdGVMb2NhbFN0b3JlKHR4biwgY2IpIHtcbiAgICB2YXIgbG9jYWxTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShMT0NBTF9TVE9SRSk7XG4gICAgdmFyIGRvY1N0b3JlID0gdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSk7XG4gICAgdmFyIHNlcVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEJZX1NFUV9TVE9SRSk7XG5cbiAgICB2YXIgY3Vyc29yID0gZG9jU3RvcmUub3BlbkN1cnNvcigpO1xuICAgIGN1cnNvci5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgIHZhciBkb2NJZCA9IG1ldGFkYXRhLmlkO1xuICAgICAgICB2YXIgbG9jYWwgPSB1dGlscy5pc0xvY2FsSWQoZG9jSWQpO1xuICAgICAgICB2YXIgcmV2ID0gbWVyZ2Uud2lubmluZ1JldihtZXRhZGF0YSk7XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgIHZhciBkb2NJZFJldiA9IGRvY0lkICsgXCI6OlwiICsgcmV2O1xuICAgICAgICAgIC8vIHJlbW92ZSBhbGwgc2VxIGVudHJpZXNcbiAgICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGhpcyBkb2NJZFxuICAgICAgICAgIHZhciBzdGFydCA9IGRvY0lkICsgXCI6OlwiO1xuICAgICAgICAgIHZhciBlbmQgPSBkb2NJZCArIFwiOjp+XCI7XG4gICAgICAgICAgdmFyIGluZGV4ID0gc2VxU3RvcmUuaW5kZXgoJ19kb2NfaWRfcmV2Jyk7XG4gICAgICAgICAgdmFyIHJhbmdlID0gZ2xvYmFsLklEQktleVJhbmdlLmJvdW5kKHN0YXJ0LCBlbmQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgdmFyIHNlcUN1cnNvciA9IGluZGV4Lm9wZW5DdXJzb3IocmFuZ2UpO1xuICAgICAgICAgIHNlcUN1cnNvci5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VxQ3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFzZXFDdXJzb3IpIHtcbiAgICAgICAgICAgICAgLy8gZG9uZVxuICAgICAgICAgICAgICBkb2NTdG9yZVtcImRlbGV0ZVwiXShjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcUN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuX2RvY19pZF9yZXYgPT09IGRvY0lkUmV2KSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZS5wdXQoZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VxU3RvcmVbXCJkZWxldGVcIl0oc2VxQ3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICBzZXFDdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Vyc29yW1wiY29udGludWVcIl0oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBtaWdyYXRpb25zIHRvIGdldCB0byB2ZXJzaW9uIDRcbiAgZnVuY3Rpb24gYWRkQXR0YWNoQW5kU2VxU3RvcmUoZGIpIHtcbiAgICB2YXIgYXR0QW5kU2VxU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShBVFRBQ0hfQU5EX1NFUV9TVE9SRSxcbiAgICAgIHthdXRvSW5jcmVtZW50OiB0cnVlfSk7XG4gICAgYXR0QW5kU2VxU3RvcmUuY3JlYXRlSW5kZXgoJ3NlcScsICdzZXEnKTtcbiAgICBhdHRBbmRTZXFTdG9yZS5jcmVhdGVJbmRleCgnZGlnZXN0U2VxJywgJ2RpZ2VzdFNlcScsIHt1bmlxdWU6IHRydWV9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pZ3JhdGVBdHRzQW5kU2Vxcyh0eG4pIHtcbiAgICB2YXIgc2VxU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFKTtcbiAgICB2YXIgYXR0U3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQVRUQUNIX1NUT1JFKTtcbiAgICB2YXIgYXR0QW5kU2VxU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQVRUQUNIX0FORF9TRVFfU1RPUkUpO1xuXG4gICAgLy8gbmVlZCB0byBhY3R1YWxseSBwb3B1bGF0ZSB0aGUgdGFibGUuIHRoaXMgaXMgdGhlIGV4cGVuc2l2ZSBwYXJ0LFxuICAgIC8vIHNvIGFzIGFuIG9wdGltaXphdGlvbiwgY2hlY2sgZmlyc3QgdGhhdCB0aGlzIGRhdGFiYXNlIGV2ZW5cbiAgICAvLyBjb250YWlucyBhdHRhY2htZW50c1xuICAgIHZhciByZXEgPSBhdHRTdG9yZS5jb3VudCgpO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGNvdW50ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICByZXR1cm47IC8vIGRvbmVcbiAgICAgIH1cblxuICAgICAgc2VxU3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBkb25lXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvYyA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgdmFyIHNlcSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICB2YXIgYXR0cyA9IE9iamVjdC5rZXlzKGRvYy5fYXR0YWNobWVudHMgfHwge30pO1xuICAgICAgICB2YXIgZGlnZXN0TWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBhdHQgPSBkb2MuX2F0dGFjaG1lbnRzW2F0dHNbal1dO1xuICAgICAgICAgIGRpZ2VzdE1hcFthdHQuZGlnZXN0XSA9IHRydWU7IC8vIHVuaXEgZGlnZXN0cywganVzdCBpbiBjYXNlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZ2VzdHMgPSBPYmplY3Qua2V5cyhkaWdlc3RNYXApO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZGlnZXN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBkaWdlc3QgPSBkaWdlc3RzW2pdO1xuICAgICAgICAgIGF0dEFuZFNlcVN0b3JlLnB1dCh7XG4gICAgICAgICAgICBzZXE6IHNlcSxcbiAgICAgICAgICAgIGRpZ2VzdFNlcTogZGlnZXN0ICsgJzo6JyArIHNlcVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBhcGkudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ2lkYic7XG4gIH07XG5cbiAgYXBpLl9pZCA9IHV0aWxzLnRvUHJvbWlzZShmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayhudWxsLCBpbnN0YW5jZUlkKTtcbiAgfSk7XG5cbiAgYXBpLl9idWxrRG9jcyA9IGZ1bmN0aW9uIGlkYl9idWxrRG9jcyhyZXEsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5ld0VkaXRzID0gb3B0cy5uZXdfZWRpdHM7XG4gICAgdmFyIHVzZXJEb2NzID0gcmVxLmRvY3M7XG4gICAgLy8gUGFyc2UgdGhlIGRvY3MsIGdpdmUgdGhlbSBhIHNlcXVlbmNlIG51bWJlciBmb3IgdGhlIHJlc3VsdFxuICAgIHZhciBkb2NJbmZvcyA9IHVzZXJEb2NzLm1hcChmdW5jdGlvbiAoZG9jLCBpKSB7XG4gICAgICBpZiAoZG9jLl9pZCAmJiB1dGlscy5pc0xvY2FsSWQoZG9jLl9pZCkpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEb2MgPSB1dGlscy5wYXJzZURvYyhkb2MsIG5ld0VkaXRzKTtcbiAgICAgIG5ld0RvYy5fYnVsa19zZXEgPSBpO1xuICAgICAgcmV0dXJuIG5ld0RvYztcbiAgICB9KTtcblxuICAgIHZhciBkb2NJbmZvRXJyb3JzID0gZG9jSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChkb2NJbmZvKSB7XG4gICAgICByZXR1cm4gZG9jSW5mby5lcnJvcjtcbiAgICB9KTtcbiAgICBpZiAoZG9jSW5mb0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhkb2NJbmZvRXJyb3JzWzBdKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShkb2NJbmZvcy5sZW5ndGgpO1xuICAgIHZhciBmZXRjaGVkRG9jcyA9IG5ldyB1dGlscy5NYXAoKTtcbiAgICB2YXIgcHJlY29uZGl0aW9uRXJyb3JlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RvY3MoKSB7XG4gICAgICBpZiAoIWRvY0luZm9zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHNUb0RvY3MgPSBuZXcgdXRpbHMuTWFwKCk7XG5cbiAgICAgIGRvY0luZm9zLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnREb2MsIHJlc3VsdHNJZHgpIHtcbiAgICAgICAgaWYgKGN1cnJlbnREb2MuX2lkICYmIHV0aWxzLmlzTG9jYWxJZChjdXJyZW50RG9jLl9pZCkpIHtcbiAgICAgICAgICBhcGlbY3VycmVudERvYy5fZGVsZXRlZCA/ICdfcmVtb3ZlTG9jYWwnIDogJ19wdXRMb2NhbCddKFxuICAgICAgICAgICAgICBjdXJyZW50RG9jLCB7Y3R4OiB0eG59LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbcmVzdWx0c0lkeF0gPSBlcnI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHRzW3Jlc3VsdHNJZHhdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gY3VycmVudERvYy5tZXRhZGF0YS5pZDtcbiAgICAgICAgaWYgKGlkc1RvRG9jcy5oYXMoaWQpKSB7XG4gICAgICAgICAgaWRzVG9Eb2NzLmdldChpZCkucHVzaChbY3VycmVudERvYywgcmVzdWx0c0lkeF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkc1RvRG9jcy5zZXQoaWQsIFtbY3VycmVudERvYywgcmVzdWx0c0lkeF1dKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGluIHRoZSBjYXNlIG9mIG5ld19lZGl0cywgdGhlIHVzZXIgY2FuIHByb3ZpZGUgbXVsdGlwbGUgZG9jc1xuICAgICAgLy8gd2l0aCB0aGUgc2FtZSBpZC4gdGhlc2UgbmVlZCB0byBiZSBwcm9jZXNzZWQgc2VxdWVudGlhbGx5XG4gICAgICBpZHNUb0RvY3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jcywgaWQpIHtcbiAgICAgICAgdmFyIG51bURvbmUgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvY1dyaXR0ZW4oKSB7XG4gICAgICAgICAgaWYgKCsrbnVtRG9uZSA8IGRvY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0RG9jKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5leHREb2MoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZG9jc1tudW1Eb25lXTtcbiAgICAgICAgICB2YXIgY3VycmVudERvYyA9IHZhbHVlWzBdO1xuICAgICAgICAgIHZhciByZXN1bHRzSWR4ID0gdmFsdWVbMV07XG5cbiAgICAgICAgICBpZiAoZmV0Y2hlZERvY3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgdXBkYXRlRG9jKGZldGNoZWREb2NzLmdldChpZCksIGN1cnJlbnREb2MsIHJlc3VsdHNJZHgsIGRvY1dyaXR0ZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnREb2MoY3VycmVudERvYywgcmVzdWx0c0lkeCwgZG9jV3JpdHRlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHREb2MoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoRXhpc3RpbmdEb2NzKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIWRvY0luZm9zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG51bUZldGNoZWQgPSAwO1xuXG4gICAgICBmdW5jdGlvbiBjaGVja0RvbmUoKSB7XG4gICAgICAgIGlmICgrK251bUZldGNoZWQgPT09IGRvY0luZm9zLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZG9jSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jSW5mbykge1xuICAgICAgICBpZiAoZG9jSW5mby5faWQgJiYgdXRpbHMuaXNMb2NhbElkKGRvY0luZm8uX2lkKSkge1xuICAgICAgICAgIHJldHVybiBjaGVja0RvbmUoKTsgLy8gc2tpcCBsb2NhbCBkb2NzXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gZG9jSW5mby5tZXRhZGF0YS5pZDtcbiAgICAgICAgdmFyIHJlcSA9IHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmdldChpZCk7XG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzX2RvY1JlYWQoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBkZWNvZGVNZXRhZGF0YShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGZldGNoZWREb2NzLnNldChpZCwgbWV0YWRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgaWYgKHByZWNvbmRpdGlvbkVycm9yZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGFyZXN1bHRzID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0Ll9idWxrX3NlcSkge1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHQuX2J1bGtfc2VxO1xuICAgICAgICB9IGVsc2UgaWYgKCFPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0YWRhdGEgPSByZXN1bHQubWV0YWRhdGE7XG4gICAgICAgIHZhciByZXYgPSBtZXJnZS53aW5uaW5nUmV2KG1ldGFkYXRhKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGlkOiBtZXRhZGF0YS5pZCxcbiAgICAgICAgICByZXY6IHJldlxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBJZGJQb3VjaC5DaGFuZ2VzLm5vdGlmeShuYW1lKTtcbiAgICAgIGRvY0NvdW50ID0gLTE7IC8vIGludmFsaWRhdGVcbiAgICAgIGNhbGxiYWNrKG51bGwsIGFyZXN1bHRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzQXR0YWNobWVudChhdHQsIGZpbmlzaCkge1xuICAgICAgaWYgKGF0dC5zdHViKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYXR0LmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBhdG9iKGF0dC5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciBlcnIgPSBlcnJvcnMuZXJyb3IoZXJyb3JzLkJBRF9BUkcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQXR0YWNobWVudHMgbmVlZCB0byBiZSBiYXNlNjQgZW5jb2RlZFwiKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICBpZiAoYmxvYlN1cHBvcnQpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGF0dC5jb250ZW50X3R5cGU7XG4gICAgICAgICAgZGF0YSA9IHV0aWxzLmZpeEJpbmFyeShkYXRhKTtcbiAgICAgICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgYXR0LmRhdGEgPSB1dGlscy5jcmVhdGVCbG9iKFtkYXRhXSwge3R5cGU6IHR5cGV9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB1dGlscy5NRDUoZGF0YSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgYXR0LmRpZ2VzdCA9ICdtZDUtJyArIHJlc3VsdDtcbiAgICAgICAgICBhdHQubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdXRpbHMucmVhZEFzQmluYXJ5U3RyaW5nKGF0dC5kYXRhLCBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgICAgIGlmICghYmxvYlN1cHBvcnQpIHtcbiAgICAgICAgICBhdHQuZGF0YSA9IGJ0b2EoYmluYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICB1dGlscy5NRDUoYmluYXJ5KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBhdHQuZGlnZXN0ID0gJ21kNS0nICsgcmVzdWx0O1xuICAgICAgICAgIGF0dC5sZW5ndGggPSBiaW5hcnkubGVuZ3RoO1xuICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlcmlmeUF0dGFjaG1lbnQoZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIHJlcSA9IHR4bi5vYmplY3RTdG9yZShbQVRUQUNIX1NUT1JFXSkuZ2V0KGRpZ2VzdCk7XG4gICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlLnRhcmdldC5yZXN1bHQpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCd1bmtub3duIHN0dWIgYXR0YWNobWVudCB3aXRoIGRpZ2VzdCAnICsgZGlnZXN0KTtcbiAgICAgICAgICBlcnIuc3RhdHVzID0gNDEyO1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2ZXJpZnlBdHRhY2htZW50cyhmaW5pc2gpIHtcbiAgICAgIHZhciBkaWdlc3RzID0gW107XG4gICAgICBkb2NJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChkb2NJbmZvKSB7XG4gICAgICAgIGlmIChkb2NJbmZvLmRhdGEgJiYgZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXR0ID0gZG9jSW5mby5kYXRhLl9hdHRhY2htZW50c1tmaWxlbmFtZV07XG4gICAgICAgICAgICBpZiAoYXR0LnN0dWIpIHtcbiAgICAgICAgICAgICAgZGlnZXN0cy5wdXNoKGF0dC5kaWdlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghZGlnZXN0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgfVxuICAgICAgdmFyIG51bURvbmUgPSAwO1xuICAgICAgdmFyIGVycjtcblxuICAgICAgZnVuY3Rpb24gY2hlY2tEb25lKCkge1xuICAgICAgICBpZiAoKytudW1Eb25lID09PSBkaWdlc3RzLmxlbmd0aCkge1xuICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkaWdlc3RzLmZvckVhY2goZnVuY3Rpb24gKGRpZ2VzdCkge1xuICAgICAgICB2ZXJpZnlBdHRhY2htZW50KGRpZ2VzdCwgZnVuY3Rpb24gKGF0dEVycikge1xuICAgICAgICAgIGlmIChhdHRFcnIgJiYgIWVycikge1xuICAgICAgICAgICAgZXJyID0gYXR0RXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzQXR0YWNobWVudHMoY2FsbGJhY2spIHtcbiAgICAgIGlmICghZG9jSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG9jdiA9IDA7XG4gICAgICBkb2NJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChkb2NJbmZvKSB7XG4gICAgICAgIHZhciBhdHRhY2htZW50cyA9IGRvY0luZm8uZGF0YSAmJiBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzID9cbiAgICAgICAgICBPYmplY3Qua2V5cyhkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzKSA6IFtdO1xuXG4gICAgICAgIGlmICghYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN2ID0gMDtcbiAgICAgICAgZnVuY3Rpb24gYXR0YWNobWVudFByb2Nlc3NlZCgpIHtcbiAgICAgICAgICByZWN2Kys7XG4gICAgICAgICAgaWYgKHJlY3YgPT09IGF0dGFjaG1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgaWYgKGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcHJlcHJvY2Vzc0F0dGFjaG1lbnQoZG9jSW5mby5kYXRhLl9hdHRhY2htZW50c1trZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudFByb2Nlc3NlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgZG9jdisrO1xuICAgICAgICBpZiAoZG9jSW5mb3MubGVuZ3RoID09PSBkb2N2KSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyaXRlRG9jKGRvY0luZm8sIHdpbm5pbmdSZXYsIGRlbGV0ZWQsIGNhbGxiYWNrLCByZXN1bHRzSWR4KSB7XG4gICAgICB2YXIgZXJyID0gbnVsbDtcbiAgICAgIHZhciByZWN2ID0gMDtcbiAgICAgIHZhciBpZCA9IGRvY0luZm8uZGF0YS5faWQgPSBkb2NJbmZvLm1ldGFkYXRhLmlkO1xuICAgICAgdmFyIHJldiA9IGRvY0luZm8uZGF0YS5fcmV2ID0gZG9jSW5mby5tZXRhZGF0YS5yZXY7XG4gICAgICB2YXIgZG9jSWRSZXYgPSBpZCArIFwiOjpcIiArIHJldjtcblxuICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgZG9jSW5mby5kYXRhLl9kZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dGFjaG1lbnRzID0gZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cyA/XG4gICAgICAgIE9iamVjdC5rZXlzKGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHMpIDogW107XG5cbiAgICAgIGZ1bmN0aW9uIGNvbGxlY3RSZXN1bHRzKGF0dGFjaG1lbnRFcnIpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBpZiAoYXR0YWNobWVudEVycikge1xuICAgICAgICAgICAgZXJyID0gYXR0YWNobWVudEVycjtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWN2ID09PSBhdHRhY2htZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhdHRhY2htZW50U2F2ZWQoZXJyKSB7XG4gICAgICAgIHJlY3YrKztcbiAgICAgICAgY29sbGVjdFJlc3VsdHMoZXJyKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgaWYgKCFkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzW2tleV0uc3R1Yikge1xuICAgICAgICAgIHZhciBkYXRhID0gZG9jSW5mby5kYXRhLl9hdHRhY2htZW50c1trZXldLmRhdGE7XG4gICAgICAgICAgZGVsZXRlIGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHNba2V5XS5kYXRhO1xuICAgICAgICAgIHZhciBkaWdlc3QgPSBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzW2tleV0uZGlnZXN0O1xuICAgICAgICAgIHNhdmVBdHRhY2htZW50KGRpZ2VzdCwgZGF0YSwgYXR0YWNobWVudFNhdmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN2Kys7XG4gICAgICAgICAgY29sbGVjdFJlc3VsdHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBtYXAgc2VxcyB0byBhdHRhY2htZW50IGRpZ2VzdHMsIHdoaWNoXG4gICAgICAvLyB3ZSB3aWxsIG5lZWQgbGF0ZXIgZHVyaW5nIGNvbXBhY3Rpb25cbiAgICAgIGZ1bmN0aW9uIGluc2VydEF0dGFjaG1lbnRNYXBwaW5ncyhzZXEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBhdHRzQWRkZWQgPSAwO1xuICAgICAgICB2YXIgYXR0c1RvQWRkID0gT2JqZWN0LmtleXMoZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cyB8fCB7fSk7XG5cbiAgICAgICAgaWYgKCFhdHRzVG9BZGQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tEb25lKCkge1xuICAgICAgICAgIGlmICgrK2F0dHNBZGRlZCA9PT0gYXR0c1RvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkKGF0dCkge1xuICAgICAgICAgIHZhciBkaWdlc3QgPSBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzW2F0dF0uZGlnZXN0O1xuICAgICAgICAgIHZhciByZXEgPSB0eG4ub2JqZWN0U3RvcmUoQVRUQUNIX0FORF9TRVFfU1RPUkUpLnB1dCh7XG4gICAgICAgICAgICBzZXE6IHNlcSxcbiAgICAgICAgICAgIGRpZ2VzdFNlcTogZGlnZXN0ICsgJzo6JyArIHNlcVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGNoZWNrRG9uZTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNhbGxiYWNrIGlzIGZvciBhIGNvbnN0YWludCBlcnJvciwgd2hpY2ggd2UgaWdub3JlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgZG9jaWQvcmV2IGhhcyBhbHJlYWR5IGJlZW4gYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgZGlnZXN0IChlLmcuIHdoZW4gbmV3X2VkaXRzID09IGZhbHNlKVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBhdm9pZCB0cmFuc2FjdGlvbiBhYm9ydFxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gYXZvaWQgdHJhbnNhY3Rpb24gb25lcnJvclxuICAgICAgICAgICAgY2hlY2tEb25lKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHNUb0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFkZChhdHRzVG9BZGRbaV0pOyAvLyBkbyBpbiBwYXJhbGxlbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgZG9jSW5mby5kYXRhLl9kb2NfaWRfcmV2ID0gZG9jSWRSZXY7XG4gICAgICAgIHZhciBzZXFTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShCWV9TRVFfU1RPUkUpO1xuICAgICAgICB2YXIgaW5kZXggPSBzZXFTdG9yZS5pbmRleCgnX2RvY19pZF9yZXYnKTtcblxuICAgICAgICBmdW5jdGlvbiBhZnRlclB1dChlKSB7XG4gICAgICAgICAgdmFyIG1ldGFkYXRhID0gZG9jSW5mby5tZXRhZGF0YTtcbiAgICAgICAgICB2YXIgc2VxID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIG1ldGFkYXRhLnNlcSA9IHNlcTtcbiAgICAgICAgICAvLyBDdXJyZW50IF9yZXYgaXMgY2FsY3VsYXRlZCBmcm9tIF9yZXZfdHJlZSBvbiByZWFkXG4gICAgICAgICAgZGVsZXRlIG1ldGFkYXRhLnJldjtcbiAgICAgICAgICB2YXIgbWV0YWRhdGFUb1N0b3JlID0gZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEsIHdpbm5pbmdSZXYsIGRlbGV0ZWQpO1xuICAgICAgICAgIHZhciBtZXRhRGF0YVJlcSA9IHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLnB1dChtZXRhZGF0YVRvU3RvcmUpO1xuICAgICAgICAgIG1ldGFEYXRhUmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZXRhZGF0YS5kZWxldGVkT3JMb2NhbDtcbiAgICAgICAgICAgIGRlbGV0ZSBtZXRhZGF0YS53aW5uaW5nUmV2O1xuICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRzSWR4XSA9IGRvY0luZm87XG4gICAgICAgICAgICBmZXRjaGVkRG9jcy5zZXQoZG9jSW5mby5tZXRhZGF0YS5pZCwgZG9jSW5mby5tZXRhZGF0YSk7XG4gICAgICAgICAgICBpbnNlcnRBdHRhY2htZW50TWFwcGluZ3Moc2VxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHV0aWxzLmNhbGwoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwdXRSZXEgPSBzZXFTdG9yZS5wdXQoZG9jSW5mby5kYXRhKTtcblxuICAgICAgICBwdXRSZXEub25zdWNjZXNzID0gYWZ0ZXJQdXQ7XG4gICAgICAgIHB1dFJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBDb25zdHJhaW50RXJyb3IsIG5lZWQgdG8gdXBkYXRlLCBub3QgcHV0IChzZWUgIzE2MzggZm9yIGRldGFpbHMpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBhdm9pZCB0cmFuc2FjdGlvbiBhYm9ydFxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIGF2b2lkIHRyYW5zYWN0aW9uIG9uZXJyb3JcbiAgICAgICAgICB2YXIgZ2V0S2V5UmVxID0gaW5kZXguZ2V0S2V5KGRvY0luZm8uZGF0YS5fZG9jX2lkX3Jldik7XG4gICAgICAgICAgZ2V0S2V5UmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcHV0UmVxID0gc2VxU3RvcmUucHV0KGRvY0luZm8uZGF0YSwgZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIHB1dFJlcS5vbnN1Y2Nlc3MgPSBhZnRlclB1dDtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0dGFjaG1lbnRzLmxlbmd0aCkge1xuICAgICAgICBmaW5pc2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEb2Mob2xkRG9jLCBkb2NJbmZvLCByZXN1bHRzSWR4LCBjYWxsYmFjaykge1xuXG4gICAgICBpZiAodXRpbHMucmV2RXhpc3RzKG9sZERvYywgZG9jSW5mby5tZXRhZGF0YS5yZXYpKSB7XG4gICAgICAgIHJlc3VsdHNbcmVzdWx0c0lkeF0gPSBkb2NJbmZvO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXJnZWQgPVxuICAgICAgICBtZXJnZS5tZXJnZShvbGREb2MucmV2X3RyZWUsIGRvY0luZm8ubWV0YWRhdGEucmV2X3RyZWVbMF0sIDEwMDApO1xuXG4gICAgICB2YXIgcHJldmlvdXNseURlbGV0ZWQgPSB1dGlscy5pc0RlbGV0ZWQob2xkRG9jKTtcbiAgICAgIHZhciBkZWxldGVkID0gdXRpbHMuaXNEZWxldGVkKGRvY0luZm8ubWV0YWRhdGEpO1xuICAgICAgdmFyIGluQ29uZmxpY3QgPSAocHJldmlvdXNseURlbGV0ZWQgJiYgZGVsZXRlZCAmJiBuZXdFZGl0cykgfHxcbiAgICAgICAgKCFwcmV2aW91c2x5RGVsZXRlZCAmJiBuZXdFZGl0cyAmJiBtZXJnZWQuY29uZmxpY3RzICE9PSAnbmV3X2xlYWYnKSB8fFxuICAgICAgICAocHJldmlvdXNseURlbGV0ZWQgJiYgIWRlbGV0ZWQgJiYgbWVyZ2VkLmNvbmZsaWN0cyA9PT0gJ25ld19icmFuY2gnKTtcblxuICAgICAgaWYgKGluQ29uZmxpY3QpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzSWR4XSA9IG1ha2VFcnIoZXJyb3JzLlJFVl9DT05GTElDVCwgZG9jSW5mby5fYnVsa19zZXEpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgZG9jSW5mby5tZXRhZGF0YS5yZXZfdHJlZSA9IG1lcmdlZC50cmVlO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZVxuICAgICAgdmFyIHdpbm5pbmdSZXYgPSBtZXJnZS53aW5uaW5nUmV2KGRvY0luZm8ubWV0YWRhdGEpO1xuICAgICAgZGVsZXRlZCA9IHV0aWxzLmlzRGVsZXRlZChkb2NJbmZvLm1ldGFkYXRhLCB3aW5uaW5nUmV2KTtcblxuICAgICAgd3JpdGVEb2MoZG9jSW5mbywgd2lubmluZ1JldiwgZGVsZXRlZCwgY2FsbGJhY2ssIHJlc3VsdHNJZHgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydERvYyhkb2NJbmZvLCByZXN1bHRzSWR4LCBjYWxsYmFjaykge1xuICAgICAgdmFyIHdpbm5pbmdSZXYgPSBtZXJnZS53aW5uaW5nUmV2KGRvY0luZm8ubWV0YWRhdGEpO1xuICAgICAgdmFyIGRlbGV0ZWQgPSB1dGlscy5pc0RlbGV0ZWQoZG9jSW5mby5tZXRhZGF0YSwgd2lubmluZ1Jldik7XG4gICAgICAvLyBDYW50IGluc2VydCBuZXcgZGVsZXRlZCBkb2N1bWVudHNcbiAgICAgIGlmICgnd2FzX2RlbGV0ZScgaW4gb3B0cyAmJiBkZWxldGVkKSB7XG4gICAgICAgIHJlc3VsdHNbcmVzdWx0c0lkeF0gPSBlcnJvcnMuTUlTU0lOR19ET0M7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZURvYyhkb2NJbmZvLCB3aW5uaW5nUmV2LCBkZWxldGVkLCBjYWxsYmFjaywgcmVzdWx0c0lkeCk7XG4gICAgfVxuXG4gICAgLy8gSW5zZXJ0IHNlcXVlbmNlIG51bWJlciBpbnRvIHRoZSBlcnJvciBzbyB3ZSBjYW4gc29ydCBsYXRlclxuICAgIGZ1bmN0aW9uIG1ha2VFcnIoZXJyLCBzZXEpIHtcbiAgICAgIGVyci5fYnVsa19zZXEgPSBzZXE7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVBdHRhY2htZW50KGRpZ2VzdCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBvYmplY3RTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShBVFRBQ0hfU1RPUkUpO1xuICAgICAgb2JqZWN0U3RvcmUuZ2V0KGRpZ2VzdCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV4aXN0cyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICAgIC8vIGRvbid0IGJvdGhlciByZS1wdXR0aW5nIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgcmV0dXJuIHV0aWxzLmNhbGwoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdBdHQgPSB7XG4gICAgICAgICAgZGlnZXN0OiBkaWdlc3QsXG4gICAgICAgICAgYm9keTogZGF0YVxuICAgICAgICB9O1xuICAgICAgICBvYmplY3RTdG9yZS5wdXQobmV3QXR0KS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXRpbHMuY2FsbChjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0eG47XG4gICAgcHJlcHJvY2Vzc0F0dGFjaG1lbnRzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIERPQ19TVE9SRSwgQllfU0VRX1NUT1JFLFxuICAgICAgICBBVFRBQ0hfU1RPUkUsIE1FVEFfU1RPUkUsXG4gICAgICAgIExPQ0FMX1NUT1JFLCBBVFRBQ0hfQU5EX1NFUV9TVE9SRVxuICAgICAgXTtcbiAgICAgIHR4biA9IGlkYi50cmFuc2FjdGlvbihzdG9yZXMsICdyZWFkd3JpdGUnKTtcbiAgICAgIHR4bi5vbmVycm9yID0gaWRiRXJyb3IoY2FsbGJhY2spO1xuICAgICAgdHhuLm9udGltZW91dCA9IGlkYkVycm9yKGNhbGxiYWNrKTtcbiAgICAgIHR4bi5vbmNvbXBsZXRlID0gY29tcGxldGU7XG5cbiAgICAgIHZlcmlmeUF0dGFjaG1lbnRzKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHByZWNvbmRpdGlvbkVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZldGNoRXhpc3RpbmdEb2NzKHByb2Nlc3NEb2NzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEZpcnN0IHdlIGxvb2sgdXAgdGhlIG1ldGFkYXRhIGluIHRoZSBpZHMgZGF0YWJhc2UsIHRoZW4gd2UgZmV0Y2ggdGhlXG4gIC8vIGN1cnJlbnQgcmV2aXNpb24ocykgZnJvbSB0aGUgYnkgc2VxdWVuY2Ugc3RvcmVcbiAgYXBpLl9nZXQgPSBmdW5jdGlvbiBpZGJfZ2V0KGlkLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBkb2M7XG4gICAgdmFyIG1ldGFkYXRhO1xuICAgIHZhciBlcnI7XG4gICAgdmFyIHR4bjtcbiAgICBvcHRzID0gdXRpbHMuY2xvbmUob3B0cyk7XG4gICAgaWYgKG9wdHMuY3R4KSB7XG4gICAgICB0eG4gPSBvcHRzLmN0eDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHhuID1cbiAgICAgICAgaWRiLnRyYW5zYWN0aW9uKFtET0NfU1RPUkUsIEJZX1NFUV9TVE9SRSwgQVRUQUNIX1NUT1JFXSwgJ3JlYWRvbmx5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgY2FsbGJhY2soZXJyLCB7ZG9jOiBkb2MsIG1ldGFkYXRhOiBtZXRhZGF0YSwgY3R4OiB0eG59KTtcbiAgICB9XG5cbiAgICB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoaWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBtZXRhZGF0YSA9IGRlY29kZU1ldGFkYXRhKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAvLyB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSByZXN1bHQgaGVyZSBpZjpcbiAgICAgIC8vIDEuIHRoZXJlIGlzIG5vIHN1Y2ggZG9jdW1lbnRcbiAgICAgIC8vIDIuIHRoZSBkb2N1bWVudCBpcyBkZWxldGVkIGFuZCB3ZSBkb24ndCBhc2sgYWJvdXQgc3BlY2lmaWMgcmV2XG4gICAgICAvLyBXaGVuIHdlIGFzayB3aXRoIG9wdHMucmV2IHdlIGV4cGVjdCB0aGUgYW5zd2VyIHRvIGJlIGVpdGhlclxuICAgICAgLy8gZG9jIChwb3NzaWJseSB3aXRoIF9kZWxldGVkPXRydWUpIG9yIG1pc3NpbmcgZXJyb3JcbiAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgZXJyID0gZXJyb3JzLk1JU1NJTkdfRE9DO1xuICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNEZWxldGVkKG1ldGFkYXRhKSAmJiAhb3B0cy5yZXYpIHtcbiAgICAgICAgZXJyID0gZXJyb3JzLmVycm9yKGVycm9ycy5NSVNTSU5HX0RPQywgXCJkZWxldGVkXCIpO1xuICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICB9XG4gICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFKTtcblxuICAgICAgLy8gbWV0YWRhdGEud2lubmluZ1JldiB3YXMgYWRkZWQgbGF0ZXIsIHNvIG9sZGVyIERCcyBtaWdodCBub3QgaGF2ZSBpdFxuICAgICAgdmFyIHJldiA9IG9wdHMucmV2IHx8IG1ldGFkYXRhLndpbm5pbmdSZXYgfHwgbWVyZ2Uud2lubmluZ1JldihtZXRhZGF0YSk7XG4gICAgICB2YXIga2V5ID0gbWV0YWRhdGEuaWQgKyAnOjonICsgcmV2O1xuXG4gICAgICBvYmplY3RTdG9yZS5pbmRleCgnX2RvY19pZF9yZXYnKS5nZXQoa2V5KS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkb2MgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIGlmIChkb2MgJiYgZG9jLl9kb2NfaWRfcmV2KSB7XG4gICAgICAgICAgZGVsZXRlKGRvYy5fZG9jX2lkX3Jldik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICBlcnIgPSBlcnJvcnMuTUlTU0lOR19ET0M7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIGFwaS5fZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChhdHRhY2htZW50LCBvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciB0eG47XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIGlmIChvcHRzLmN0eCkge1xuICAgICAgdHhuID0gb3B0cy5jdHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4biA9XG4gICAgICAgIGlkYi50cmFuc2FjdGlvbihbRE9DX1NUT1JFLCBCWV9TRVFfU1RPUkUsIEFUVEFDSF9TVE9SRV0sICdyZWFkb25seScpO1xuICAgIH1cbiAgICB2YXIgZGlnZXN0ID0gYXR0YWNobWVudC5kaWdlc3Q7XG4gICAgdmFyIHR5cGUgPSBhdHRhY2htZW50LmNvbnRlbnRfdHlwZTtcblxuICAgIHR4bi5vYmplY3RTdG9yZShBVFRBQ0hfU1RPUkUpLmdldChkaWdlc3QpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGF0YSA9IGUudGFyZ2V0LnJlc3VsdC5ib2R5O1xuICAgICAgaWYgKG9wdHMuZW5jb2RlKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsICcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHsgLy8gd2UgaGF2ZSBibG9iIHN1cHBvcnRcbiAgICAgICAgICB1dGlscy5yZWFkQXNCaW5hcnlTdHJpbmcoZGF0YSwgZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYnRvYShiaW5hcnkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHsgLy8gbm8gYmxvYiBzdXBwb3J0XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHV0aWxzLmNyZWF0ZUJsb2IoWycnXSwge3R5cGU6IHR5cGV9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7IC8vIHdlIGhhdmUgYmxvYiBzdXBwb3J0XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIG5vIGJsb2Igc3VwcG9ydFxuICAgICAgICAgIGRhdGEgPSB1dGlscy5maXhCaW5hcnkoYXRvYihkYXRhKSk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgdXRpbHMuY3JlYXRlQmxvYihbZGF0YV0sIHt0eXBlOiB0eXBlfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhbGxEb2NzUXVlcnkodG90YWxSb3dzLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBzdGFydCA9ICdzdGFydGtleScgaW4gb3B0cyA/IG9wdHMuc3RhcnRrZXkgOiBmYWxzZTtcbiAgICB2YXIgZW5kID0gJ2VuZGtleScgaW4gb3B0cyA/IG9wdHMuZW5ka2V5IDogZmFsc2U7XG4gICAgdmFyIGtleSA9ICdrZXknIGluIG9wdHMgPyBvcHRzLmtleSA6IGZhbHNlO1xuICAgIHZhciBza2lwID0gb3B0cy5za2lwIHx8IDA7XG4gICAgdmFyIGxpbWl0ID0gdHlwZW9mIG9wdHMubGltaXQgPT09ICdudW1iZXInID8gb3B0cy5saW1pdCA6IC0xO1xuICAgIHZhciBpbmNsdXNpdmVFbmQgPSBvcHRzLmluY2x1c2l2ZV9lbmQgIT09IGZhbHNlO1xuICAgIHZhciBkZXNjZW5kaW5nID0gJ2Rlc2NlbmRpbmcnIGluIG9wdHMgJiYgb3B0cy5kZXNjZW5kaW5nID8gJ3ByZXYnIDogbnVsbDtcblxuICAgIHZhciBtYW51YWxEZXNjRW5kID0gZmFsc2U7XG4gICAgaWYgKGRlc2NlbmRpbmcgJiYgc3RhcnQgJiYgZW5kKSB7XG4gICAgICAvLyB1bmZvcnR1bmF0ZWx5IElEQiBoYXMgYSBxdWlyayB3aGVyZSBJREJLZXlSYW5nZS5ib3VuZCBpcyBpbnZhbGlkIGlmIHRoZVxuICAgICAgLy8gc3RhcnQgaXMgbGVzcyB0aGFuIHRoZSBlbmQsIGV2ZW4gaW4gZGVzY2VuZGluZyBtb2RlLiAgQmVzdCBiZXRcbiAgICAgIC8vIGlzIGp1c3QgdG8gaGFuZGxlIGl0IG1hbnVhbGx5IGluIHRoYXQgY2FzZS5cbiAgICAgIG1hbnVhbERlc2NFbmQgPSBlbmQ7XG4gICAgICBlbmQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5UmFuZ2UgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgIGtleVJhbmdlID0gZ2xvYmFsLklEQktleVJhbmdlLmJvdW5kKHN0YXJ0LCBlbmQsIGZhbHNlLCAhaW5jbHVzaXZlRW5kKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgICBrZXlSYW5nZSA9IGdsb2JhbC5JREJLZXlSYW5nZS51cHBlckJvdW5kKHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlSYW5nZSA9IGdsb2JhbC5JREJLZXlSYW5nZS5sb3dlckJvdW5kKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgICBrZXlSYW5nZSA9IGdsb2JhbC5JREJLZXlSYW5nZS5sb3dlckJvdW5kKGVuZCwgIWluY2x1c2l2ZUVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5UmFuZ2UgPSBnbG9iYWwuSURCS2V5UmFuZ2UudXBwZXJCb3VuZChlbmQsICFpbmNsdXNpdmVFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICBrZXlSYW5nZSA9IGdsb2JhbC5JREJLZXlSYW5nZS5vbmx5KGtleSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSA9PT0gXCJEYXRhRXJyb3JcIiAmJiBlLmNvZGUgPT09IDApIHtcbiAgICAgICAgLy8gZGF0YSBlcnJvciwgc3RhcnQgaXMgbGVzcyB0aGFuIGVuZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIHRvdGFsX3Jvd3MgOiB0b3RhbFJvd3MsXG4gICAgICAgICAgb2Zmc2V0IDogb3B0cy5za2lwLFxuICAgICAgICAgIHJvd3MgOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuZXJyb3IoZXJyb3JzLklEQl9FUlJPUiwgZS5uYW1lLCBlLm1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJhbnNhY3Rpb24gPSBpZGIudHJhbnNhY3Rpb24oW0RPQ19TVE9SRSwgQllfU0VRX1NUT1JFXSwgJ3JlYWRvbmx5Jyk7XG4gICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgdG90YWxfcm93czogdG90YWxSb3dzLFxuICAgICAgICBvZmZzZXQ6IG9wdHMuc2tpcCxcbiAgICAgICAgcm93czogcmVzdWx0c1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBvU3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuICAgIHZhciBvQ3Vyc29yID0gZGVzY2VuZGluZyA/IG9TdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlLCBkZXNjZW5kaW5nKVxuICAgICAgOiBvU3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZSk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBvQ3Vyc29yLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUudGFyZ2V0LnJlc3VsdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgdmFyIG1ldGFkYXRhID0gZGVjb2RlTWV0YWRhdGEoY3Vyc29yLnZhbHVlKTtcbiAgICAgIC8vIG1ldGFkYXRhLndpbm5pbmdSZXYgYWRkZWQgbGF0ZXIsIHNvbWUgZGJzIG1pZ2h0IGJlIG1pc3NpbmcgaXRcbiAgICAgIHZhciB3aW5uaW5nUmV2ID0gbWV0YWRhdGEud2lubmluZ1JldiB8fCBtZXJnZS53aW5uaW5nUmV2KG1ldGFkYXRhKTtcblxuICAgICAgZnVuY3Rpb24gYWxsRG9jc0lubmVyKG1ldGFkYXRhLCBkYXRhKSB7XG4gICAgICAgIHZhciBkb2MgPSB7XG4gICAgICAgICAgaWQ6IG1ldGFkYXRhLmlkLFxuICAgICAgICAgIGtleTogbWV0YWRhdGEuaWQsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHJldjogd2lubmluZ1JldlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZV9kb2NzKSB7XG4gICAgICAgICAgZG9jLmRvYyA9IGRhdGE7XG4gICAgICAgICAgZG9jLmRvYy5fcmV2ID0gd2lubmluZ1JldjtcbiAgICAgICAgICBpZiAoZG9jLmRvYy5fZG9jX2lkX3Jldikge1xuICAgICAgICAgICAgZGVsZXRlKGRvYy5kb2MuX2RvY19pZF9yZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cy5jb25mbGljdHMpIHtcbiAgICAgICAgICAgIGRvYy5kb2MuX2NvbmZsaWN0cyA9IG1lcmdlLmNvbGxlY3RDb25mbGljdHMobWV0YWRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBhdHQgaW4gZG9jLmRvYy5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIGlmIChkb2MuZG9jLl9hdHRhY2htZW50cy5oYXNPd25Qcm9wZXJ0eShhdHQpKSB7XG4gICAgICAgICAgICAgIGRvYy5kb2MuX2F0dGFjaG1lbnRzW2F0dF0uc3R1YiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxldGVkID0gdXRpbHMuaXNEZWxldGVkKG1ldGFkYXRhLCB3aW5uaW5nUmV2KTtcbiAgICAgICAgaWYgKG9wdHMuZGVsZXRlZCA9PT0gJ29rJykge1xuICAgICAgICAgIC8vIGRlbGV0ZWQgZG9jcyBhcmUgb2theSB3aXRoIGtleXNfcmVxdWVzdHNcbiAgICAgICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICAgICAgZG9jLnZhbHVlLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZG9jLmRvYyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgICB9IGVsc2UgaWYgKCFkZWxldGVkICYmIHNraXAtLSA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1hbnVhbERlc2NFbmQpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdXNpdmVFbmQgJiYgZG9jLmtleSA8IG1hbnVhbERlc2NFbmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaW5jbHVzaXZlRW5kICYmIGRvYy5rZXkgPD0gbWFudWFsRGVzY0VuZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgICAgIGlmICgtLWxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0cy5pbmNsdWRlX2RvY3MpIHtcbiAgICAgICAgYWxsRG9jc0lubmVyKG1ldGFkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEJZX1NFUV9TVE9SRSkuaW5kZXgoJ19kb2NfaWRfcmV2Jyk7XG4gICAgICAgIHZhciBrZXkgPSBtZXRhZGF0YS5pZCArIFwiOjpcIiArIHdpbm5pbmdSZXY7XG4gICAgICAgIGluZGV4LmdldChrZXkpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGFsbERvY3NJbm5lcihkZWNvZGVNZXRhZGF0YShjdXJzb3IudmFsdWUpLCBldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY291bnREb2NzKGNhbGxiYWNrKSB7XG4gICAgaWYgKGRvY0NvdW50ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvY0NvdW50KTtcbiAgICB9XG5cbiAgICB2YXIgY291bnQ7XG4gICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihbRE9DX1NUT1JFXSwgJ3JlYWRvbmx5Jyk7XG4gICAgdmFyIGluZGV4ID0gdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSkuaW5kZXgoJ2RlbGV0ZWRPckxvY2FsJyk7XG4gICAgaW5kZXguY291bnQoZ2xvYmFsLklEQktleVJhbmdlLm9ubHkoXCIwXCIpKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgY291bnQgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgfTtcbiAgICB0eG4ub25lcnJvciA9IGlkYkVycm9yKGNhbGxiYWNrKTtcbiAgICB0eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvY0NvdW50ID0gY291bnQ7XG4gICAgICBjYWxsYmFjayhudWxsLCBkb2NDb3VudCk7XG4gICAgfTtcbiAgfVxuXG4gIGFwaS5fYWxsRG9jcyA9IGZ1bmN0aW9uIGlkYl9hbGxEb2NzKG9wdHMsIGNhbGxiYWNrKSB7XG5cbiAgICAvLyBmaXJzdCBjb3VudCB0aGUgdG90YWxfcm93c1xuICAgIGNvdW50RG9jcyhmdW5jdGlvbiAoZXJyLCB0b3RhbFJvd3MpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5saW1pdCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIHRvdGFsX3Jvd3MgOiB0b3RhbFJvd3MsXG4gICAgICAgICAgb2Zmc2V0IDogb3B0cy5za2lwLFxuICAgICAgICAgIHJvd3MgOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFsbERvY3NRdWVyeSh0b3RhbFJvd3MsIG9wdHMsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfTtcblxuICBhcGkuX2luZm8gPSBmdW5jdGlvbiBpZGJfaW5mbyhjYWxsYmFjaykge1xuXG4gICAgY291bnREb2NzKGZ1bmN0aW9uIChlcnIsIGNvdW50KSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKGlkYiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ2RiIGlzblxcJ3Qgb3BlbicpO1xuICAgICAgICBlcnJvci5pZCA9ICdpZGJOdWxsJztcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVTZXEgPSAwO1xuICAgICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihbQllfU0VRX1NUT1JFXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICB0eG4ub2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFKS5vcGVuQ3Vyc29yKG51bGwsIFwicHJldlwiKS5vbnN1Y2Nlc3MgPVxuICAgICAgICBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICB1cGRhdGVTZXEgPSBjdXJzb3Iua2V5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZVNlcSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgZG9jX2NvdW50OiBjb3VudCxcbiAgICAgICAgICB1cGRhdGVfc2VxOiB1cGRhdGVTZXFcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIGFwaS5fY2hhbmdlcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuXG4gICAgaWYgKG9wdHMuY29udGludW91cykge1xuICAgICAgdmFyIGlkID0gbmFtZSArICc6JyArIHV0aWxzLnV1aWQoKTtcbiAgICAgIElkYlBvdWNoLkNoYW5nZXMuYWRkTGlzdGVuZXIobmFtZSwgaWQsIGFwaSwgb3B0cyk7XG4gICAgICBJZGJQb3VjaC5DaGFuZ2VzLm5vdGlmeShuYW1lKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIElkYlBvdWNoLkNoYW5nZXMucmVtb3ZlTGlzdGVuZXIobmFtZSwgaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZXNjZW5kaW5nID0gb3B0cy5kZXNjZW5kaW5nID8gJ3ByZXYnIDogbnVsbDtcbiAgICB2YXIgbGFzdFNlcSA9IDA7XG5cbiAgICAvLyBJZ25vcmUgdGhlIGBzaW5jZWAgcGFyYW1ldGVyIHdoZW4gYGRlc2NlbmRpbmdgIGlzIHRydWVcbiAgICBvcHRzLnNpbmNlID0gb3B0cy5zaW5jZSAmJiAhZGVzY2VuZGluZyA/IG9wdHMuc2luY2UgOiAwO1xuXG4gICAgdmFyIGxpbWl0ID0gJ2xpbWl0JyBpbiBvcHRzID8gb3B0cy5saW1pdCA6IC0xO1xuICAgIGlmIChsaW1pdCA9PT0gMCkge1xuICAgICAgbGltaXQgPSAxOyAvLyBwZXIgQ291Y2hEQiBfY2hhbmdlcyBzcGVjXG4gICAgfVxuICAgIHZhciByZXR1cm5Eb2NzO1xuICAgIGlmICgncmV0dXJuRG9jcycgaW4gb3B0cykge1xuICAgICAgcmV0dXJuRG9jcyA9IG9wdHMucmV0dXJuRG9jcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRG9jcyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgbnVtUmVzdWx0cyA9IDA7XG4gICAgdmFyIGZpbHRlciA9IHV0aWxzLmZpbHRlckNoYW5nZShvcHRzKTtcblxuICAgIHZhciB0eG47XG5cbiAgICBmdW5jdGlvbiBmZXRjaENoYW5nZXMoKSB7XG4gICAgICB0eG4gPSBpZGIudHJhbnNhY3Rpb24oW0RPQ19TVE9SRSwgQllfU0VRX1NUT1JFXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICB0eG4ub25jb21wbGV0ZSA9IG9uVHhuQ29tcGxldGU7XG5cbiAgICAgIHZhciByZXE7XG5cbiAgICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICAgIHJlcSA9IHR4bi5vYmplY3RTdG9yZShCWV9TRVFfU1RPUkUpXG4gICAgICAgICAgICAub3BlbkN1cnNvcihnbG9iYWwuSURCS2V5UmFuZ2UubG93ZXJCb3VuZChvcHRzLnNpbmNlLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxID0gdHhuLm9iamVjdFN0b3JlKEJZX1NFUV9TVE9SRSlcbiAgICAgICAgICAgIC5vcGVuQ3Vyc29yKGdsb2JhbC5JREJLZXlSYW5nZS5sb3dlckJvdW5kKG9wdHMuc2luY2UsIHRydWUpKTtcbiAgICAgIH1cblxuICAgICAgcmVxLm9uc3VjY2VzcyA9IG9uc3VjY2VzcztcbiAgICAgIHJlcS5vbmVycm9yID0gb25lcnJvcjtcbiAgICB9XG5cbiAgICBmZXRjaENoYW5nZXMoKTtcblxuICAgIGZ1bmN0aW9uIG9uc3VjY2VzcyhldmVudCkge1xuICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvYyA9IGN1cnNvci52YWx1ZTtcblxuICAgICAgaWYgKG9wdHMuZG9jX2lkcyAmJiBvcHRzLmRvY19pZHMuaW5kZXhPZihkb2MuX2lkKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuICAgICAgaW5kZXguZ2V0KGRvYy5faWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBkZWNvZGVNZXRhZGF0YShldmVudC50YXJnZXQucmVzdWx0KTtcblxuICAgICAgICBpZiAobGFzdFNlcSA8IG1ldGFkYXRhLnNlcSkge1xuICAgICAgICAgIGxhc3RTZXEgPSBtZXRhZGF0YS5zZXE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWV0YWRhdGEud2lubmluZ1JldiB3YXMgb25seSBhZGRlZCBsYXRlclxuICAgICAgICB2YXIgd2lubmluZ1JldiA9IG1ldGFkYXRhLndpbm5pbmdSZXYgfHwgbWVyZ2Uud2lubmluZ1JldihtZXRhZGF0YSk7XG4gICAgICAgIGlmIChkb2MuX3JldiAhPT0gd2lubmluZ1Jldikge1xuICAgICAgICAgIHJldHVybiBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGRvY1snX2RvY19pZF9yZXYnXTtcblxuICAgICAgICB2YXIgY2hhbmdlID0gb3B0cy5wcm9jZXNzQ2hhbmdlKGRvYywgbWV0YWRhdGEsIG9wdHMpO1xuICAgICAgICBjaGFuZ2Uuc2VxID0gY3Vyc29yLmtleTtcbiAgICAgICAgaWYgKGZpbHRlcihjaGFuZ2UpKSB7XG4gICAgICAgICAgbnVtUmVzdWx0cysrO1xuICAgICAgICAgIGlmIChyZXR1cm5Eb2NzKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0cy5vbkNoYW5nZShjaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1SZXN1bHRzICE9PSBsaW1pdCkge1xuICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25UeG5Db21wbGV0ZSgpIHtcbiAgICAgIGlmICghb3B0cy5jb250aW51b3VzKSB7XG4gICAgICAgIG9wdHMuY29tcGxldGUobnVsbCwge1xuICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgICAgbGFzdF9zZXE6IGxhc3RTZXFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGFwaS5fY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAoaWRiID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLk5PVF9PUEVOKTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0luZGV4ZWREQi9JREJEYXRhYmFzZSNjbG9zZVxuICAgIC8vIFwiUmV0dXJucyBpbW1lZGlhdGVseSBhbmQgY2xvc2VzIHRoZSBjb25uZWN0aW9uIGluIGEgc2VwYXJhdGUgdGhyZWFkLi4uXCJcbiAgICBpZGIuY2xvc2UoKTtcbiAgICBkZWxldGUgY2FjaGVkREJzW25hbWVdO1xuICAgIGlkYiA9IG51bGw7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcblxuICBhcGkuX2dldFJldmlzaW9uVHJlZSA9IGZ1bmN0aW9uIChkb2NJZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHhuID0gaWRiLnRyYW5zYWN0aW9uKFtET0NfU1RPUkVdLCAncmVhZG9ubHknKTtcbiAgICB2YXIgcmVxID0gdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSkuZ2V0KGRvY0lkKTtcbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgZG9jID0gZGVjb2RlTWV0YWRhdGEoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICBpZiAoIWRvYykge1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMuTUlTU0lOR19ET0MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZG9jLnJldl90cmVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyByZXZpc2lvbnMgb2YgZG9jdW1lbnQgZG9jSWRcbiAgLy8gd2hpY2ggYXJlIGxpc3RlZCBpbiByZXZzIGFuZCBzZXRzIHRoaXMgZG9jdW1lbnRcbiAgLy8gcmV2aXNpb24gdG8gdG8gcmV2X3RyZWVcbiAgYXBpLl9kb0NvbXBhY3Rpb24gPSBmdW5jdGlvbiAoZG9jSWQsIHJldnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihbXG4gICAgICBET0NfU1RPUkUsXG4gICAgICBCWV9TRVFfU1RPUkUsXG4gICAgICBBVFRBQ0hfU1RPUkUsXG4gICAgICBBVFRBQ0hfQU5EX1NFUV9TVE9SRVxuICAgIF0sICdyZWFkd3JpdGUnKTtcblxuICAgIHZhciBkb2NTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuICAgIHZhciBzZXFTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShCWV9TRVFfU1RPUkUpO1xuICAgIHZhciBhdHRTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShBVFRBQ0hfU1RPUkUpO1xuICAgIHZhciBhdHRBbmRTZXFTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShBVFRBQ0hfQU5EX1NFUV9TVE9SRSk7XG5cbiAgICB2YXIgcG9zc2libHlPcnBoYW5lZERpZ2VzdHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZU9ycGhhbmVkQXR0YWNobWVudHMoKSB7XG4gICAgICBpZiAoIXBvc3NpYmx5T3JwaGFuZWREaWdlc3RzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwb3NzaWJseU9ycGhhbmVkRGlnZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChkaWdlc3QpIHtcbiAgICAgICAgdmFyIGNvdW50UmVxID0gYXR0QW5kU2VxU3RvcmUuaW5kZXgoJ2RpZ2VzdFNlcScpLmNvdW50KFxuICAgICAgICAgIGdsb2JhbC5JREJLZXlSYW5nZS5ib3VuZChcbiAgICAgICAgICAgIGRpZ2VzdCArICc6OicsIGRpZ2VzdCArICc6OlxcdWZmZmYnLCBmYWxzZSwgZmFsc2UpKTtcbiAgICAgICAgY291bnRSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgY291bnQgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgLy8gb3JwaGFuZWRcbiAgICAgICAgICAgIGF0dFN0b3JlW1wiZGVsZXRlXCJdKGRpZ2VzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZG9jU3RvcmUuZ2V0KGRvY0lkKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBtZXRhZGF0YSA9IGRlY29kZU1ldGFkYXRhKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgbWVyZ2UudHJhdmVyc2VSZXZUcmVlKG1ldGFkYXRhLnJldl90cmVlLCBmdW5jdGlvbiAoaXNMZWFmLCBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZIYXNoLCBjdHgsIG9wdHMpIHtcbiAgICAgICAgdmFyIHJldiA9IHBvcyArICctJyArIHJldkhhc2g7XG4gICAgICAgIGlmIChyZXZzLmluZGV4T2YocmV2KSAhPT0gLTEpIHtcbiAgICAgICAgICBvcHRzLnN0YXR1cyA9ICdtaXNzaW5nJztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBjb3VudCA9IHJldnMubGVuZ3RoO1xuICAgICAgcmV2cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc2VxU3RvcmUuaW5kZXgoJ19kb2NfaWRfcmV2Jyk7XG4gICAgICAgIHZhciBrZXkgPSBkb2NJZCArIFwiOjpcIiArIHJldjtcbiAgICAgICAgaW5kZXguZ2V0S2V5KGtleSkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgc2VxID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2VxICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXFTdG9yZVtcImRlbGV0ZVwiXShzZXEpO1xuXG4gICAgICAgICAgdmFyIGN1cnNvciA9IGF0dEFuZFNlcVN0b3JlLmluZGV4KCdzZXEnKVxuICAgICAgICAgICAgLm9wZW5DdXJzb3IoZ2xvYmFsLklEQktleVJhbmdlLm9ubHkoc2VxKSk7XG5cbiAgICAgICAgICBjdXJzb3Iub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgdmFyIGRpZ2VzdCA9IGN1cnNvci52YWx1ZS5kaWdlc3RTZXEuc3BsaXQoJzo6JylbMF07XG4gICAgICAgICAgICAgIHBvc3NpYmx5T3JwaGFuZWREaWdlc3RzLnB1c2goZGlnZXN0KTtcbiAgICAgICAgICAgICAgYXR0QW5kU2VxU3RvcmVbXCJkZWxldGVcIl0oY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gZG9uZVxuICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7IC8vIGRvbmUgcHJvY2Vzc2luZyBhbGwgcmV2c1xuICAgICAgICAgICAgICAgIC8vIHdpbm5pbmdSZXYgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgdGhlcmUsIHNpbmNlIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBub3QgZm9ybWFsbHkgbWlncmF0ZWQuIGRlbGV0ZWRPckxvY2FsIGlzIGFcbiAgICAgICAgICAgICAgICAvLyBub3ctdW5mb3J0dW5hdGUgbmFtZSB0aGF0IHJlYWxseSBqdXN0IG1lYW5zIFwiZGVsZXRlZFwiXG4gICAgICAgICAgICAgICAgdmFyIHdpbm5pbmdSZXYgPSBtZXRhZGF0YS53aW5uaW5nUmV2IHx8XG4gICAgICAgICAgICAgICAgICBtZXJnZS53aW5uaW5nUmV2KG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRlZCA9IG1ldGFkYXRhLmRlbGV0ZWRPckxvY2FsO1xuICAgICAgICAgICAgICAgIHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLnB1dChcbiAgICAgICAgICAgICAgICAgIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhLCB3aW5uaW5nUmV2LCBkZWxldGVkKSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlT3JwaGFuZWRBdHRhY2htZW50cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdHhuLm9uZXJyb3IgPSBpZGJFcnJvcihjYWxsYmFjayk7XG4gICAgdHhuLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB1dGlscy5jYWxsKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9O1xuXG5cbiAgYXBpLl9nZXRMb2NhbCA9IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHggPSBpZGIudHJhbnNhY3Rpb24oW0xPQ0FMX1NUT1JFXSwgJ3JlYWRvbmx5Jyk7XG4gICAgdmFyIHJlcSA9IHR4Lm9iamVjdFN0b3JlKExPQ0FMX1NUT1JFKS5nZXQoaWQpO1xuXG4gICAgcmVxLm9uZXJyb3IgPSBpZGJFcnJvcihjYWxsYmFjayk7XG4gICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZG9jID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLk1JU1NJTkdfRE9DKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBkb2NbJ19kb2NfaWRfcmV2J107XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBhcGkuX3B1dExvY2FsID0gZnVuY3Rpb24gKGRvYywgb3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgZGVsZXRlIGRvYy5fcmV2aXNpb25zOyAvLyBpZ25vcmUgdGhpcywgdHJ1c3QgdGhlIHJldlxuICAgIHZhciBvbGRSZXYgPSBkb2MuX3JldjtcbiAgICB2YXIgaWQgPSBkb2MuX2lkO1xuICAgIGlmICghb2xkUmV2KSB7XG4gICAgICBkb2MuX3JldiA9ICcwLTEnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2MuX3JldiA9ICcwLScgKyAocGFyc2VJbnQob2xkUmV2LnNwbGl0KCctJylbMV0sIDEwKSArIDEpO1xuICAgIH1cbiAgICBkb2MuX2RvY19pZF9yZXYgPSBpZCArICc6OicgKyBkb2MuX3JldjtcblxuICAgIHZhciB0eCA9IG9wdHMuY3R4O1xuICAgIHZhciByZXQ7XG4gICAgaWYgKCF0eCkge1xuICAgICAgdHggPSBpZGIudHJhbnNhY3Rpb24oW0xPQ0FMX1NUT1JFXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgdHgub25lcnJvciA9IGlkYkVycm9yKGNhbGxiYWNrKTtcbiAgICAgIHR4Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvU3RvcmUgPSB0eC5vYmplY3RTdG9yZShMT0NBTF9TVE9SRSk7XG4gICAgdmFyIHJlcTtcbiAgICBpZiAob2xkUmV2KSB7XG4gICAgICB2YXIgaW5kZXggPSBvU3RvcmUuaW5kZXgoJ19kb2NfaWRfcmV2Jyk7XG4gICAgICB2YXIgZG9jSWRSZXYgPSBpZCArICc6OicgKyBvbGRSZXY7XG4gICAgICByZXEgPSBpbmRleC5nZXQoZG9jSWRSZXYpO1xuICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS50YXJnZXQucmVzdWx0KSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3JzLlJFVl9DT05GTElDVCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHVwZGF0ZVxuICAgICAgICAgIHZhciByZXEgPSBvU3RvcmUucHV0KGRvYyk7XG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldCA9IHtvazogdHJ1ZSwgaWQ6IGRvYy5faWQsIHJldjogZG9jLl9yZXZ9O1xuICAgICAgICAgICAgaWYgKG9wdHMuY3R4KSB7IC8vIHJldHV0aGlzLmltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgeyAvLyBuZXcgZG9jXG4gICAgICByZXEgPSBvU3RvcmUuZ2V0KGlkKTtcbiAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQucmVzdWx0KSB7IC8vIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgY2FsbGJhY2soZXJyb3JzLlJFVl9DT05GTElDVCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIGluc2VydFxuICAgICAgICAgIHZhciByZXEgPSBvU3RvcmUucHV0KGRvYyk7XG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldCA9IHtvazogdHJ1ZSwgaWQ6IGRvYy5faWQsIHJldjogZG9jLl9yZXZ9O1xuICAgICAgICAgICAgaWYgKG9wdHMuY3R4KSB7IC8vIHJldHVybiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGFwaS5fcmVtb3ZlTG9jYWwgPSBmdW5jdGlvbiAoZG9jLCBjYWxsYmFjaykge1xuICAgIHZhciB0eCA9IGlkYi50cmFuc2FjdGlvbihbTE9DQUxfU1RPUkVdLCAncmVhZHdyaXRlJyk7XG4gICAgdmFyIHJldDtcbiAgICB0eC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRvY0lkUmV2ID0gZG9jLl9pZCArICc6OicgKyBkb2MuX3JldjtcbiAgICB2YXIgb1N0b3JlID0gdHgub2JqZWN0U3RvcmUoTE9DQUxfU1RPUkUpO1xuICAgIHZhciBpbmRleCA9IG9TdG9yZS5pbmRleCgnX2RvY19pZF9yZXYnKTtcbiAgICB2YXIgcmVxID0gaW5kZXguZ2V0KGRvY0lkUmV2KTtcblxuICAgIHJlcS5vbmVycm9yID0gaWRiRXJyb3IoY2FsbGJhY2spO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmICghZG9jKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycy5NSVNTSU5HX0RPQyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVxID0gaW5kZXguZ2V0S2V5KGRvY0lkUmV2KTtcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICBvU3RvcmVbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgICByZXQgPSB7b2s6IHRydWUsIGlkOiBkb2MuX2lkLCByZXY6ICcwLTAnfTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBjYWNoZWQgPSBjYWNoZWREQnNbbmFtZV07XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIGlkYiA9IGNhY2hlZC5pZGI7XG4gICAgYmxvYlN1cHBvcnQgPSBjYWNoZWQuYmxvYlN1cHBvcnQ7XG4gICAgaW5zdGFuY2VJZCA9IGNhY2hlZC5pbnN0YW5jZUlkO1xuICAgIGlkU3RvcmVkID0gY2FjaGVkLmlkU3RvcmVkO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgYXBpKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVxID0gZ2xvYmFsLmluZGV4ZWREQi5vcGVuKG5hbWUsIEFEQVBURVJfVkVSU0lPTik7XG5cbiAgaWYgKCEoJ29wZW5SZXFMaXN0JyBpbiBJZGJQb3VjaCkpIHtcbiAgICBJZGJQb3VjaC5vcGVuUmVxTGlzdCA9IHt9O1xuICB9XG4gIElkYlBvdWNoLm9wZW5SZXFMaXN0W25hbWVdID0gcmVxO1xuXG4gIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkYiA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICBpZiAoZS5vbGRWZXJzaW9uIDwgMSkge1xuICAgICAgY3JlYXRlU2NoZW1hKGRiKTsgLy8gbmV3IGRiLCBpbml0aWFsIHNjaGVtYVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwcm9taXNlcyB3b3VsZCBiZSBncmVhdCBoZXJlLCBJbmRleGVkREIuID5fPFxuICAgIHZhciB0eG4gPSBlLmN1cnJlbnRUYXJnZXQudHJhbnNhY3Rpb247XG4gICAgaWYgKGUub2xkVmVyc2lvbiA8IDQpIHtcbiAgICAgIGFkZEF0dGFjaEFuZFNlcVN0b3JlKGRiKTsgLy8gdjRcbiAgICAgIGlmIChlLm9sZFZlcnNpb24gPCAzKSB7XG4gICAgICAgIGNyZWF0ZUxvY2FsU3RvcmVTY2hlbWEoZGIpOyAvLyB2M1xuICAgICAgICBpZiAoZS5vbGRWZXJzaW9uIDwgMikge1xuICAgICAgICAgIGFkZERlbGV0ZWRPckxvY2FsSW5kZXgodHhuLCBmdW5jdGlvbiAoKSB7IC8vIHYyXG4gICAgICAgICAgICBtaWdyYXRlTG9jYWxTdG9yZSh0eG4sIGZ1bmN0aW9uICgpIHsgLy8gdjNcbiAgICAgICAgICAgICAgbWlncmF0ZUF0dHNBbmRTZXFzKHR4bik7IC8vIHY0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaWdyYXRlTG9jYWxTdG9yZSh0eG4sIGZ1bmN0aW9uICgpIHsgLy8gdjNcbiAgICAgICAgICAgIG1pZ3JhdGVBdHRzQW5kU2Vxcyh0eG4pOyAvLyB2NFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaWdyYXRlQXR0c0FuZFNlcXModHhuKTsgLy8gdjRcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICBpZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICBpZGIub252ZXJzaW9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWRiLmNsb3NlKCk7XG4gICAgICBkZWxldGUgY2FjaGVkREJzW25hbWVdO1xuICAgIH07XG4gICAgaWRiLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZGIuY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSBjYWNoZWREQnNbbmFtZV07XG4gICAgfTtcblxuICAgIHZhciB0eG4gPSBpZGIudHJhbnNhY3Rpb24oW01FVEFfU1RPUkUsIERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkVdLFxuICAgICAgJ3JlYWR3cml0ZScpO1xuXG4gICAgdmFyIHJlcSA9IHR4bi5vYmplY3RTdG9yZShNRVRBX1NUT1JFKS5nZXQoTUVUQV9TVE9SRSk7XG5cbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcblxuICAgICAgdmFyIGNoZWNrU2V0dXBDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGJsb2JTdXBwb3J0ID09PSBudWxsIHx8ICFpZFN0b3JlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZWREQnNbbmFtZV0gPSB7XG4gICAgICAgICAgICBpZGI6IGlkYixcbiAgICAgICAgICAgIGJsb2JTdXBwb3J0OiBibG9iU3VwcG9ydCxcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlSWQsXG4gICAgICAgICAgICBpZFN0b3JlZDogaWRTdG9yZWQsXG4gICAgICAgICAgICBsb2FkZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGFwaSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtZXRhID0gZS50YXJnZXQucmVzdWx0IHx8IHtpZDogTUVUQV9TVE9SRX07XG4gICAgICBpZiAobmFtZSAgKyAnX2lkJyBpbiBtZXRhKSB7XG4gICAgICAgIGluc3RhbmNlSWQgPSBtZXRhW25hbWUgKyAnX2lkJ107XG4gICAgICAgIGlkU3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgY2hlY2tTZXR1cENvbXBsZXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZUlkID0gdXRpbHMudXVpZCgpO1xuICAgICAgICBtZXRhW25hbWUgKyAnX2lkJ10gPSBpbnN0YW5jZUlkO1xuICAgICAgICB0eG4ub2JqZWN0U3RvcmUoTUVUQV9TVE9SRSkucHV0KG1ldGEpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZFN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgY2hlY2tTZXR1cENvbXBsZXRlKCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIERldGVjdCBibG9iIHN1cHBvcnQuIENocm9tZSBkaWRuJ3Qgc3VwcG9ydCBpdCB1bnRpbCB2ZXJzaW9uIDM4LlxuICAgICAgLy8gaW4gdmVyc2lvbiAzNyB0aGV5IGhhZCBhIGJyb2tlbiB2ZXJzaW9uIHdoZXJlIFBOR3MgKGFuZCBwb3NzaWJseVxuICAgICAgLy8gb3RoZXIgYmluYXJ5IHR5cGVzKSBhcmVuJ3Qgc3RvcmVkIGNvcnJlY3RseS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBibG9iID0gdXRpbHMuY3JlYXRlQmxvYihbJyddLCB7dHlwZTogJ2ltYWdlL3BuZyd9KTtcbiAgICAgICAgdHhuLm9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpLnB1dChibG9iLCAna2V5Jyk7XG4gICAgICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGhhdmUgdG8gZG8gaXQgaW4gYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbiwgZWxzZSB0aGUgY29ycmVjdFxuICAgICAgICAgIC8vIGNvbnRlbnQgdHlwZSBpcyBhbHdheXMgcmV0dXJuZWRcbiAgICAgICAgICB0eG4gPSBpZGIudHJhbnNhY3Rpb24oW01FVEFfU1RPUkUsIERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkVdLFxuICAgICAgICAgICAgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgIHZhciBnZXRCbG9iUmVxID0gdHhuLm9iamVjdFN0b3JlKFxuICAgICAgICAgICAgREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSkuZ2V0KCdrZXknKTtcbiAgICAgICAgICBnZXRCbG9iUmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVkQmxvYiA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0b3JlZEJsb2IpO1xuICAgICAgICAgICAgdXRpbHMuYWpheCh7XG4gICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuc3RhdHVzID09PSA0MDUpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJlZm94IHdvbid0IGxldCB1cyBkbyB0aGF0LiBidXQgZmlyZWZveCBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0aGUgYmxvYiB0eXBlIGJ1ZyB0aGF0IENocm9tZSBkb2VzLCBzbyB0aGF0J3Mgb2tcbiAgICAgICAgICAgICAgICBibG9iU3VwcG9ydCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmxvYlN1cHBvcnQgPSAhIShyZXMgJiYgcmVzLnR5cGUgPT09ICdpbWFnZS9wbmcnKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgdXRpbHMuZXhwbGFpbjQwNChcbiAgICAgICAgICAgICAgICAgICAgJ1BvdWNoREIgaXMganVzdCBkZXRlY3RpbmcgYmxvYiBVUkwgc3VwcG9ydC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgICBjaGVja1NldHVwQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYmxvYlN1cHBvcnQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tTZXR1cENvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICByZXEub25lcnJvciA9IGlkYkVycm9yKGNhbGxiYWNrKTtcblxufVxuXG5JZGJQb3VjaC52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSXNzdWUgIzI1MzMsIHdlIGZpbmFsbHkgZ2F2ZSB1cCBvbiBkb2luZyBidWdcbiAgLy8gZGV0ZWN0aW9uIGluc3RlYWQgb2YgYnJvd3NlciBzbmlmZmluZy4gU2FmYXJpIGJyb3VnaHQgdXNcbiAgLy8gdG8gb3VyIGtuZWVzLlxuICB2YXIgaXNTYWZhcmkgPSB0eXBlb2Ygb3BlbkRhdGFiYXNlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAhL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAvLyBzb21lIG91dGRhdGVkIGltcGxlbWVudGF0aW9ucyBvZiBJREIgdGhhdCBhcHBlYXIgb24gU2Ftc3VuZ1xuICAvLyBhbmQgSFRDIEFuZHJvaWQgZGV2aWNlcyA8NC40IGFyZSBtaXNzaW5nIElEQktleVJhbmdlXG4gIHJldHVybiAhaXNTYWZhcmkgJiYgZ2xvYmFsLmluZGV4ZWREQiAmJiBnbG9iYWwuSURCS2V5UmFuZ2U7XG59O1xuXG5mdW5jdGlvbiBkZXN0cm95KG5hbWUsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICghKCdvcGVuUmVxTGlzdCcgaW4gSWRiUG91Y2gpKSB7XG4gICAgSWRiUG91Y2gub3BlblJlcUxpc3QgPSB7fTtcbiAgfVxuICBJZGJQb3VjaC5DaGFuZ2VzLnJlbW92ZUFsbExpc3RlbmVycyhuYW1lKTtcblxuICAvL0Nsb3NlIG9wZW4gcmVxdWVzdCBmb3IgXCJuYW1lXCIgZGF0YWJhc2UgdG8gZml4IGllIGRlbGF5LlxuICBpZiAoSWRiUG91Y2gub3BlblJlcUxpc3RbbmFtZV0gJiYgSWRiUG91Y2gub3BlblJlcUxpc3RbbmFtZV0ucmVzdWx0KSB7XG4gICAgSWRiUG91Y2gub3BlblJlcUxpc3RbbmFtZV0ucmVzdWx0LmNsb3NlKCk7XG4gIH1cbiAgdmFyIHJlcSA9IGdsb2JhbC5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG5cbiAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL1JlbW92ZSBvcGVuIHJlcXVlc3QgZnJvbSB0aGUgbGlzdC5cbiAgICBpZiAoSWRiUG91Y2gub3BlblJlcUxpc3RbbmFtZV0pIHtcbiAgICAgIElkYlBvdWNoLm9wZW5SZXFMaXN0W25hbWVdID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmhhc0xvY2FsU3RvcmFnZSgpICYmIChuYW1lIGluIGdsb2JhbC5sb2NhbFN0b3JhZ2UpKSB7XG4gICAgICBkZWxldGUgZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgICB9XG4gICAgZGVsZXRlIGNhY2hlZERCc1tuYW1lXTtcbiAgICBjYWxsYmFjayhudWxsLCB7ICdvayc6IHRydWUgfSk7XG4gIH07XG5cbiAgcmVxLm9uZXJyb3IgPSBpZGJFcnJvcihjYWxsYmFjayk7XG59XG5cbklkYlBvdWNoLmRlc3Ryb3kgPSB1dGlscy50b1Byb21pc2UoZnVuY3Rpb24gKG5hbWUsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIHRhc2tRdWV1ZS5xdWV1ZS5wdXNoKHtcbiAgICBhY3Rpb246IGZ1bmN0aW9uICh0aGlzQ2FsbGJhY2spIHtcbiAgICAgIGRlc3Ryb3kobmFtZSwgb3B0cywgdGhpc0NhbGxiYWNrKTtcbiAgICB9LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbiAgYXBwbHlOZXh0KCk7XG59KTtcblxuSWRiUG91Y2guQ2hhbmdlcyA9IG5ldyB1dGlscy5DaGFuZ2VzKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSWRiUG91Y2g7XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL1VzZXJzL2RhbGVoYXJ2ZXkvc3JjL3BvdWNoZGIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vZGVwcy9lcnJvcnNcIjoxMixcIi4uL21lcmdlXCI6MjEsXCIuLi91dGlsc1wiOjI2LFwiL1VzZXJzL2RhbGVoYXJ2ZXkvc3JjL3BvdWNoZGIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCI6MzEsXCJ2dXZ1emVsYVwiOjYxfV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFsnaWRiJywgJ3dlYnNxbCddO1xufSx7fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzJyk7XG52YXIgbWVyZ2UgPSBfZGVyZXFfKCcuLi9tZXJnZScpO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oJy4uL2RlcHMvZXJyb3JzJyk7XG52YXIgdnV2dXplbGEgPSBfZGVyZXFfKCd2dXZ1emVsYScpO1xudmFyIHBhcnNlSGV4U3RyaW5nID0gX2RlcmVxXygnLi4vZGVwcy9wYXJzZS1oZXgnKTtcblxuZnVuY3Rpb24gcXVvdGUoc3RyKSB7XG4gIHJldHVybiBcIidcIiArIHN0ciArIFwiJ1wiO1xufVxuXG4vLyBlc2NhcGVCbG9iIGFuZCB1bmVzY2FwZUJsb2IgYXJlIHdvcmthcm91bmRzIGZvciBhIHdlYnNxbCBidWc6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDIyNjkwXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3NjM3XG4vLyBUaGUgZ29hbCBpcyB0byBuZXZlciBhY3R1YWxseSBpbnNlcnQgdGhlIFxcdTAwMDAgY2hhcmFjdGVyXG4vLyBpbiB0aGUgZGF0YWJhc2UuXG5mdW5jdGlvbiBlc2NhcGVCbG9iKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoL1xcdTAwMDIvZywgJ1xcdTAwMDJcXHUwMDAyJylcbiAgICAucmVwbGFjZSgvXFx1MDAwMS9nLCAnXFx1MDAwMVxcdTAwMDInKVxuICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICdcXHUwMDAxXFx1MDAwMScpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUJsb2Ioc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZSgvXFx1MDAwMVxcdTAwMDEvZywgJ1xcdTAwMDAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMDAxXFx1MDAwMi9nLCAnXFx1MDAwMScpXG4gICAgLnJlcGxhY2UoL1xcdTAwMDJcXHUwMDAyL2csICdcXHUwMDAyJyk7XG59XG5cbnZhciBjYWNoZWREYXRhYmFzZXMgPSB7fTtcblxudmFyIG9wZW5EQiA9IHV0aWxzLmdldEFyZ3VtZW50cyhmdW5jdGlvbiAoYXJncykge1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnNxbGl0ZVBsdWdpbiAmJlxuICAgICAgICBnbG9iYWwubmF2aWdhdG9yLnNxbGl0ZVBsdWdpbi5vcGVuRGF0YWJhc2UpIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3Iuc3FsaXRlUGx1Z2luLm9wZW5EYXRhYmFzZVxuICAgICAgICAuYXBwbHkobmF2aWdhdG9yLnNxbGl0ZVBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuc3FsaXRlUGx1Z2luICYmIGdsb2JhbC5zcWxpdGVQbHVnaW4ub3BlbkRhdGFiYXNlKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsLnNxbGl0ZVBsdWdpbi5vcGVuRGF0YWJhc2VcbiAgICAgICAgLmFwcGx5KGdsb2JhbC5zcWxpdGVQbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGIgPSBjYWNoZWREYXRhYmFzZXNbYXJnc1swXV07XG4gICAgICBpZiAoIWRiKSB7XG4gICAgICAgIGRiID0gY2FjaGVkRGF0YWJhc2VzW2FyZ3NbMF1dID1cbiAgICAgICAgICBnbG9iYWwub3BlbkRhdGFiYXNlLmFwcGx5KGdsb2JhbCwgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGI7XG4gICAgfVxuICB9XG59KTtcblxudmFyIFBPVUNIX1ZFUlNJT04gPSAxO1xudmFyIEFEQVBURVJfVkVSU0lPTiA9IDY7IC8vIHVzZWQgdG8gbWFuYWdlIG1pZ3JhdGlvbnNcblxuLy8gVGhlIG9iamVjdCBzdG9yZXMgY3JlYXRlZCBmb3IgZWFjaCBkYXRhYmFzZVxuLy8gRE9DX1NUT1JFIHN0b3JlcyB0aGUgZG9jdW1lbnQgbWV0YSBkYXRhLCBpdHMgcmV2aXNpb24gaGlzdG9yeSBhbmQgc3RhdGVcbnZhciBET0NfU1RPUkUgPSBxdW90ZSgnZG9jdW1lbnQtc3RvcmUnKTtcbi8vIEJZX1NFUV9TVE9SRSBzdG9yZXMgYSBwYXJ0aWN1bGFyIHZlcnNpb24gb2YgYSBkb2N1bWVudCwga2V5ZWQgYnkgaXRzXG4vLyBzZXF1ZW5jZSBpZFxudmFyIEJZX1NFUV9TVE9SRSA9IHF1b3RlKCdieS1zZXF1ZW5jZScpO1xuLy8gV2hlcmUgd2Ugc3RvcmUgYXR0YWNobWVudHNcbnZhciBBVFRBQ0hfU1RPUkUgPSBxdW90ZSgnYXR0YWNoLXN0b3JlJyk7XG52YXIgTE9DQUxfU1RPUkUgPSBxdW90ZSgnbG9jYWwtc3RvcmUnKTtcbnZhciBNRVRBX1NUT1JFID0gcXVvdGUoJ21ldGFkYXRhLXN0b3JlJyk7XG4vLyB3aGVyZSB3ZSBzdG9yZSBtYW55LXRvLW1hbnkgcmVsYXRpb25zIGJldHdlZW4gYXR0YWNobWVudFxuLy8gZGlnZXN0cyBhbmQgc2Vxc1xudmFyIEFUVEFDSF9BTkRfU0VRX1NUT1JFID0gcXVvdGUoJ2F0dGFjaC1zZXEtc3RvcmUnKTtcblxuLy8gdGhlc2UgaW5kZXhlcyBjb3ZlciB0aGUgZ3JvdW5kIGZvciBtb3N0IGFsbERvY3MgcXVlcmllc1xudmFyIEJZX1NFUV9TVE9SRV9ERUxFVEVEX0lOREVYX1NRTCA9XG4gICdDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBcXCdieS1zZXEtZGVsZXRlZC1pZHhcXCcgT04gJyArXG4gIEJZX1NFUV9TVE9SRSArICcgKHNlcSwgZGVsZXRlZCknO1xudmFyIEJZX1NFUV9TVE9SRV9ET0NfSURfUkVWX0lOREVYX1NRTCA9XG4gICdDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFMgXFwnYnktc2VxLWRvYy1pZC1yZXZcXCcgT04gJyArXG4gICAgQllfU0VRX1NUT1JFICsgJyAoZG9jX2lkLCByZXYpJztcbnZhciBET0NfU1RPUkVfV0lOTklOR1NFUV9JTkRFWF9TUUwgPVxuICAnQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgXFwnZG9jLXdpbm5pbmdzZXEtaWR4XFwnIE9OICcgK1xuICBET0NfU1RPUkUgKyAnICh3aW5uaW5nc2VxKSc7XG52YXIgQVRUQUNIX0FORF9TRVFfU1RPUkVfU0VRX0lOREVYX1NRTCA9XG4gICdDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBcXCdhdHRhY2gtc2VxLXNlcS1pZHhcXCcgT04gJyArXG4gICAgQVRUQUNIX0FORF9TRVFfU1RPUkUgKyAnIChzZXEpJztcbnZhciBBVFRBQ0hfQU5EX1NFUV9TVE9SRV9BVFRBQ0hfSU5ERVhfU1FMID1cbiAgJ0NSRUFURSBVTklRVUUgSU5ERVggSUYgTk9UIEVYSVNUUyBcXCdhdHRhY2gtc2VxLWRpZ2VzdC1pZHhcXCcgT04gJyArXG4gICAgQVRUQUNIX0FORF9TRVFfU1RPUkUgKyAnIChkaWdlc3QsIHNlcSknO1xuXG52YXIgRE9DX1NUT1JFX0FORF9CWV9TRVFfSk9JTkVSID0gQllfU0VRX1NUT1JFICtcbiAgJy5zZXEgPSAnICsgRE9DX1NUT1JFICsgJy53aW5uaW5nc2VxJztcblxudmFyIFNFTEVDVF9ET0NTID0gQllfU0VRX1NUT1JFICsgJy5zZXEgQVMgc2VxLCAnICtcbiAgQllfU0VRX1NUT1JFICsgJy5kZWxldGVkIEFTIGRlbGV0ZWQsICcgK1xuICBCWV9TRVFfU1RPUkUgKyAnLmpzb24gQVMgZGF0YSwgJyArXG4gIEJZX1NFUV9TVE9SRSArICcucmV2IEFTIHJldiwgJyArXG4gIERPQ19TVE9SRSArICcuanNvbiBBUyBtZXRhZGF0YSc7XG5cbmZ1bmN0aW9uIHNlbGVjdChzZWxlY3RvciwgdGFibGUsIGpvaW5lciwgd2hlcmUsIG9yZGVyQnkpIHtcbiAgcmV0dXJuICdTRUxFQ1QgJyArIHNlbGVjdG9yICsgJyBGUk9NICcgK1xuICAgICh0eXBlb2YgdGFibGUgPT09ICdzdHJpbmcnID8gdGFibGUgOiB0YWJsZS5qb2luKCcgSk9JTiAnKSkgK1xuICAgIChqb2luZXIgPyAoJyBPTiAnICsgam9pbmVyKSA6ICcnKSArXG4gICAgKHdoZXJlID8gKCcgV0hFUkUgJyArXG4gICAgICAodHlwZW9mIHdoZXJlID09PSAnc3RyaW5nJyA/IHdoZXJlIDogd2hlcmUuam9pbignIEFORCAnKSkpIDogJycpICtcbiAgICAob3JkZXJCeSA/ICgnIE9SREVSIEJZICcgKyBvcmRlckJ5KSA6ICcnKTtcbn1cblxuZnVuY3Rpb24gdW5rbm93bkVycm9yKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBldmVudCBtYXkgYWN0dWFsbHkgYmUgYSBTUUxFcnJvciBvYmplY3QsIHNvIHJlcG9ydCBpcyBhcyBzdWNoXG4gICAgdmFyIGVycm9yTmFtZU1hdGNoID0gZXZlbnQgJiYgZXZlbnQuY29uc3RydWN0b3IudG9TdHJpbmcoKVxuICAgICAgLm1hdGNoKC9mdW5jdGlvbiAoW15cXChdKykvKTtcbiAgICB2YXIgZXJyb3JOYW1lID0gKGVycm9yTmFtZU1hdGNoICYmIGVycm9yTmFtZU1hdGNoWzFdKSB8fCBldmVudC50eXBlO1xuICAgIHZhciBlcnJvclJlYXNvbiA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5tZXNzYWdlO1xuICAgIGNhbGxiYWNrKGVycm9ycy5lcnJvcihlcnJvcnMuV1NRX0VSUk9SLCBlcnJvclJlYXNvbiwgZXJyb3JOYW1lKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvYyhkb2MpIHtcbiAgLy8gZG9uJ3QgYm90aGVyIHN0b3JpbmcgdGhlIGlkL3Jldi4gaXQgdXNlcyBsb3RzIG9mIHNwYWNlLFxuICAvLyBpbiBwZXJzaXN0ZW50IG1hcC9yZWR1Y2UgZXNwZWNpYWxseVxuICBkZWxldGUgZG9jLl9pZDtcbiAgZGVsZXRlIGRvYy5fcmV2O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZG9jKTtcbn1cblxuZnVuY3Rpb24gdW5zdHJpbmdpZnlEb2MoZG9jLCBpZCwgcmV2KSB7XG4gIGRvYyA9IEpTT04ucGFyc2UoZG9jKTtcbiAgZG9jLl9pZCA9IGlkO1xuICBkb2MuX3JldiA9IHJldjtcbiAgcmV0dXJuIGRvYztcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShvcHRzKSB7XG4gIGlmICgnc2l6ZScgaW4gb3B0cykge1xuICAgIC8vIHRyaWdnZXJzIGltbWVkaWF0ZSBwb3B1cCBpbiBpT1MsIGZpeGVzICMyMzQ3XG4gICAgLy8gZS5nLiA1MDAwMDAxIGFza3MgZm9yIDUgTUIsIDEwMDAwMDAxIGFza3MgZm9yIDEwIE1CLFxuICAgIHJldHVybiBvcHRzLnNpemUgKiAxMDAwMDAwO1xuICB9XG4gIC8vIEluIGlPUywgZG9lc24ndCBtYXR0ZXIgYXMgbG9uZyBhcyBpdCdzIDw9IDUwMDAwMDAuXG4gIC8vIEV4Y2VwdCB0aGF0IGlmIHlvdSByZXF1ZXN0IHRvbyBtdWNoLCBvdXIgdGVzdHMgZmFpbFxuICAvLyBiZWNhdXNlIG9mIHRoZSBuYXRpdmUgXCJkbyB5b3UgYWNjZXB0P1wiIHBvcHVwLlxuICAvLyBJbiBBbmRyb2lkIDw9NC4zLCB0aGlzIHZhbHVlIGlzIGFjdHVhbGx5IHVzZWQgYXMgYW5cbiAgLy8gaG9uZXN0LXRvLWdvZCBjZWlsaW5nIGZvciBkYXRhLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIHNldCBpdCB0byBhIGRlY2VudGx5IGhpZ2ggbnVtYmVyLlxuICB2YXIgaXNBbmRyb2lkID0gL0FuZHJvaWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICByZXR1cm4gaXNBbmRyb2lkID8gNTAwMDAwMCA6IDE7IC8vIGluIFBoYW50b21KUywgaWYgeW91IHVzZSAwIGl0IHdpbGwgY3Jhc2hcbn1cblxuZnVuY3Rpb24gV2ViU3FsUG91Y2gob3B0cywgY2FsbGJhY2spIHtcbiAgdmFyIGFwaSA9IHRoaXM7XG4gIHZhciBpbnN0YW5jZUlkID0gbnVsbDtcbiAgdmFyIG5hbWUgPSBvcHRzLm5hbWU7XG4gIHZhciBzaXplID0gZ2V0U2l6ZShvcHRzKTtcbiAgdmFyIGlkUmVxdWVzdHMgPSBbXTtcbiAgdmFyIGRvY0NvdW50ID0gLTE7IC8vIGNhY2hlIHNxbGl0ZSBjb3VudCgqKSBmb3IgcGVyZm9ybWFuY2VcbiAgdmFyIGVuY29kaW5nO1xuXG4gIHZhciBkYiA9IG9wZW5EQihuYW1lLCBQT1VDSF9WRVJTSU9OLCBuYW1lLCBzaXplKTtcbiAgaWYgKCFkYikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuVU5LTk9XTl9FUlJPUik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRiLnJlYWRUcmFuc2FjdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGRvZXNuJ3QgZXhpc3QgaW4gc3FsaXRlIHBsdWdpblxuICAgIGRiLnJlYWRUcmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGJDcmVhdGVkKCkge1xuICAgIC8vIG5vdGUgdGhlIGRiIG5hbWUgaW4gY2FzZSB0aGUgYnJvd3NlciB1cGdyYWRlcyB0byBpZGJcbiAgICBpZiAodXRpbHMuaGFzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2VbJ19wb3VjaF9fd2Vic3FsZGJfJyArIG5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgYXBpKTtcbiAgfVxuXG4gIC8vIEluIHRoaXMgbWlncmF0aW9uLCB3ZSBhZGRlZCB0aGUgJ2RlbGV0ZWQnIGFuZCAnbG9jYWwnIGNvbHVtbnMgdG8gdGhlXG4gIC8vIGJ5LXNlcSBhbmQgZG9jIHN0b3JlIHRhYmxlcy5cbiAgLy8gVG8gcHJlc2VydmUgZXhpc3RpbmcgdXNlciBkYXRhLCB3ZSByZS1wcm9jZXNzIGFsbCB0aGUgZXhpc3RpbmcgSlNPTlxuICAvLyBhbmQgYWRkIHRoZXNlIHZhbHVlcy5cbiAgLy8gQ2FsbGVkIG1pZ3JhdGlvbjIgYmVjYXVzZSBpdCBjb3JyZXNwb25kcyB0byBhZGFwdGVyIHZlcnNpb24gKGRiX3ZlcnNpb24pICMyXG4gIGZ1bmN0aW9uIHJ1bk1pZ3JhdGlvbjIodHgsIGNhbGxiYWNrKSB7XG4gICAgLy8gaW5kZXggdXNlZCBmb3IgdGhlIGpvaW4gaW4gdGhlIGFsbERvY3MgcXVlcnlcbiAgICB0eC5leGVjdXRlU3FsKERPQ19TVE9SRV9XSU5OSU5HU0VRX0lOREVYX1NRTCk7XG5cbiAgICB0eC5leGVjdXRlU3FsKCdBTFRFUiBUQUJMRSAnICsgQllfU0VRX1NUT1JFICtcbiAgICAgICcgQUREIENPTFVNTiBkZWxldGVkIFRJTllJTlQoMSkgREVGQVVMVCAwJywgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHR4LmV4ZWN1dGVTcWwoQllfU0VRX1NUT1JFX0RFTEVURURfSU5ERVhfU1FMKTtcbiAgICAgIHR4LmV4ZWN1dGVTcWwoJ0FMVEVSIFRBQkxFICcgKyBET0NfU1RPUkUgK1xuICAgICAgICAnIEFERCBDT0xVTU4gbG9jYWwgVElOWUlOVCgxKSBERUZBVUxUIDAnLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0eC5leGVjdXRlU3FsKCdDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBcXCdkb2Mtc3RvcmUtbG9jYWwtaWR4XFwnIE9OICcgK1xuICAgICAgICAgIERPQ19TVE9SRSArICcgKGxvY2FsLCBpZCknKTtcblxuICAgICAgICB2YXIgc3FsID0gJ1NFTEVDVCAnICsgRE9DX1NUT1JFICsgJy53aW5uaW5nc2VxIEFTIHNlcSwgJyArIERPQ19TVE9SRSArXG4gICAgICAgICAgJy5qc29uIEFTIG1ldGFkYXRhIEZST00gJyArIEJZX1NFUV9TVE9SRSArICcgSk9JTiAnICsgRE9DX1NUT1JFICtcbiAgICAgICAgICAnIE9OICcgKyBCWV9TRVFfU1RPUkUgKyAnLnNlcSA9ICcgKyBET0NfU1RPUkUgKyAnLndpbm5pbmdzZXEnO1xuXG4gICAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBbXSwgZnVuY3Rpb24gKHR4LCByZXN1bHQpIHtcblxuICAgICAgICAgIHZhciBkZWxldGVkID0gW107XG4gICAgICAgICAgdmFyIGxvY2FsID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHJlc3VsdC5yb3dzLml0ZW0oaSk7XG4gICAgICAgICAgICB2YXIgc2VxID0gaXRlbS5zZXE7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBKU09OLnBhcnNlKGl0ZW0ubWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRGVsZXRlZChtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlZC5wdXNoKHNlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXRpbHMuaXNMb2NhbElkKG1ldGFkYXRhLmlkKSkge1xuICAgICAgICAgICAgICBsb2NhbC5wdXNoKG1ldGFkYXRhLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHguZXhlY3V0ZVNxbCgnVVBEQVRFICcgKyBET0NfU1RPUkUgKyAnU0VUIGxvY2FsID0gMSBXSEVSRSBpZCBJTiAoJyArXG4gICAgICAgICAgICBsb2NhbC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICc/JztcbiAgICAgICAgICB9KS5qb2luKCcsJykgKyAnKScsIGxvY2FsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0eC5leGVjdXRlU3FsKCdVUERBVEUgJyArIEJZX1NFUV9TVE9SRSArXG4gICAgICAgICAgICAgICcgU0VUIGRlbGV0ZWQgPSAxIFdIRVJFIHNlcSBJTiAoJyArIGRlbGV0ZWQubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICc/JztcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKSArICcpJywgZGVsZXRlZCwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaW4gdGhpcyBtaWdyYXRpb24sIHdlIG1ha2UgYWxsIHRoZSBsb2NhbCBkb2NzIHVudmVyc2lvbmVkXG4gIGZ1bmN0aW9uIHJ1bk1pZ3JhdGlvbjModHgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxvY2FsID0gJ0NSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTICcgKyBMT0NBTF9TVE9SRSArXG4gICAgICAnIChpZCBVTklRVUUsIHJldiwganNvbiknO1xuICAgIHR4LmV4ZWN1dGVTcWwobG9jYWwsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3FsID0gJ1NFTEVDVCAnICsgRE9DX1NUT1JFICsgJy5pZCBBUyBpZCwgJyArXG4gICAgICAgIEJZX1NFUV9TVE9SRSArICcuanNvbiBBUyBkYXRhICcgK1xuICAgICAgICAnRlJPTSAnICsgQllfU0VRX1NUT1JFICsgJyBKT0lOICcgK1xuICAgICAgICBET0NfU1RPUkUgKyAnIE9OICcgKyBCWV9TRVFfU1RPUkUgKyAnLnNlcSA9ICcgK1xuICAgICAgICBET0NfU1RPUkUgKyAnLndpbm5pbmdzZXEgV0hFUkUgbG9jYWwgPSAxJztcbiAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBbXSwgZnVuY3Rpb24gKHR4LCByZXMpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJvd3MucHVzaChyZXMucm93cy5pdGVtKGkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkb05leHQoKSB7XG4gICAgICAgICAgaWYgKCFyb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJvdyA9IHJvd3Muc2hpZnQoKTtcbiAgICAgICAgICB2YXIgcmV2ID0gSlNPTi5wYXJzZShyb3cuZGF0YSkuX3JldjtcbiAgICAgICAgICB0eC5leGVjdXRlU3FsKCdJTlNFUlQgSU5UTyAnICsgTE9DQUxfU1RPUkUgK1xuICAgICAgICAgICAgICAnIChpZCwgcmV2LCBqc29uKSBWQUxVRVMgKD8sPyw/KScsXG4gICAgICAgICAgICAgIFtyb3cuaWQsIHJldiwgcm93LmRhdGFdLCBmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgIHR4LmV4ZWN1dGVTcWwoJ0RFTEVURSBGUk9NICcgKyBET0NfU1RPUkUgKyAnIFdIRVJFIGlkPT8nLFxuICAgICAgICAgICAgICAgIFtyb3cuaWRdLCBmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgdHguZXhlY3V0ZVNxbCgnREVMRVRFIEZST00gJyArIEJZX1NFUV9TVE9SRSArICcgV0hFUkUgc2VxPT8nLFxuICAgICAgICAgICAgICAgICAgW3Jvdy5zZXFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9OZXh0KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9OZXh0KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGluIHRoaXMgbWlncmF0aW9uLCB3ZSByZW1vdmUgZG9jX2lkX3JldiBhbmQganVzdCB1c2UgcmV2XG4gIGZ1bmN0aW9uIHJ1bk1pZ3JhdGlvbjQodHgsIGNhbGxiYWNrKSB7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVSb3dzKHJvd3MpIHtcbiAgICAgIGZ1bmN0aW9uIGRvTmV4dCgpIHtcbiAgICAgICAgaWYgKCFyb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IHJvd3Muc2hpZnQoKTtcbiAgICAgICAgdmFyIGRvY19pZF9yZXYgPSBwYXJzZUhleFN0cmluZyhyb3cuaGV4LCBlbmNvZGluZyk7XG4gICAgICAgIHZhciBpZHggPSBkb2NfaWRfcmV2Lmxhc3RJbmRleE9mKCc6OicpO1xuICAgICAgICB2YXIgZG9jX2lkID0gZG9jX2lkX3Jldi5zdWJzdHJpbmcoMCwgaWR4KTtcbiAgICAgICAgdmFyIHJldiA9IGRvY19pZF9yZXYuc3Vic3RyaW5nKGlkeCArIDIpO1xuICAgICAgICB2YXIgc3FsID0gJ1VQREFURSAnICsgQllfU0VRX1NUT1JFICtcbiAgICAgICAgICAnIFNFVCBkb2NfaWQ9PywgcmV2PT8gV0hFUkUgZG9jX2lkX3Jldj0/JztcbiAgICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIFtkb2NfaWQsIHJldiwgZG9jX2lkX3Jldl0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkb05leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkb05leHQoKTtcbiAgICB9XG5cbiAgICB2YXIgc3FsID0gJ0FMVEVSIFRBQkxFICcgKyBCWV9TRVFfU1RPUkUgKyAnIEFERCBDT0xVTU4gZG9jX2lkJztcbiAgICB0eC5leGVjdXRlU3FsKHNxbCwgW10sIGZ1bmN0aW9uICh0eCkge1xuICAgICAgdmFyIHNxbCA9ICdBTFRFUiBUQUJMRSAnICsgQllfU0VRX1NUT1JFICsgJyBBREQgQ09MVU1OIHJldic7XG4gICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW10sIGZ1bmN0aW9uICh0eCkge1xuICAgICAgICB0eC5leGVjdXRlU3FsKEJZX1NFUV9TVE9SRV9ET0NfSURfUkVWX0lOREVYX1NRTCwgW10sIGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgIHZhciBzcWwgPSAnU0VMRUNUIGhleChkb2NfaWRfcmV2KSBhcyBoZXggRlJPTSAnICsgQllfU0VRX1NUT1JFO1xuICAgICAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBbXSwgZnVuY3Rpb24gKHR4LCByZXMpIHtcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHJvd3MucHVzaChyZXMucm93cy5pdGVtKGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVJvd3Mocm93cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBpbiB0aGlzIG1pZ3JhdGlvbiwgd2UgYWRkIHRoZSBhdHRhY2hfYW5kX3NlcSB0YWJsZVxuICAvLyBmb3IgaXNzdWUgIzI4MThcbiAgZnVuY3Rpb24gcnVuTWlncmF0aW9uNSh0eCwgY2FsbGJhY2spIHtcblxuICAgIGZ1bmN0aW9uIG1pZ3JhdGVBdHRzQW5kU2Vxcyh0eCkge1xuICAgICAgLy8gbmVlZCB0byBhY3R1YWxseSBwb3B1bGF0ZSB0aGUgdGFibGUuIHRoaXMgaXMgdGhlIGV4cGVuc2l2ZSBwYXJ0LFxuICAgICAgLy8gc28gYXMgYW4gb3B0aW1pemF0aW9uLCBjaGVjayBmaXJzdCB0aGF0IHRoaXMgZGF0YWJhc2UgZXZlblxuICAgICAgLy8gY29udGFpbnMgYXR0YWNobWVudHNcbiAgICAgIHZhciBzcWwgPSAnU0VMRUNUIENPVU5UKCopIEFTIGNudCBGUk9NICcgKyBBVFRBQ0hfU1RPUkU7XG4gICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW10sIGZ1bmN0aW9uICh0eCwgcmVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHJlcy5yb3dzLml0ZW0oMCkuY250O1xuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgcGFnZVNpemUgPSAxMDtcbiAgICAgICAgZnVuY3Rpb24gbmV4dFBhZ2UoKSB7XG4gICAgICAgICAgdmFyIHNxbCA9IHNlbGVjdChcbiAgICAgICAgICAgIFNFTEVDVF9ET0NTICsgJywgJyArIERPQ19TVE9SRSArICcuaWQgQVMgaWQnLFxuICAgICAgICAgICAgW0RPQ19TVE9SRSwgQllfU0VRX1NUT1JFXSxcbiAgICAgICAgICAgIERPQ19TVE9SRV9BTkRfQllfU0VRX0pPSU5FUixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBET0NfU1RPUkUgKyAnLmlkICdcbiAgICAgICAgICApO1xuICAgICAgICAgIHNxbCArPSAnIExJTUlUICcgKyBwYWdlU2l6ZSArICcgT0ZGU0VUICcgKyBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ICs9IHBhZ2VTaXplO1xuICAgICAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBbXSwgZnVuY3Rpb24gKHR4LCByZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlnZXN0U2VxcyA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRkRGlnZXN0U2VxKGRpZ2VzdCwgc2VxKSB7XG4gICAgICAgICAgICAgIC8vIHVuaXEgZGlnZXN0L3NlcSBwYWlycywganVzdCBpbiBjYXNlIHRoZXJlIGFyZSBkdXBzXG4gICAgICAgICAgICAgIHZhciBzZXFzID0gZGlnZXN0U2Vxc1tkaWdlc3RdID0gKGRpZ2VzdFNlcXNbZGlnZXN0XSB8fCBbXSk7XG4gICAgICAgICAgICAgIGlmIChzZXFzLmluZGV4T2Yoc2VxKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzZXFzLnB1c2goc2VxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gcmVzLnJvd3MuaXRlbShpKTtcbiAgICAgICAgICAgICAgdmFyIGRvYyA9IHVuc3RyaW5naWZ5RG9jKHJvdy5kYXRhLCByb3cuaWQsIHJvdy5yZXYpO1xuICAgICAgICAgICAgICB2YXIgYXR0cyA9IE9iamVjdC5rZXlzKGRvYy5fYXR0YWNobWVudHMgfHwge30pO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF0dHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ID0gZG9jLl9hdHRhY2htZW50c1thdHRzW2pdXTtcbiAgICAgICAgICAgICAgICBhZGREaWdlc3RTZXEoYXR0LmRpZ2VzdCwgcm93LnNlcSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaWdlc3RTZXFQYWlycyA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlnZXN0U2VxcykuZm9yRWFjaChmdW5jdGlvbiAoZGlnZXN0KSB7XG4gICAgICAgICAgICAgIHZhciBzZXFzID0gZGlnZXN0U2Vxc1tkaWdlc3RdO1xuICAgICAgICAgICAgICBzZXFzLmZvckVhY2goZnVuY3Rpb24gKHNlcSkge1xuICAgICAgICAgICAgICAgIGRpZ2VzdFNlcVBhaXJzLnB1c2goW2RpZ2VzdCwgc2VxXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWRpZ2VzdFNlcVBhaXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dFBhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1Eb25lID0gMDtcbiAgICAgICAgICAgIGRpZ2VzdFNlcVBhaXJzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgdmFyIHNxbCA9ICdJTlNFUlQgSU5UTyAnICsgQVRUQUNIX0FORF9TRVFfU1RPUkUgK1xuICAgICAgICAgICAgICAgICcgKGRpZ2VzdCwgc2VxKSBWQUxVRVMgKD8sPyknO1xuICAgICAgICAgICAgICB0eC5leGVjdXRlU3FsKHNxbCwgcGFpciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgrK251bURvbmUgPT09IGRpZ2VzdFNlcVBhaXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgbmV4dFBhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFBhZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhdHRhY2hBbmRSZXYgPSAnQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJyArXG4gICAgICBBVFRBQ0hfQU5EX1NFUV9TVE9SRSArICcgKGRpZ2VzdCwgc2VxIElOVEVHRVIpJztcbiAgICB0eC5leGVjdXRlU3FsKGF0dGFjaEFuZFJldiwgW10sIGZ1bmN0aW9uICh0eCkge1xuICAgICAgdHguZXhlY3V0ZVNxbChcbiAgICAgICAgQVRUQUNIX0FORF9TRVFfU1RPUkVfQVRUQUNIX0lOREVYX1NRTCwgW10sIGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgIHR4LmV4ZWN1dGVTcWwoXG4gICAgICAgICAgICBBVFRBQ0hfQU5EX1NFUV9TVE9SRV9TRVFfSU5ERVhfU1FMLCBbXSxcbiAgICAgICAgICAgIG1pZ3JhdGVBdHRzQW5kU2Vxcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaW4gdGhpcyBtaWdyYXRpb24sIHdlIHVzZSBlc2NhcGVCbG9iKCkgYW5kIHVuZXNjYXBlQmxvYigpXG4gIC8vIGluc3RlYWQgb2YgcmVhZGluZyBvdXQgdGhlIGJpbmFyeSBhcyBIRVgsIHdoaWNoIGlzIHNsb3dcbiAgZnVuY3Rpb24gcnVuTWlncmF0aW9uNih0eCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc3FsID0gJ0FMVEVSIFRBQkxFICcgKyBBVFRBQ0hfU1RPUkUgK1xuICAgICAgJyBBREQgQ09MVU1OIGVzY2FwZWQgVElOWUlOVCgxKSBERUZBVUxUIDAnO1xuICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBbXSwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFbmNvZGluZyh0eCwgY2IpIHtcbiAgICAvLyBVVEYtOCBvbiBjaHJvbWUvYW5kcm9pZCwgVVRGLTE2IG9uIHNhZmFyaSA8IDcuMVxuICAgIHR4LmV4ZWN1dGVTcWwoJ1NFTEVDVCBIRVgoXCJhXCIpIEFTIGhleCcsIFtdLCBmdW5jdGlvbiAodHgsIHJlcykge1xuICAgICAgICB2YXIgaGV4ID0gcmVzLnJvd3MuaXRlbSgwKS5oZXg7XG4gICAgICAgIGVuY29kaW5nID0gaGV4Lmxlbmd0aCA9PT0gMiA/ICdVVEYtOCcgOiAnVVRGLTE2JztcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25HZXRJbnN0YW5jZUlkKCkge1xuICAgIHdoaWxlIChpZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpZENhbGxiYWNrID0gaWRSZXF1ZXN0cy5wb3AoKTtcbiAgICAgIGlkQ2FsbGJhY2sobnVsbCwgaW5zdGFuY2VJZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25HZXRWZXJzaW9uKHR4LCBkYlZlcnNpb24pIHtcbiAgICBpZiAoZGJWZXJzaW9uID09PSAwKSB7XG4gICAgICAvLyBpbml0aWFsIHNjaGVtYVxuXG4gICAgICB2YXIgbWV0YSA9ICdDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAnICsgTUVUQV9TVE9SRSArXG4gICAgICAgICcgKGRiaWQsIGRiX3ZlcnNpb24gSU5URUdFUiknO1xuICAgICAgdmFyIGF0dGFjaCA9ICdDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAnICsgQVRUQUNIX1NUT1JFICtcbiAgICAgICAgJyAoZGlnZXN0IFVOSVFVRSwgZXNjYXBlZCBUSU5ZSU5UKDEpLCBib2R5IEJMT0IpJztcbiAgICAgIHZhciBhdHRhY2hBbmRSZXYgPSAnQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJyArXG4gICAgICAgIEFUVEFDSF9BTkRfU0VRX1NUT1JFICsgJyAoZGlnZXN0LCBzZXEgSU5URUdFUiknO1xuICAgICAgdmFyIGRvYyA9ICdDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAnICsgRE9DX1NUT1JFICtcbiAgICAgICAgJyAoaWQgdW5pcXVlLCBqc29uLCB3aW5uaW5nc2VxKSc7XG4gICAgICB2YXIgc2VxID0gJ0NSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTICcgKyBCWV9TRVFfU1RPUkUgK1xuICAgICAgICAnIChzZXEgSU5URUdFUiBOT1QgTlVMTCBQUklNQVJZIEtFWSBBVVRPSU5DUkVNRU5ULCAnICtcbiAgICAgICAgJ2pzb24sIGRlbGV0ZWQgVElOWUlOVCgxKSwgZG9jX2lkLCByZXYpJztcbiAgICAgIHZhciBsb2NhbCA9ICdDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAnICsgTE9DQUxfU1RPUkUgK1xuICAgICAgICAnIChpZCBVTklRVUUsIHJldiwganNvbiknO1xuXG4gICAgICAvLyBjcmVhdGVzXG4gICAgICB0eC5leGVjdXRlU3FsKGF0dGFjaCk7XG4gICAgICB0eC5leGVjdXRlU3FsKGxvY2FsKTtcbiAgICAgIHR4LmV4ZWN1dGVTcWwoYXR0YWNoQW5kUmV2LCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0eC5leGVjdXRlU3FsKEFUVEFDSF9BTkRfU0VRX1NUT1JFX1NFUV9JTkRFWF9TUUwpO1xuICAgICAgICB0eC5leGVjdXRlU3FsKEFUVEFDSF9BTkRfU0VRX1NUT1JFX0FUVEFDSF9JTkRFWF9TUUwpO1xuICAgICAgfSk7XG4gICAgICB0eC5leGVjdXRlU3FsKGRvYywgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHguZXhlY3V0ZVNxbChET0NfU1RPUkVfV0lOTklOR1NFUV9JTkRFWF9TUUwpO1xuICAgICAgICB0eC5leGVjdXRlU3FsKHNlcSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0eC5leGVjdXRlU3FsKEJZX1NFUV9TVE9SRV9ERUxFVEVEX0lOREVYX1NRTCk7XG4gICAgICAgICAgdHguZXhlY3V0ZVNxbChCWV9TRVFfU1RPUkVfRE9DX0lEX1JFVl9JTkRFWF9TUUwpO1xuICAgICAgICAgIHR4LmV4ZWN1dGVTcWwobWV0YSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIG1hcmsgdGhlIGRiIHZlcnNpb24sIGFuZCBuZXcgZGJpZFxuICAgICAgICAgICAgdmFyIGluaXRTZXEgPSAnSU5TRVJUIElOVE8gJyArIE1FVEFfU1RPUkUgK1xuICAgICAgICAgICAgICAnIChkYl92ZXJzaW9uLCBkYmlkKSBWQUxVRVMgKD8sPyknO1xuICAgICAgICAgICAgaW5zdGFuY2VJZCA9IHV0aWxzLnV1aWQoKTtcbiAgICAgICAgICAgIHZhciBpbml0U2VxQXJncyA9IFtBREFQVEVSX1ZFUlNJT04sIGluc3RhbmNlSWRdO1xuICAgICAgICAgICAgdHguZXhlY3V0ZVNxbChpbml0U2VxLCBpbml0U2VxQXJncywgZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgICAgICAgIG9uR2V0SW5zdGFuY2VJZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHsgLy8gdmVyc2lvbiA+IDBcblxuICAgICAgdmFyIHNldHVwRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1pZ3JhdGVkID0gZGJWZXJzaW9uIDwgQURBUFRFUl9WRVJTSU9OO1xuICAgICAgICBpZiAobWlncmF0ZWQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGRiIHZlcnNpb24gd2l0aGluIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgICAgICB0eC5leGVjdXRlU3FsKCdVUERBVEUgJyArIE1FVEFfU1RPUkUgKyAnIFNFVCBkYl92ZXJzaW9uID0gJyArXG4gICAgICAgICAgICBBREFQVEVSX1ZFUlNJT04pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGlmeSBkYi5pZCgpIGNhbGxlcnNcbiAgICAgICAgdmFyIHNxbCA9ICdTRUxFQ1QgZGJpZCBGUk9NICcgKyBNRVRBX1NUT1JFO1xuICAgICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW10sIGZ1bmN0aW9uICh0eCwgcmVzdWx0KSB7XG4gICAgICAgICAgaW5zdGFuY2VJZCA9IHJlc3VsdC5yb3dzLml0ZW0oMCkuZGJpZDtcbiAgICAgICAgICBvbkdldEluc3RhbmNlSWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyB3b3VsZCBsb3ZlIHRvIHVzZSBwcm9taXNlcyBoZXJlLCBidXQgdGhlbiB3ZWJzcWxcbiAgICAgIC8vIGVuZHMgdGhlIHRyYW5zYWN0aW9uIGVhcmx5XG4gICAgICB2YXIgdGFza3MgPSBbXG4gICAgICAgIHJ1bk1pZ3JhdGlvbjIsXG4gICAgICAgIHJ1bk1pZ3JhdGlvbjMsXG4gICAgICAgIHJ1bk1pZ3JhdGlvbjQsXG4gICAgICAgIHJ1bk1pZ3JhdGlvbjUsXG4gICAgICAgIHJ1bk1pZ3JhdGlvbjYsXG4gICAgICAgIHNldHVwRG9uZVxuICAgICAgXTtcblxuICAgICAgLy8gcnVuIGVhY2ggbWlncmF0aW9uIHNlcXVlbnRpYWxseVxuICAgICAgdmFyIGkgPSBkYlZlcnNpb247XG4gICAgICB2YXIgbmV4dE1pZ3JhdGlvbiA9IGZ1bmN0aW9uICh0eCkge1xuICAgICAgICB0YXNrc1tpIC0gMV0odHgsIG5leHRNaWdyYXRpb24pO1xuICAgICAgICBpKys7XG4gICAgICB9O1xuICAgICAgbmV4dE1pZ3JhdGlvbih0eCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHR4KSB7XG4gICAgICAvLyBmaXJzdCBjaGVjayB0aGUgZW5jb2RpbmdcbiAgICAgIGNoZWNrRW5jb2RpbmcodHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHZlcnNpb25cbiAgICAgICAgZmV0Y2hWZXJzaW9uKHR4KTtcbiAgICAgIH0pO1xuICAgIH0sIHVua25vd25FcnJvcihjYWxsYmFjayksIGRiQ3JlYXRlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaFZlcnNpb24odHgpIHtcbiAgICB2YXIgc3FsID0gJ1NFTEVDVCBzcWwgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHRibF9uYW1lID0gJyArIE1FVEFfU1RPUkU7XG4gICAgdHguZXhlY3V0ZVNxbChzcWwsIFtdLCBmdW5jdGlvbiAodHgsIHJlc3VsdCkge1xuICAgICAgaWYgKCFyZXN1bHQucm93cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gZGF0YWJhc2UgaGFzbid0IGV2ZW4gYmVlbiBjcmVhdGVkIHlldCAodmVyc2lvbiAwKVxuICAgICAgICBvbkdldFZlcnNpb24odHgsIDApO1xuICAgICAgfSBlbHNlIGlmICghL2RiX3ZlcnNpb24vLnRlc3QocmVzdWx0LnJvd3MuaXRlbSgwKS5zcWwpKSB7XG4gICAgICAgIC8vIHRhYmxlIHdhcyBjcmVhdGVkLCBidXQgd2l0aG91dCB0aGUgbmV3IGRiX3ZlcnNpb24gY29sdW1uLFxuICAgICAgICAvLyBzbyBhZGQgaXQuXG4gICAgICAgIHR4LmV4ZWN1dGVTcWwoJ0FMVEVSIFRBQkxFICcgKyBNRVRBX1NUT1JFICtcbiAgICAgICAgICAnIEFERCBDT0xVTU4gZGJfdmVyc2lvbiBJTlRFR0VSJywgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBiZWZvcmUgdmVyc2lvbiAyLCB0aGlzIGNvbHVtbiBkaWRuJ3QgZXZlbiBleGlzdFxuICAgICAgICAgIG9uR2V0VmVyc2lvbih0eCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHsgLy8gY29sdW1uIGV4aXN0cywgd2UgY2FuIHNhZmVseSBnZXQgaXRcbiAgICAgICAgdHguZXhlY3V0ZVNxbCgnU0VMRUNUIGRiX3ZlcnNpb24gRlJPTSAnICsgTUVUQV9TVE9SRSxcbiAgICAgICAgICBbXSwgZnVuY3Rpb24gKHR4LCByZXN1bHQpIHtcbiAgICAgICAgICB2YXIgZGJWZXJzaW9uID0gcmVzdWx0LnJvd3MuaXRlbSgwKS5kYl92ZXJzaW9uO1xuICAgICAgICAgIG9uR2V0VmVyc2lvbih0eCwgZGJWZXJzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNDb3Jkb3ZhKCkgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvL3RvIHdhaXQgdW50aWwgY3VzdG9tIGFwaSBpcyBtYWRlIGluIHBvdWNoLmFkYXB0ZXJzIGJlZm9yZSBkb2luZyBzZXR1cFxuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKG5hbWUgKyAnX3BvdWNoJywgZnVuY3Rpb24gY29yZG92YV9pbml0KCkge1xuICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSArICdfcG91Y2gnLCBjb3Jkb3ZhX2luaXQsIGZhbHNlKTtcbiAgICAgIHNldHVwKCk7XG4gICAgfSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHNldHVwKCk7XG4gIH1cblxuICBhcGkudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3dlYnNxbCc7XG4gIH07XG5cbiAgYXBpLl9pZCA9IHV0aWxzLnRvUHJvbWlzZShmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayhudWxsLCBpbnN0YW5jZUlkKTtcbiAgfSk7XG5cbiAgYXBpLl9pbmZvID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgZGIucmVhZFRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eCkge1xuICAgICAgY291bnREb2NzKHR4LCBmdW5jdGlvbiAoZG9jQ291bnQpIHtcbiAgICAgICAgdmFyIHNxbCA9ICdTRUxFQ1QgTUFYKHNlcSkgQVMgc2VxIEZST00gJyArIEJZX1NFUV9TVE9SRTtcbiAgICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIFtdLCBmdW5jdGlvbiAodHgsIHJlcykge1xuICAgICAgICAgIHZhciB1cGRhdGVTZXEgPSByZXMucm93cy5pdGVtKDApLnNlcSB8fCAwO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIGRvY19jb3VudDogZG9jQ291bnQsXG4gICAgICAgICAgICB1cGRhdGVfc2VxOiB1cGRhdGVTZXFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCB1bmtub3duRXJyb3IoY2FsbGJhY2spKTtcbiAgfTtcblxuICBhcGkuX2J1bGtEb2NzID0gZnVuY3Rpb24gKHJlcSwgb3B0cywgY2FsbGJhY2spIHtcblxuICAgIHZhciBuZXdFZGl0cyA9IG9wdHMubmV3X2VkaXRzO1xuICAgIHZhciB1c2VyRG9jcyA9IHJlcS5kb2NzO1xuXG4gICAgLy8gUGFyc2UgdGhlIGRvY3MsIGdpdmUgdGhlbSBhIHNlcXVlbmNlIG51bWJlciBmb3IgdGhlIHJlc3VsdFxuICAgIHZhciBkb2NJbmZvcyA9IHVzZXJEb2NzLm1hcChmdW5jdGlvbiAoZG9jLCBpKSB7XG4gICAgICBpZiAoZG9jLl9pZCAmJiB1dGlscy5pc0xvY2FsSWQoZG9jLl9pZCkpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEb2MgPSB1dGlscy5wYXJzZURvYyhkb2MsIG5ld0VkaXRzKTtcbiAgICAgIG5ld0RvYy5fYnVsa19zZXEgPSBpO1xuICAgICAgcmV0dXJuIG5ld0RvYztcbiAgICB9KTtcblxuICAgIHZhciBkb2NJbmZvRXJyb3JzID0gZG9jSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChkb2NJbmZvKSB7XG4gICAgICByZXR1cm4gZG9jSW5mby5lcnJvcjtcbiAgICB9KTtcbiAgICBpZiAoZG9jSW5mb0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhkb2NJbmZvRXJyb3JzWzBdKTtcbiAgICB9XG5cbiAgICB2YXIgdHg7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkoZG9jSW5mb3MubGVuZ3RoKTtcbiAgICB2YXIgZmV0Y2hlZERvY3MgPSBuZXcgdXRpbHMuTWFwKCk7XG4gICAgdmFyIG51bURvY3NXcml0dGVuID0gMDtcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgdmFyIGFyZXN1bHRzID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0Ll9idWxrX3NlcSkge1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHQuX2J1bGtfc2VxO1xuICAgICAgICB9IGVsc2UgaWYgKCFPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0YWRhdGEgPSByZXN1bHQubWV0YWRhdGE7XG4gICAgICAgIHZhciByZXYgPSBtZXJnZS53aW5uaW5nUmV2KG1ldGFkYXRhKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGlkOiBtZXRhZGF0YS5pZCxcbiAgICAgICAgICByZXY6IHJldlxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBXZWJTcWxQb3VjaC5DaGFuZ2VzLm5vdGlmeShuYW1lKTtcblxuICAgICAgY2FsbGJhY2sobnVsbCwgYXJlc3VsdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlcmlmeUF0dGFjaG1lbnQoZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNxbCA9ICdTRUxFQ1QgY291bnQoKikgYXMgY250IEZST00gJyArIEFUVEFDSF9TVE9SRSArXG4gICAgICAgICcgV0hFUkUgZGlnZXN0PT8nO1xuICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIFtkaWdlc3RdLCBmdW5jdGlvbiAodHgsIHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnJvd3MuaXRlbSgwKS5jbnQgPT09IDApIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCd1bmtub3duIHN0dWIgYXR0YWNobWVudCB3aXRoIGRpZ2VzdCAnICsgZGlnZXN0KTtcbiAgICAgICAgICBlcnIuc3RhdHVzID0gNDEyO1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmVyaWZ5QXR0YWNobWVudHMoZmluaXNoKSB7XG4gICAgICB2YXIgZGlnZXN0cyA9IFtdO1xuICAgICAgZG9jSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jSW5mbykge1xuICAgICAgICBpZiAoZG9jSW5mby5kYXRhICYmIGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgdmFyIGF0dCA9IGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dC5zdHViKSB7XG4gICAgICAgICAgICAgIGRpZ2VzdHMucHVzaChhdHQuZGlnZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWRpZ2VzdHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgIH1cbiAgICAgIHZhciBudW1Eb25lID0gMDtcbiAgICAgIHZhciBlcnI7XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrRG9uZSgpIHtcbiAgICAgICAgaWYgKCsrbnVtRG9uZSA9PT0gZGlnZXN0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlnZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChkaWdlc3QpIHtcbiAgICAgICAgdmVyaWZ5QXR0YWNobWVudChkaWdlc3QsIGZ1bmN0aW9uIChhdHRFcnIpIHtcbiAgICAgICAgICBpZiAoYXR0RXJyICYmICFlcnIpIHtcbiAgICAgICAgICAgIGVyciA9IGF0dEVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hlY2tEb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc0F0dGFjaG1lbnQoYXR0LCBmaW5pc2gpIHtcbiAgICAgIGlmIChhdHQuc3R1Yikge1xuICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGF0dC5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF0dC5kYXRhID0gYXRvYihhdHQuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgZXJyID0gZXJyb3JzLmVycm9yKGVycm9ycy5CQURfQVJHLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkF0dGFjaG1lbnRzIG5lZWQgdG8gYmUgYmFzZTY0IGVuY29kZWRcIik7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSB1dGlscy5maXhCaW5hcnkoYXR0LmRhdGEpO1xuICAgICAgICBhdHQuZGF0YSA9IHV0aWxzLmNyZWF0ZUJsb2IoW2RhdGFdLCB7dHlwZTogYXR0LmNvbnRlbnRfdHlwZX0pO1xuICAgICAgfVxuICAgICAgdXRpbHMucmVhZEFzQmluYXJ5U3RyaW5nKGF0dC5kYXRhLCBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgICAgIGF0dC5kYXRhID0gYmluYXJ5O1xuICAgICAgICB1dGlscy5NRDUoYmluYXJ5KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBhdHQuZGlnZXN0ID0gJ21kNS0nICsgcmVzdWx0O1xuICAgICAgICAgIGF0dC5sZW5ndGggPSBiaW5hcnkubGVuZ3RoO1xuICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NBdHRhY2htZW50cyhjYWxsYmFjaykge1xuICAgICAgaWYgKCFkb2NJbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb2N2ID0gMDtcblxuICAgICAgZG9jSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jSW5mbykge1xuICAgICAgICB2YXIgYXR0YWNobWVudHMgPSBkb2NJbmZvLmRhdGEgJiYgZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cyA/XG4gICAgICAgICAgT2JqZWN0LmtleXMoZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cykgOiBbXTtcbiAgICAgICAgdmFyIHJlY3YgPSAwO1xuXG4gICAgICAgIGlmICghYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NlZEF0dGFjaG1lbnQoKSB7XG4gICAgICAgICAgcmVjdisrO1xuICAgICAgICAgIGlmIChyZWN2ID09PSBhdHRhY2htZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgICAgIGlmIChkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHByZXByb2Nlc3NBdHRhY2htZW50KGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZEF0dGFjaG1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIGRvY3YrKztcbiAgICAgICAgaWYgKGRvY0luZm9zLmxlbmd0aCA9PT0gZG9jdikge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cml0ZURvYyhkb2NJbmZvLCB3aW5uaW5nUmV2LCBkZWxldGVkLCBjYWxsYmFjaywgaXNVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0lkeCkge1xuXG4gICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIHZhciBkYXRhID0gZG9jSW5mby5kYXRhO1xuICAgICAgICB2YXIgZGVsZXRlZEludCA9IGRlbGV0ZWQgPyAxIDogMDtcblxuICAgICAgICB2YXIgaWQgPSBkYXRhLl9pZDtcbiAgICAgICAgdmFyIHJldiA9IGRhdGEuX3JldjtcbiAgICAgICAgdmFyIGpzb24gPSBzdHJpbmdpZnlEb2MoZGF0YSk7XG4gICAgICAgIHZhciBzcWwgPSAnSU5TRVJUIElOVE8gJyArIEJZX1NFUV9TVE9SRSArXG4gICAgICAgICAgJyAoZG9jX2lkLCByZXYsIGpzb24sIGRlbGV0ZWQpIFZBTFVFUyAoPywgPywgPywgPyk7JztcbiAgICAgICAgdmFyIHNxbEFyZ3MgPSBbaWQsIHJldiwganNvbiwgZGVsZXRlZEludF07XG5cbiAgICAgICAgLy8gbWFwIHNlcXMgdG8gYXR0YWNobWVudCBkaWdlc3RzLCB3aGljaFxuICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgbGF0ZXIgZHVyaW5nIGNvbXBhY3Rpb25cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QXR0YWNobWVudE1hcHBpbmdzKHNlcSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgYXR0c0FkZGVkID0gMDtcbiAgICAgICAgICB2YXIgYXR0c1RvQWRkID0gT2JqZWN0LmtleXMoZGF0YS5fYXR0YWNobWVudHMgfHwge30pO1xuXG4gICAgICAgICAgaWYgKCFhdHRzVG9BZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2hlY2tEb25lKCkge1xuICAgICAgICAgICAgaWYgKCsrYXR0c0FkZGVkID09PSBhdHRzVG9BZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGFjayBoYW5kbGluZyBhIGNvbnN0cmFpbnQgZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYWRkKGF0dCkge1xuICAgICAgICAgICAgdmFyIHNxbCA9ICdJTlNFUlQgSU5UTyAnICsgQVRUQUNIX0FORF9TRVFfU1RPUkUgK1xuICAgICAgICAgICAgICAnIChkaWdlc3QsIHNlcSkgVkFMVUVTICg/LD8pJztcbiAgICAgICAgICAgIHZhciBzcWxBcmdzID0gW2RhdGEuX2F0dGFjaG1lbnRzW2F0dF0uZGlnZXN0LCBzZXFdO1xuICAgICAgICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIHNxbEFyZ3MsIGNoZWNrRG9uZSwgY2hlY2tEb25lKTtcbiAgICAgICAgICAgIC8vIHNlY29uZCBjYWxsYmFjayBpcyBmb3IgYSBjb25zdGFpbnQgZXJyb3IsIHdoaWNoIHdlIGlnbm9yZVxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGRvY2lkL3JldiBoYXMgYWxyZWFkeSBiZWVuIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGRpZ2VzdCAoZS5nLiB3aGVuIG5ld19lZGl0cyA9PSBmYWxzZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRzVG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFkZChhdHRzVG9BZGRbaV0pOyAvLyBkbyBpbiBwYXJhbGxlbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBzcWxBcmdzLCBmdW5jdGlvbiAodHgsIHJlc3VsdCkge1xuICAgICAgICAgIHZhciBzZXEgPSByZXN1bHQuaW5zZXJ0SWQ7XG4gICAgICAgICAgaW5zZXJ0QXR0YWNobWVudE1hcHBpbmdzKHNlcSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGF0YVdyaXR0ZW4odHgsIHNlcSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBjb25zdHJhaW50IGVycm9yLCByZWNvdmVyIGJ5IHVwZGF0aW5nIGluc3RlYWQgKHNlZSAjMTYzOClcbiAgICAgICAgICB2YXIgZmV0Y2hTcWwgPSBzZWxlY3QoJ3NlcScsIEJZX1NFUV9TVE9SRSwgbnVsbCxcbiAgICAgICAgICAgICdkb2NfaWQ9PyBBTkQgcmV2PT8nKTtcbiAgICAgICAgICB0eC5leGVjdXRlU3FsKGZldGNoU3FsLCBbaWQsIHJldl0sIGZ1bmN0aW9uICh0eCwgcmVzKSB7XG4gICAgICAgICAgICB2YXIgc2VxID0gcmVzLnJvd3MuaXRlbSgwKS5zZXE7XG4gICAgICAgICAgICB2YXIgc3FsID0gJ1VQREFURSAnICsgQllfU0VRX1NUT1JFICtcbiAgICAgICAgICAgICAgJyBTRVQganNvbj0/LCBkZWxldGVkPT8gV0hFUkUgZG9jX2lkPT8gQU5EIHJldj0/Oyc7XG4gICAgICAgICAgICB2YXIgc3FsQXJncyA9IFtqc29uLCBkZWxldGVkSW50LCBpZCwgcmV2XTtcbiAgICAgICAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBzcWxBcmdzLCBmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgaW5zZXJ0QXR0YWNobWVudE1hcHBpbmdzKHNlcSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRhdGFXcml0dGVuKHR4LCBzZXEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gYWNrIHRoYXQgd2UndmUgaGFuZGxlZCB0aGUgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbGxlY3RSZXN1bHRzKGF0dGFjaG1lbnRFcnIpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBpZiAoYXR0YWNobWVudEVycikge1xuICAgICAgICAgICAgZXJyID0gYXR0YWNobWVudEVycjtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWN2ID09PSBhdHRhY2htZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZXJyID0gbnVsbDtcbiAgICAgIHZhciByZWN2ID0gMDtcblxuICAgICAgZG9jSW5mby5kYXRhLl9pZCA9IGRvY0luZm8ubWV0YWRhdGEuaWQ7XG4gICAgICBkb2NJbmZvLmRhdGEuX3JldiA9IGRvY0luZm8ubWV0YWRhdGEucmV2O1xuXG4gICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBkb2NJbmZvLmRhdGEuX2RlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0YWNobWVudHMgPSBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzID9cbiAgICAgICAgT2JqZWN0LmtleXMoZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cykgOiBbXTtcblxuICAgICAgZnVuY3Rpb24gYXR0YWNobWVudFNhdmVkKGVycikge1xuICAgICAgICByZWN2Kys7XG4gICAgICAgIGNvbGxlY3RSZXN1bHRzKGVycik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgIGlmICghZG9jSW5mby5kYXRhLl9hdHRhY2htZW50c1trZXldLnN0dWIpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHNba2V5XS5kYXRhO1xuICAgICAgICAgIGRlbGV0ZSBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzW2tleV0uZGF0YTtcbiAgICAgICAgICB2YXIgZGlnZXN0ID0gZG9jSW5mby5kYXRhLl9hdHRhY2htZW50c1trZXldLmRpZ2VzdDtcbiAgICAgICAgICBzYXZlQXR0YWNobWVudChkaWdlc3QsIGRhdGEsIGF0dGFjaG1lbnRTYXZlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdisrO1xuICAgICAgICAgIGNvbGxlY3RSZXN1bHRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdHRhY2htZW50cy5sZW5ndGgpIHtcbiAgICAgICAgZmluaXNoKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRhdGFXcml0dGVuKHR4LCBzZXEpIHtcbiAgICAgICAgZG9jSW5mby5tZXRhZGF0YS5zZXEgPSBzZXE7XG4gICAgICAgIGRlbGV0ZSBkb2NJbmZvLm1ldGFkYXRhLnJldjtcblxuICAgICAgICB2YXIgc3FsID0gaXNVcGRhdGUgP1xuICAgICAgICAgICdVUERBVEUgJyArIERPQ19TVE9SRSArXG4gICAgICAgICAgJyBTRVQganNvbj0/LCB3aW5uaW5nc2VxPShTRUxFQ1Qgc2VxIEZST00gJyArIEJZX1NFUV9TVE9SRSArXG4gICAgICAgICAgJyBXSEVSRSBkb2NfaWQ9JyArIERPQ19TVE9SRSArICcuaWQgQU5EIHJldj0/KSBXSEVSRSBpZD0/J1xuICAgICAgICAgIDogJ0lOU0VSVCBJTlRPICcgKyBET0NfU1RPUkUgK1xuICAgICAgICAgICcgKGlkLCB3aW5uaW5nc2VxLCBqc29uKSBWQUxVRVMgKD8sID8sID8pOyc7XG4gICAgICAgIHZhciBtZXRhZGF0YVN0ciA9IHZ1dnV6ZWxhLnN0cmluZ2lmeShkb2NJbmZvLm1ldGFkYXRhKTtcbiAgICAgICAgdmFyIGlkID0gZG9jSW5mby5tZXRhZGF0YS5pZDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGlzVXBkYXRlID9cbiAgICAgICAgICBbbWV0YWRhdGFTdHIsIHdpbm5pbmdSZXYsIGlkXSA6XG4gICAgICAgICAgW2lkLCBzZXEsIG1ldGFkYXRhU3RyXTtcbiAgICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIHBhcmFtcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc3VsdHNbcmVzdWx0c0lkeF0gPSBkb2NJbmZvO1xuICAgICAgICAgIGZldGNoZWREb2NzLnNldChpZCwgZG9jSW5mby5tZXRhZGF0YSk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlRG9jKG9sZERvYywgZG9jSW5mbywgcmVzdWx0c0lkeCwgY2FsbGJhY2spIHtcblxuICAgICAgaWYgKHV0aWxzLnJldkV4aXN0cyhvbGREb2MsIGRvY0luZm8ubWV0YWRhdGEucmV2KSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHNJZHhdID0gZG9jSW5mbztcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVyZ2VkID1cbiAgICAgICAgbWVyZ2UubWVyZ2Uob2xkRG9jLnJldl90cmVlLCBkb2NJbmZvLm1ldGFkYXRhLnJldl90cmVlWzBdLCAxMDAwKTtcblxuICAgICAgdmFyIHByZXZpb3VzbHlEZWxldGVkID0gdXRpbHMuaXNEZWxldGVkKG9sZERvYyk7XG4gICAgICB2YXIgZGVsZXRlZCA9IHV0aWxzLmlzRGVsZXRlZChkb2NJbmZvLm1ldGFkYXRhKTtcbiAgICAgIHZhciBpbkNvbmZsaWN0ID0gKHByZXZpb3VzbHlEZWxldGVkICYmIGRlbGV0ZWQgJiYgbmV3RWRpdHMpIHx8XG4gICAgICAgICghcHJldmlvdXNseURlbGV0ZWQgJiYgbmV3RWRpdHMgJiYgbWVyZ2VkLmNvbmZsaWN0cyAhPT0gJ25ld19sZWFmJykgfHxcbiAgICAgICAgKHByZXZpb3VzbHlEZWxldGVkICYmICFkZWxldGVkICYmIG1lcmdlZC5jb25mbGljdHMgPT09ICduZXdfYnJhbmNoJyk7XG5cbiAgICAgIGlmIChpbkNvbmZsaWN0KSB7XG4gICAgICAgIHJlc3VsdHNbcmVzdWx0c0lkeF0gPSBtYWtlRXJyKGVycm9ycy5SRVZfQ09ORkxJQ1QsIGRvY0luZm8uX2J1bGtfc2VxKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIGRvY0luZm8ubWV0YWRhdGEucmV2X3RyZWUgPSBtZXJnZWQudHJlZTtcblxuICAgICAgLy8gcmVjYWxjdWxhdGVcbiAgICAgIHZhciB3aW5uaW5nUmV2ID0gbWVyZ2Uud2lubmluZ1Jldihkb2NJbmZvLm1ldGFkYXRhKTtcbiAgICAgIGRlbGV0ZWQgPSB1dGlscy5pc0RlbGV0ZWQoZG9jSW5mby5tZXRhZGF0YSwgd2lubmluZ1Jldik7XG5cbiAgICAgIHdyaXRlRG9jKGRvY0luZm8sIHdpbm5pbmdSZXYsIGRlbGV0ZWQsIGNhbGxiYWNrLCB0cnVlLCByZXN1bHRzSWR4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnREb2MoZG9jSW5mbywgcmVzdWx0c0lkeCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbnQgaW5zZXJ0IG5ldyBkZWxldGVkIGRvY3VtZW50c1xuICAgICAgdmFyIHdpbm5pbmdSZXYgPSBtZXJnZS53aW5uaW5nUmV2KGRvY0luZm8ubWV0YWRhdGEpO1xuICAgICAgdmFyIGRlbGV0ZWQgPSB1dGlscy5pc0RlbGV0ZWQoZG9jSW5mby5tZXRhZGF0YSwgd2lubmluZ1Jldik7XG4gICAgICBpZiAoJ3dhc19kZWxldGUnIGluIG9wdHMgJiYgZGVsZXRlZCkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHNJZHhdID0gZXJyb3JzLk1JU1NJTkdfRE9DO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHdyaXRlRG9jKGRvY0luZm8sIHdpbm5pbmdSZXYsIGRlbGV0ZWQsIGNhbGxiYWNrLCBmYWxzZSwgcmVzdWx0c0lkeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tEb25lV3JpdGluZ0RvY3MoKSB7XG4gICAgICBpZiAoKytudW1Eb2NzV3JpdHRlbiA9PT0gZG9jSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RvY3MoKSB7XG4gICAgICBpZiAoIWRvY0luZm9zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkc1RvRG9jcyA9IG5ldyB1dGlscy5NYXAoKTtcblxuICAgICAgZG9jSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudERvYywgcmVzdWx0c0lkeCkge1xuXG4gICAgICAgIGlmIChjdXJyZW50RG9jLl9pZCAmJiB1dGlscy5pc0xvY2FsSWQoY3VycmVudERvYy5faWQpKSB7XG4gICAgICAgICAgYXBpW2N1cnJlbnREb2MuX2RlbGV0ZWQgPyAnX3JlbW92ZUxvY2FsJyA6ICdfcHV0TG9jYWwnXShcbiAgICAgICAgICAgICAgY3VycmVudERvYywge2N0eDogdHh9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbcmVzdWx0c0lkeF0gPSBlcnI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHRzW3Jlc3VsdHNJZHhdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0RvbmVXcml0aW5nRG9jcygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGN1cnJlbnREb2MubWV0YWRhdGEuaWQ7XG4gICAgICAgIGlmIChpZHNUb0RvY3MuaGFzKGlkKSkge1xuICAgICAgICAgIGlkc1RvRG9jcy5nZXQoaWQpLnB1c2goW2N1cnJlbnREb2MsIHJlc3VsdHNJZHhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHNUb0RvY3Muc2V0KGlkLCBbW2N1cnJlbnREb2MsIHJlc3VsdHNJZHhdXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbiB0aGUgY2FzZSBvZiBuZXdfZWRpdHMsIHRoZSB1c2VyIGNhbiBwcm92aWRlIG11bHRpcGxlIGRvY3NcbiAgICAgIC8vIHdpdGggdGhlIHNhbWUgaWQuIHRoZXNlIG5lZWQgdG8gYmUgcHJvY2Vzc2VkIHNlcXVlbnRpYWxseVxuICAgICAgaWRzVG9Eb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvY3MsIGlkKSB7XG4gICAgICAgIHZhciBudW1Eb25lID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBkb2NXcml0dGVuKCkge1xuICAgICAgICAgIGNoZWNrRG9uZVdyaXRpbmdEb2NzKCk7XG4gICAgICAgICAgaWYgKCsrbnVtRG9uZSA8IGRvY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0RG9jKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5leHREb2MoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZG9jc1tudW1Eb25lXTtcbiAgICAgICAgICB2YXIgY3VycmVudERvYyA9IHZhbHVlWzBdO1xuICAgICAgICAgIHZhciByZXN1bHRzSWR4ID0gdmFsdWVbMV07XG5cbiAgICAgICAgICBpZiAoZmV0Y2hlZERvY3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgdXBkYXRlRG9jKGZldGNoZWREb2NzLmdldChpZCksIGN1cnJlbnREb2MsIHJlc3VsdHNJZHgsIGRvY1dyaXR0ZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnREb2MoY3VycmVudERvYywgcmVzdWx0c0lkeCwgZG9jV3JpdHRlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHREb2MoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoRXhpc3RpbmdEb2NzKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIWRvY0luZm9zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG51bUZldGNoZWQgPSAwO1xuXG4gICAgICBmdW5jdGlvbiBjaGVja0RvbmUoKSB7XG4gICAgICAgIGlmICgrK251bUZldGNoZWQgPT09IGRvY0luZm9zLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZG9jSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jSW5mbykge1xuICAgICAgICBpZiAoZG9jSW5mby5faWQgJiYgdXRpbHMuaXNMb2NhbElkKGRvY0luZm8uX2lkKSkge1xuICAgICAgICAgIHJldHVybiBjaGVja0RvbmUoKTsgLy8gc2tpcCBsb2NhbCBkb2NzXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gZG9jSW5mby5tZXRhZGF0YS5pZDtcbiAgICAgICAgdHguZXhlY3V0ZVNxbCgnU0VMRUNUIGpzb24gRlJPTSAnICsgRE9DX1NUT1JFICtcbiAgICAgICAgICAnIFdIRVJFIGlkID0gPycsIFtpZF0sIGZ1bmN0aW9uICh0eCwgcmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gdnV2dXplbGEucGFyc2UocmVzdWx0LnJvd3MuaXRlbSgwKS5qc29uKTtcbiAgICAgICAgICAgIGZldGNoZWREb2NzLnNldChpZCwgbWV0YWRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgc2VxdWVuY2UgbnVtYmVyIGludG8gdGhlIGVycm9yIHNvIHdlIGNhbiBzb3J0IGxhdGVyXG4gICAgZnVuY3Rpb24gbWFrZUVycihlcnIsIHNlcSkge1xuICAgICAgZXJyLl9idWxrX3NlcSA9IHNlcTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZUF0dGFjaG1lbnQoZGlnZXN0LCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNxbCA9ICdTRUxFQ1QgZGlnZXN0IEZST00gJyArIEFUVEFDSF9TVE9SRSArICcgV0hFUkUgZGlnZXN0PT8nO1xuICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIFtkaWdlc3RdLCBmdW5jdGlvbiAodHgsIHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnJvd3MubGVuZ3RoKSB7IC8vIGF0dGFjaG1lbnQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBjb3VsZCBqdXN0IGluc2VydCBiZWZvcmUgc2VsZWN0aW5nIGFuZCBjYXRjaCB0aGUgZXJyb3IsXG4gICAgICAgIC8vIGJ1dCBteSBodW5jaCBpcyB0aGF0IGl0J3MgY2hlYXBlciBub3QgdG8gc2VyaWFsaXplIHRoZSBibG9iXG4gICAgICAgIC8vIGZyb20gSlMgdG8gQyBpZiB3ZSBkb24ndCBoYXZlIHRvIChUT0RPOiBjb25maXJtIHRoaXMpXG4gICAgICAgIHNxbCA9ICdJTlNFUlQgSU5UTyAnICsgQVRUQUNIX1NUT1JFICtcbiAgICAgICAgICAnIChkaWdlc3QsIGJvZHksIGVzY2FwZWQpIFZBTFVFUyAoPyw/LDEpJztcbiAgICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIFtkaWdlc3QsIGVzY2FwZUJsb2IoZGF0YSldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGlnbm9yZSBjb25zdGFpbnQgZXJyb3JzLCBtZWFucyBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBhY2sgd2UgaGFuZGxlZCB0aGUgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcmVwcm9jZXNzQXR0YWNobWVudHMoZnVuY3Rpb24gKCkge1xuICAgICAgZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHR4bikge1xuICAgICAgICB0eCA9IHR4bjtcbiAgICAgICAgdmVyaWZ5QXR0YWNobWVudHMoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaEV4aXN0aW5nRG9jcyhwcm9jZXNzRG9jcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgdW5rbm93bkVycm9yKGNhbGxiYWNrKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2NDb3VudCA9IC0xO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXBpLl9nZXQgPSBmdW5jdGlvbiAoaWQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIHZhciBkb2M7XG4gICAgdmFyIG1ldGFkYXRhO1xuICAgIHZhciBlcnI7XG4gICAgaWYgKCFvcHRzLmN0eCkge1xuICAgICAgZGIucmVhZFRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eG4pIHtcbiAgICAgICAgb3B0cy5jdHggPSB0eG47XG4gICAgICAgIGFwaS5fZ2V0KGlkLCBvcHRzLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHR4ID0gb3B0cy5jdHg7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIHtkb2M6IGRvYywgbWV0YWRhdGE6IG1ldGFkYXRhLCBjdHg6IHR4fSk7XG4gICAgfVxuXG4gICAgdmFyIHNxbDtcbiAgICB2YXIgc3FsQXJncztcbiAgICBpZiAob3B0cy5yZXYpIHtcbiAgICAgIHNxbCA9IHNlbGVjdChcbiAgICAgICAgU0VMRUNUX0RPQ1MsXG4gICAgICAgIFtET0NfU1RPUkUsIEJZX1NFUV9TVE9SRV0sXG4gICAgICAgIERPQ19TVE9SRSArICcuaWQ9JyArIEJZX1NFUV9TVE9SRSArICcuZG9jX2lkJyxcbiAgICAgICAgW0JZX1NFUV9TVE9SRSArICcuZG9jX2lkPT8nLCBCWV9TRVFfU1RPUkUgKyAnLnJldj0/J10pO1xuICAgICAgc3FsQXJncyA9IFtpZCwgb3B0cy5yZXZdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcWwgPSBzZWxlY3QoXG4gICAgICAgIFNFTEVDVF9ET0NTLFxuICAgICAgICBbRE9DX1NUT1JFLCBCWV9TRVFfU1RPUkVdLFxuICAgICAgICBET0NfU1RPUkVfQU5EX0JZX1NFUV9KT0lORVIsXG4gICAgICAgIERPQ19TVE9SRSArICcuaWQ9PycpO1xuICAgICAgc3FsQXJncyA9IFtpZF07XG4gICAgfVxuICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBzcWxBcmdzLCBmdW5jdGlvbiAoYSwgcmVzdWx0cykge1xuICAgICAgaWYgKCFyZXN1bHRzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgIGVyciA9IGVycm9ycy5NSVNTSU5HX0RPQztcbiAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW0gPSByZXN1bHRzLnJvd3MuaXRlbSgwKTtcbiAgICAgIG1ldGFkYXRhID0gdnV2dXplbGEucGFyc2UoaXRlbS5tZXRhZGF0YSk7XG4gICAgICBpZiAoaXRlbS5kZWxldGVkICYmICFvcHRzLnJldikge1xuICAgICAgICBlcnIgPSBlcnJvcnMuZXJyb3IoZXJyb3JzLk1JU1NJTkdfRE9DLCAnZGVsZXRlZCcpO1xuICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICB9XG4gICAgICBkb2MgPSB1bnN0cmluZ2lmeURvYyhpdGVtLmRhdGEsIG1ldGFkYXRhLmlkLCBpdGVtLnJldik7XG4gICAgICBmaW5pc2goKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBjb3VudERvY3ModHgsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoZG9jQ291bnQgIT09IC0xKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZG9jQ291bnQpO1xuICAgIH1cblxuICAgIC8vIGNvdW50IHRoZSB0b3RhbCByb3dzXG4gICAgdmFyIHNxbCA9IHNlbGVjdChcbiAgICAgICdDT1VOVCgnICsgRE9DX1NUT1JFICsgJy5pZCkgQVMgXFwnbnVtXFwnJyxcbiAgICAgIFtET0NfU1RPUkUsIEJZX1NFUV9TVE9SRV0sXG4gICAgICBET0NfU1RPUkVfQU5EX0JZX1NFUV9KT0lORVIsXG4gICAgICBCWV9TRVFfU1RPUkUgKyAnLmRlbGV0ZWQ9MCcpO1xuXG4gICAgdHguZXhlY3V0ZVNxbChzcWwsIFtdLCBmdW5jdGlvbiAodHgsIHJlc3VsdCkge1xuICAgICAgZG9jQ291bnQgPSByZXN1bHQucm93cy5pdGVtKDApLm51bTtcbiAgICAgIGNhbGxiYWNrKGRvY0NvdW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwaS5fYWxsRG9jcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHRvdGFsUm93cztcblxuICAgIHZhciBzdGFydCA9ICdzdGFydGtleScgaW4gb3B0cyA/IG9wdHMuc3RhcnRrZXkgOiBmYWxzZTtcbiAgICB2YXIgZW5kID0gJ2VuZGtleScgaW4gb3B0cyA/IG9wdHMuZW5ka2V5IDogZmFsc2U7XG4gICAgdmFyIGtleSA9ICdrZXknIGluIG9wdHMgPyBvcHRzLmtleSA6IGZhbHNlO1xuICAgIHZhciBkZXNjZW5kaW5nID0gJ2Rlc2NlbmRpbmcnIGluIG9wdHMgPyBvcHRzLmRlc2NlbmRpbmcgOiBmYWxzZTtcbiAgICB2YXIgbGltaXQgPSAnbGltaXQnIGluIG9wdHMgPyBvcHRzLmxpbWl0IDogLTE7XG4gICAgdmFyIG9mZnNldCA9ICdza2lwJyBpbiBvcHRzID8gb3B0cy5za2lwIDogMDtcbiAgICB2YXIgaW5jbHVzaXZlRW5kID0gb3B0cy5pbmNsdXNpdmVfZW5kICE9PSBmYWxzZTtcblxuICAgIHZhciBzcWxBcmdzID0gW107XG4gICAgdmFyIGNyaXRlcmlhID0gW107XG5cbiAgICBpZiAoa2V5ICE9PSBmYWxzZSkge1xuICAgICAgY3JpdGVyaWEucHVzaChET0NfU1RPUkUgKyAnLmlkID0gPycpO1xuICAgICAgc3FsQXJncy5wdXNoKGtleSk7XG4gICAgfSBlbHNlIGlmIChzdGFydCAhPT0gZmFsc2UgfHwgZW5kICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHN0YXJ0ICE9PSBmYWxzZSkge1xuICAgICAgICBjcml0ZXJpYS5wdXNoKERPQ19TVE9SRSArICcuaWQgJyArIChkZXNjZW5kaW5nID8gJzw9JyA6ICc+PScpICsgJyA/Jyk7XG4gICAgICAgIHNxbEFyZ3MucHVzaChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgY29tcGFyYXRvciA9IGRlc2NlbmRpbmcgPyAnPicgOiAnPCc7XG4gICAgICAgIGlmIChpbmNsdXNpdmVFbmQpIHtcbiAgICAgICAgICBjb21wYXJhdG9yICs9ICc9JztcbiAgICAgICAgfVxuICAgICAgICBjcml0ZXJpYS5wdXNoKERPQ19TVE9SRSArICcuaWQgJyArIGNvbXBhcmF0b3IgKyAnID8nKTtcbiAgICAgICAgc3FsQXJncy5wdXNoKGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ICE9PSBmYWxzZSkge1xuICAgICAgICBjcml0ZXJpYS5wdXNoKERPQ19TVE9SRSArICcuaWQgPSA/Jyk7XG4gICAgICAgIHNxbEFyZ3MucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRzLmRlbGV0ZWQgIT09ICdvaycpIHtcbiAgICAgIC8vIHJlcG9ydCBkZWxldGVkIGlmIGtleXMgYXJlIHNwZWNpZmllZFxuICAgICAgY3JpdGVyaWEucHVzaChCWV9TRVFfU1RPUkUgKyAnLmRlbGV0ZWQgPSAwJyk7XG4gICAgfVxuXG4gICAgZGIucmVhZFRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eCkge1xuXG4gICAgICAvLyBmaXJzdCBjb3VudCB1cCB0aGUgdG90YWwgcm93c1xuICAgICAgY291bnREb2NzKHR4LCBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdG90YWxSb3dzID0gY291bnQ7XG5cbiAgICAgICAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlbiBhY3R1YWxseSBmZXRjaCB0aGUgZG9jdW1lbnRzXG4gICAgICAgIHZhciBzcWwgPSBzZWxlY3QoXG4gICAgICAgICAgU0VMRUNUX0RPQ1MsXG4gICAgICAgICAgW0RPQ19TVE9SRSwgQllfU0VRX1NUT1JFXSxcbiAgICAgICAgICBET0NfU1RPUkVfQU5EX0JZX1NFUV9KT0lORVIsXG4gICAgICAgICAgY3JpdGVyaWEsXG4gICAgICAgICAgRE9DX1NUT1JFICsgJy5pZCAnICsgKGRlc2NlbmRpbmcgPyAnREVTQycgOiAnQVNDJylcbiAgICAgICAgICApO1xuICAgICAgICBzcWwgKz0gJyBMSU1JVCAnICsgbGltaXQgKyAnIE9GRlNFVCAnICsgb2Zmc2V0O1xuXG4gICAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBzcWxBcmdzLCBmdW5jdGlvbiAodHgsIHJlc3VsdCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdWx0LnJvd3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHJlc3VsdC5yb3dzLml0ZW0oaSk7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB2dXZ1emVsYS5wYXJzZShpdGVtLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdW5zdHJpbmdpZnlEb2MoaXRlbS5kYXRhLCBtZXRhZGF0YS5pZCwgaXRlbS5yZXYpO1xuICAgICAgICAgICAgdmFyIHdpbm5pbmdSZXYgPSBkYXRhLl9yZXY7XG4gICAgICAgICAgICB2YXIgZG9jID0ge1xuICAgICAgICAgICAgICBpZDogbWV0YWRhdGEuaWQsXG4gICAgICAgICAgICAgIGtleTogbWV0YWRhdGEuaWQsXG4gICAgICAgICAgICAgIHZhbHVlOiB7cmV2OiB3aW5uaW5nUmV2fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRzLmluY2x1ZGVfZG9jcykge1xuICAgICAgICAgICAgICBkb2MuZG9jID0gZGF0YTtcbiAgICAgICAgICAgICAgZG9jLmRvYy5fcmV2ID0gd2lubmluZ1JldjtcbiAgICAgICAgICAgICAgaWYgKG9wdHMuY29uZmxpY3RzKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRvYy5fY29uZmxpY3RzID0gbWVyZ2UuY29sbGVjdENvbmZsaWN0cyhtZXRhZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgYXR0IGluIGRvYy5kb2MuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYy5kb2MuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGF0dCkpIHtcbiAgICAgICAgICAgICAgICAgIGRvYy5kb2MuX2F0dGFjaG1lbnRzW2F0dF0uc3R1YiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRzLmRlbGV0ZWQgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICBkb2MudmFsdWUuZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG9jLmRvYyA9IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCB1bmtub3duRXJyb3IoY2FsbGJhY2spLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHRvdGFsX3Jvd3M6IHRvdGFsUm93cyxcbiAgICAgICAgb2Zmc2V0OiBvcHRzLnNraXAsXG4gICAgICAgIHJvd3M6IHJlc3VsdHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGFwaS5fY2hhbmdlcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuXG4gICAgaWYgKG9wdHMuY29udGludW91cykge1xuICAgICAgdmFyIGlkID0gbmFtZSArICc6JyArIHV0aWxzLnV1aWQoKTtcbiAgICAgIFdlYlNxbFBvdWNoLkNoYW5nZXMuYWRkTGlzdGVuZXIobmFtZSwgaWQsIGFwaSwgb3B0cyk7XG4gICAgICBXZWJTcWxQb3VjaC5DaGFuZ2VzLm5vdGlmeShuYW1lKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFdlYlNxbFBvdWNoLkNoYW5nZXMucmVtb3ZlTGlzdGVuZXIobmFtZSwgaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZXNjZW5kaW5nID0gb3B0cy5kZXNjZW5kaW5nO1xuXG4gICAgLy8gSWdub3JlIHRoZSBgc2luY2VgIHBhcmFtZXRlciB3aGVuIGBkZXNjZW5kaW5nYCBpcyB0cnVlXG4gICAgb3B0cy5zaW5jZSA9IG9wdHMuc2luY2UgJiYgIWRlc2NlbmRpbmcgPyBvcHRzLnNpbmNlIDogMDtcblxuICAgIHZhciBsaW1pdCA9ICdsaW1pdCcgaW4gb3B0cyA/IG9wdHMubGltaXQgOiAtMTtcbiAgICBpZiAobGltaXQgPT09IDApIHtcbiAgICAgIGxpbWl0ID0gMTsgLy8gcGVyIENvdWNoREIgX2NoYW5nZXMgc3BlY1xuICAgIH1cblxuICAgIHZhciByZXR1cm5Eb2NzO1xuICAgIGlmICgncmV0dXJuRG9jcycgaW4gb3B0cykge1xuICAgICAgcmV0dXJuRG9jcyA9IG9wdHMucmV0dXJuRG9jcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRG9jcyA9IHRydWU7XG4gICAgfVxuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIG51bVJlc3VsdHMgPSAwO1xuICAgIGZ1bmN0aW9uIGZldGNoQ2hhbmdlcygpIHtcblxuICAgICAgdmFyIGNyaXRlcmlhID0gW1xuICAgICAgICBET0NfU1RPUkUgKyAnLndpbm5pbmdzZXEgPiAnICsgb3B0cy5zaW5jZVxuICAgICAgXTtcbiAgICAgIHZhciBzcWxBcmdzID0gW107XG4gICAgICBpZiAob3B0cy5kb2NfaWRzKSB7XG4gICAgICAgIGNyaXRlcmlhLnB1c2goRE9DX1NUT1JFICsgJy5pZCBJTiAoJyArIG9wdHMuZG9jX2lkcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnPyc7XG4gICAgICAgIH0pLmpvaW4oJywnKSArICcpJyk7XG4gICAgICAgIHNxbEFyZ3MgPSBvcHRzLmRvY19pZHM7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcWwgPSBzZWxlY3QoU0VMRUNUX0RPQ1MsIFtET0NfU1RPUkUsIEJZX1NFUV9TVE9SRV0sXG4gICAgICAgIERPQ19TVE9SRV9BTkRfQllfU0VRX0pPSU5FUiwgY3JpdGVyaWEsXG4gICAgICAgIERPQ19TVE9SRSArICcud2lubmluZ3NlcSAnICsgKGRlc2NlbmRpbmcgPyAnREVTQycgOiAnQVNDJykpO1xuXG4gICAgICB2YXIgZmlsdGVyID0gdXRpbHMuZmlsdGVyQ2hhbmdlKG9wdHMpO1xuICAgICAgaWYgKCFvcHRzLnZpZXcgJiYgIW9wdHMuZmlsdGVyKSB7XG4gICAgICAgIC8vIHdlIGNhbiBqdXN0IGxpbWl0IGluIHRoZSBxdWVyeVxuICAgICAgICBzcWwgKz0gJyBMSU1JVCAnICsgbGltaXQ7XG4gICAgICB9XG5cbiAgICAgIGRiLnJlYWRUcmFuc2FjdGlvbihmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIHNxbEFyZ3MsIGZ1bmN0aW9uICh0eCwgcmVzdWx0KSB7XG4gICAgICAgICAgdmFyIGxhc3RTZXEgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdWx0LnJvd3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gcmVzdWx0LnJvd3MuaXRlbShpKTtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHZ1dnV6ZWxhLnBhcnNlKHJlcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAobGFzdFNlcSA8IHJlcy5zZXEpIHtcbiAgICAgICAgICAgICAgbGFzdFNlcSA9IHJlcy5zZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZG9jID0gdW5zdHJpbmdpZnlEb2MocmVzLmRhdGEsIG1ldGFkYXRhLmlkLCByZXMucmV2KTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBvcHRzLnByb2Nlc3NDaGFuZ2UoZG9jLCBtZXRhZGF0YSwgb3B0cyk7XG4gICAgICAgICAgICBjaGFuZ2Uuc2VxID0gcmVzLnNlcTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIoY2hhbmdlKSkge1xuICAgICAgICAgICAgICBudW1SZXN1bHRzKys7XG4gICAgICAgICAgICAgIGlmIChyZXR1cm5Eb2NzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3B0cy5vbkNoYW5nZShjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bVJlc3VsdHMgPT09IGxpbWl0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdHMuY29udGludW91cykge1xuICAgICAgICAgICAgb3B0cy5jb21wbGV0ZShudWxsLCB7XG4gICAgICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgICAgICAgIGxhc3Rfc2VxOiBsYXN0U2VxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hDaGFuZ2VzKCk7XG4gIH07XG5cbiAgYXBpLl9jbG9zZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vV2ViU1FMIGRhdGFiYXNlcyBkbyBub3QgbmVlZCB0byBiZSBjbG9zZWRcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIGFwaS5fZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChhdHRhY2htZW50LCBvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciByZXM7XG4gICAgdmFyIHR4ID0gb3B0cy5jdHg7XG4gICAgdmFyIGRpZ2VzdCA9IGF0dGFjaG1lbnQuZGlnZXN0O1xuICAgIHZhciB0eXBlID0gYXR0YWNobWVudC5jb250ZW50X3R5cGU7XG4gICAgdmFyIHNxbCA9ICdTRUxFQ1QgZXNjYXBlZCwgJyArXG4gICAgICAnQ0FTRSBXSEVOIGVzY2FwZWQgPSAxIFRIRU4gYm9keSBFTFNFIEhFWChib2R5KSBFTkQgQVMgYm9keSBGUk9NICcgK1xuICAgICAgQVRUQUNIX1NUT1JFICsgJyBXSEVSRSBkaWdlc3Q9Pyc7XG4gICAgdHguZXhlY3V0ZVNxbChzcWwsIFtkaWdlc3RdLCBmdW5jdGlvbiAodHgsIHJlc3VsdCkge1xuICAgICAgLy8gd2Vic3FsIGhhcyBhIGJ1ZyB3aGVyZSBcXHUwMDAwIGNhdXNlcyBlYXJseSB0cnVuY2F0aW9uIGluIHN0cmluZ3NcbiAgICAgIC8vIGFuZCBibG9icy4gdG8gd29yayBhcm91bmQgdGhpcywgd2UgdXNlZCB0byB1c2UgdGhlIGhleCgpIGZ1bmN0aW9uLFxuICAgICAgLy8gYnV0IHRoYXQncyBub3QgcGVyZm9ybWFudC4gYWZ0ZXIgbWlncmF0aW9uIDYsIHdlIHJlbW92ZSBcXHUwMDAwXG4gICAgICAvLyBhbmQgYWRkIGl0IGJhY2sgaW4gYWZ0ZXJ3YXJkc1xuICAgICAgdmFyIGl0ZW0gPSByZXN1bHQucm93cy5pdGVtKDApO1xuICAgICAgdmFyIGRhdGEgPSBpdGVtLmVzY2FwZWQgPyB1bmVzY2FwZUJsb2IoaXRlbS5ib2R5KSA6XG4gICAgICAgIHBhcnNlSGV4U3RyaW5nKGl0ZW0uYm9keSwgZW5jb2RpbmcpO1xuICAgICAgaWYgKG9wdHMuZW5jb2RlKSB7XG4gICAgICAgIHJlcyA9IGJ0b2EoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gdXRpbHMuZml4QmluYXJ5KGRhdGEpO1xuICAgICAgICByZXMgPSB1dGlscy5jcmVhdGVCbG9iKFtkYXRhXSwge3R5cGU6IHR5cGV9KTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXBpLl9nZXRSZXZpc2lvblRyZWUgPSBmdW5jdGlvbiAoZG9jSWQsIGNhbGxiYWNrKSB7XG4gICAgZGIucmVhZFRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eCkge1xuICAgICAgdmFyIHNxbCA9ICdTRUxFQ1QganNvbiBBUyBtZXRhZGF0YSBGUk9NICcgKyBET0NfU1RPUkUgKyAnIFdIRVJFIGlkID0gPyc7XG4gICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW2RvY0lkXSwgZnVuY3Rpb24gKHR4LCByZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcnMuTUlTU0lOR19ET0MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXRhID0gdnV2dXplbGEucGFyc2UocmVzdWx0LnJvd3MuaXRlbSgwKS5tZXRhZGF0YSk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YS5yZXZfdHJlZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGFwaS5fZG9Db21wYWN0aW9uID0gZnVuY3Rpb24gKGRvY0lkLCByZXZzLCBjYWxsYmFjaykge1xuICAgIGlmICghcmV2cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBkYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodHgpIHtcblxuICAgICAgLy8gdXBkYXRlIGRvYyBzdG9yZVxuICAgICAgdmFyIHNxbCA9ICdTRUxFQ1QganNvbiBBUyBtZXRhZGF0YSBGUk9NICcgKyBET0NfU1RPUkUgKyAnIFdIRVJFIGlkID0gPyc7XG4gICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW2RvY0lkXSwgZnVuY3Rpb24gKHR4LCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gdnV2dXplbGEucGFyc2UocmVzdWx0LnJvd3MuaXRlbSgwKS5tZXRhZGF0YSk7XG4gICAgICAgIG1lcmdlLnRyYXZlcnNlUmV2VHJlZShtZXRhZGF0YS5yZXZfdHJlZSwgZnVuY3Rpb24gKGlzTGVhZiwgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZIYXNoLCBjdHgsIG9wdHMpIHtcbiAgICAgICAgICB2YXIgcmV2ID0gcG9zICsgJy0nICsgcmV2SGFzaDtcbiAgICAgICAgICBpZiAocmV2cy5pbmRleE9mKHJldikgIT09IC0xKSB7XG4gICAgICAgICAgICBvcHRzLnN0YXR1cyA9ICdtaXNzaW5nJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzcWwgPSAnVVBEQVRFICcgKyBET0NfU1RPUkUgKyAnIFNFVCBqc29uID0gPyBXSEVSRSBpZCA9ID8nO1xuICAgICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW3Z1dnV6ZWxhLnN0cmluZ2lmeShtZXRhZGF0YSksIGRvY0lkXSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gdXBkYXRlIGJ5LXNlcSBhbmQgYXR0YWNoIHN0b3JlcyBpbiBwYXJhbGxlbFxuICAgICAgcmV2cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgICAgdmFyIHNxbCA9ICdTRUxFQ1Qgc2VxIEZST00gJyArIEJZX1NFUV9TVE9SRSArXG4gICAgICAgICAgJyBXSEVSRSBkb2NfaWQ9PyBBTkQgcmV2PT8nO1xuICAgICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW2RvY0lkLCByZXZdLCBmdW5jdGlvbiAodHgsIHJlcykge1xuICAgICAgICAgIGlmICghcmVzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgZGVsZXRlZFxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2VxID0gcmVzLnJvd3MuaXRlbSgwKS5zZXE7XG5cbiAgICAgICAgICAvLyBmaW5kIG9ycGhhbmVkIGF0dGFjaG1lbnQgZGlnZXN0c1xuICAgICAgICAgIHZhciBzcWwgPSAnU0VMRUNUIGExLmRpZ2VzdCBBUyBkaWdlc3QgJyArXG4gICAgICAgICAgICAgICdGUk9NICcgKyBBVFRBQ0hfQU5EX1NFUV9TVE9SRSArICcgYTEgSk9JTiAnICtcbiAgICAgICAgICAgICAgQVRUQUNIX0FORF9TRVFfU1RPUkUgKyAnIGEyIE9OIGExLmRpZ2VzdD1hMi5kaWdlc3QgJyArXG4gICAgICAgICAgICAgICdXSEVSRSBhMS5zZXE9PyAnICtcbiAgICAgICAgICAgICAgJ0dST1VQIEJZIGExLmRpZ2VzdCBIQVZJTkcgQ09VTlQoKikgPSAxJztcbiAgICAgICAgICB0eC5leGVjdXRlU3FsKHNxbCwgW3NlcV0sIGZ1bmN0aW9uICh0eCwgcmVzKSB7XG4gICAgICAgICAgICB2YXIgb3JwaGFuZWRBdHRhY2htZW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBvcnBoYW5lZEF0dGFjaG1lbnRzLnB1c2gocmVzLnJvd3MuaXRlbShpKS5kaWdlc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0eC5leGVjdXRlU3FsKFxuICAgICAgICAgICAgICAnREVMRVRFIEZST00gJyArIEJZX1NFUV9TVE9SRSArICcgV0hFUkUgc2VxPT8nLCBbc2VxXSk7XG4gICAgICAgICAgICB0eC5leGVjdXRlU3FsKFxuICAgICAgICAgICAgICAnREVMRVRFIEZST00gJyArIEFUVEFDSF9BTkRfU0VRX1NUT1JFICsgJyBXSEVSRSBzZXE9PycsIFtzZXFdKTtcbiAgICAgICAgICAgIG9ycGhhbmVkQXR0YWNobWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZGlnZXN0KSB7XG4gICAgICAgICAgICAgIHR4LmV4ZWN1dGVTcWwoXG4gICAgICAgICAgICAgICAgJ0RFTEVURSBGUk9NICcgKyBBVFRBQ0hfQU5EX1NFUV9TVE9SRSArICcgV0hFUkUgZGlnZXN0PT8nLFxuICAgICAgICAgICAgICAgIFtkaWdlc3RdKTtcbiAgICAgICAgICAgICAgdHguZXhlY3V0ZVNxbChcbiAgICAgICAgICAgICAgICAnREVMRVRFIEZST00gJyArIEFUVEFDSF9TVE9SRSArICcgV0hFUkUgZGlnZXN0PT8nLCBbZGlnZXN0XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCB1bmtub3duRXJyb3IoY2FsbGJhY2spLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xuXG4gIGFwaS5fZ2V0TG9jYWwgPSBmdW5jdGlvbiAoaWQsIGNhbGxiYWNrKSB7XG4gICAgZGIucmVhZFRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eCkge1xuICAgICAgdmFyIHNxbCA9ICdTRUxFQ1QganNvbiwgcmV2IEZST00gJyArIExPQ0FMX1NUT1JFICsgJyBXSEVSRSBpZD0/JztcbiAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLCBbaWRdLCBmdW5jdGlvbiAodHgsIHJlcykge1xuICAgICAgICBpZiAocmVzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByZXMucm93cy5pdGVtKDApO1xuICAgICAgICAgIHZhciBkb2MgPSB1bnN0cmluZ2lmeURvYyhpdGVtLmpzb24sIGlkLCBpdGVtLnJldik7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcnMuTUlTU0lOR19ET0MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBhcGkuX3B1dExvY2FsID0gZnVuY3Rpb24gKGRvYywgb3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgZGVsZXRlIGRvYy5fcmV2aXNpb25zOyAvLyBpZ25vcmUgdGhpcywgdHJ1c3QgdGhlIHJldlxuICAgIHZhciBvbGRSZXYgPSBkb2MuX3JldjtcbiAgICB2YXIgaWQgPSBkb2MuX2lkO1xuICAgIHZhciBuZXdSZXY7XG4gICAgaWYgKCFvbGRSZXYpIHtcbiAgICAgIG5ld1JldiA9IGRvYy5fcmV2ID0gJzAtMSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1JldiA9IGRvYy5fcmV2ID0gJzAtJyArIChwYXJzZUludChvbGRSZXYuc3BsaXQoJy0nKVsxXSwgMTApICsgMSk7XG4gICAgfVxuICAgIHZhciBqc29uID0gc3RyaW5naWZ5RG9jKGRvYyk7XG5cbiAgICB2YXIgcmV0O1xuICAgIGZ1bmN0aW9uIHB1dExvY2FsKHR4KSB7XG4gICAgICB2YXIgc3FsO1xuICAgICAgdmFyIHZhbHVlcztcbiAgICAgIGlmIChvbGRSZXYpIHtcbiAgICAgICAgc3FsID0gJ1VQREFURSAnICsgTE9DQUxfU1RPUkUgKyAnIFNFVCByZXY9PywganNvbj0/ICcgK1xuICAgICAgICAgICdXSEVSRSBpZD0/IEFORCByZXY9Pyc7XG4gICAgICAgIHZhbHVlcyA9IFtuZXdSZXYsIGpzb24sIGlkLCBvbGRSZXZdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3FsID0gJ0lOU0VSVCBJTlRPICcgKyBMT0NBTF9TVE9SRSArICcgKGlkLCByZXYsIGpzb24pIFZBTFVFUyAoPyw/LD8pJztcbiAgICAgICAgdmFsdWVzID0gW2lkLCBuZXdSZXYsIGpzb25dO1xuICAgICAgfVxuICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIHZhbHVlcywgZnVuY3Rpb24gKHR4LCByZXMpIHtcbiAgICAgICAgaWYgKHJlcy5yb3dzQWZmZWN0ZWQpIHtcbiAgICAgICAgICByZXQgPSB7b2s6IHRydWUsIGlkOiBpZCwgcmV2OiBuZXdSZXZ9O1xuICAgICAgICAgIGlmIChvcHRzLmN0eCkgeyAvLyByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9ycy5SRVZfQ09ORkxJQ1QpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycy5SRVZfQ09ORkxJQ1QpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGFjayB0aGF0IHdlIGhhbmRsZWQgdGhlIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jdHgpIHtcbiAgICAgIHB1dExvY2FsKG9wdHMuY3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgIHB1dExvY2FsKHR4KTtcbiAgICAgIH0sIHVua25vd25FcnJvcihjYWxsYmFjayksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBhcGkuX3JlbW92ZUxvY2FsID0gZnVuY3Rpb24gKGRvYywgY2FsbGJhY2spIHtcbiAgICB2YXIgcmV0O1xuICAgIGRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eCkge1xuICAgICAgdmFyIHNxbCA9ICdERUxFVEUgRlJPTSAnICsgTE9DQUxfU1RPUkUgKyAnIFdIRVJFIGlkPT8gQU5EIHJldj0/JztcbiAgICAgIHZhciBwYXJhbXMgPSBbZG9jLl9pZCwgZG9jLl9yZXZdO1xuICAgICAgdHguZXhlY3V0ZVNxbChzcWwsIHBhcmFtcywgZnVuY3Rpb24gKHR4LCByZXMpIHtcbiAgICAgICAgaWYgKCFyZXMucm93c0FmZmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5SRVZfQ09ORkxJQ1QpO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IHtvazogdHJ1ZSwgaWQ6IGRvYy5faWQsIHJldjogJzAtMCd9O1xuICAgICAgfSk7XG4gICAgfSwgdW5rbm93bkVycm9yKGNhbGxiYWNrKSwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmV0KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuV2ViU3FsUG91Y2gudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAgIGdsb2JhbC5uYXZpZ2F0b3Iuc3FsaXRlUGx1Z2luICYmXG4gICAgICAgIGdsb2JhbC5uYXZpZ2F0b3Iuc3FsaXRlUGx1Z2luLm9wZW5EYXRhYmFzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuc3FsaXRlUGx1Z2luICYmIGdsb2JhbC5zcWxpdGVQbHVnaW4ub3BlbkRhdGFiYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5vcGVuRGF0YWJhc2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5XZWJTcWxQb3VjaC5kZXN0cm95ID0gdXRpbHMudG9Qcm9taXNlKGZ1bmN0aW9uIChuYW1lLCBvcHRzLCBjYWxsYmFjaykge1xuICBXZWJTcWxQb3VjaC5DaGFuZ2VzLnJlbW92ZUFsbExpc3RlbmVycyhuYW1lKTtcbiAgdmFyIHNpemUgPSBnZXRTaXplKG9wdHMpO1xuICB2YXIgZGIgPSBvcGVuREIobmFtZSwgUE9VQ0hfVkVSU0lPTiwgbmFtZSwgc2l6ZSk7XG4gIGRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eCkge1xuICAgIHZhciBzdG9yZXMgPSBbRE9DX1NUT1JFLCBCWV9TRVFfU1RPUkUsIEFUVEFDSF9TVE9SRSwgTUVUQV9TVE9SRSxcbiAgICAgIExPQ0FMX1NUT1JFLCBBVFRBQ0hfQU5EX1NFUV9TVE9SRV07XG4gICAgc3RvcmVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICB0eC5leGVjdXRlU3FsKCdEUk9QIFRBQkxFIElGIEVYSVNUUyAnICsgc3RvcmUsIFtdKTtcbiAgICB9KTtcbiAgfSwgdW5rbm93bkVycm9yKGNhbGxiYWNrKSwgZnVuY3Rpb24gKCkge1xuICAgIGlmICh1dGlscy5oYXNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgZGVsZXRlIGdsb2JhbC5sb2NhbFN0b3JhZ2VbJ19wb3VjaF9fd2Vic3FsZGJfJyArIG5hbWVdO1xuICAgICAgZGVsZXRlIGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHsnb2snOiB0cnVlfSk7XG4gIH0pO1xufSk7XG5cbldlYlNxbFBvdWNoLkNoYW5nZXMgPSBuZXcgdXRpbHMuQ2hhbmdlcygpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNxbFBvdWNoO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi9kZXBzL2Vycm9yc1wiOjEyLFwiLi4vZGVwcy9wYXJzZS1oZXhcIjoxNCxcIi4uL21lcmdlXCI6MjEsXCIuLi91dGlsc1wiOjI2LFwidnV2dXplbGFcIjo2MX1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xudmFyIG1lcmdlID0gX2RlcmVxXygnLi9tZXJnZScpO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oJy4vZGVwcy9lcnJvcnMnKTtcbnZhciBFRSA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBldmFsRmlsdGVyID0gX2RlcmVxXygnLi9ldmFsRmlsdGVyJyk7XG52YXIgZXZhbFZpZXcgPSBfZGVyZXFfKCcuL2V2YWxWaWV3Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZXM7XG51dGlscy5pbmhlcml0cyhDaGFuZ2VzLCBFRSk7XG5cbmZ1bmN0aW9uIENoYW5nZXMoZGIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIEVFLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5kYiA9IGRiO1xuICBvcHRzID0gb3B0cyA/IHV0aWxzLmNsb25lKG9wdHMpIDoge307XG4gIHZhciBvbGRDb21wbGV0ZSA9IGNhbGxiYWNrIHx8IG9wdHMuY29tcGxldGUgfHwgZnVuY3Rpb24gKCkge307XG4gIHZhciBjb21wbGV0ZSA9IG9wdHMuY29tcGxldGUgPSB1dGlscy5vbmNlKGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5lbWl0KCdjb21wbGV0ZScsIHJlc3ApO1xuICAgIH1cbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGRiLnJlbW92ZUxpc3RlbmVyKCdkZXN0cm95ZWQnLCBvbkRlc3Ryb3kpO1xuICB9KTtcbiAgaWYgKG9sZENvbXBsZXRlKSB7XG4gICAgc2VsZi5vbignY29tcGxldGUnLCBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgb2xkQ29tcGxldGUobnVsbCwgcmVzcCk7XG4gICAgfSk7XG4gICAgc2VsZi5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBvbGRDb21wbGV0ZShlcnIpO1xuICAgIH0pO1xuICB9XG4gIHZhciBvbGRPbkNoYW5nZSA9IG9wdHMub25DaGFuZ2U7XG4gIGlmIChvbGRPbkNoYW5nZSkge1xuICAgIHNlbGYub24oJ2NoYW5nZScsIG9sZE9uQ2hhbmdlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7XG4gICAgc2VsZi5jYW5jZWwoKTtcbiAgfVxuICBkYi5vbmNlKCdkZXN0cm95ZWQnLCBvbkRlc3Ryb3kpO1xuXG4gIG9wdHMub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgaWYgKG9wdHMuaXNDYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdjaGFuZ2UnLCBjaGFuZ2UpO1xuICAgIGlmIChzZWxmLnN0YXJ0U2VxICYmIHNlbGYuc3RhcnRTZXEgPD0gY2hhbmdlLnNlcSkge1xuICAgICAgc2VsZi5lbWl0KCd1cHRvZGF0ZScpO1xuICAgICAgc2VsZi5zdGFydFNlcSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlLmRlbGV0ZWQpIHtcbiAgICAgIHNlbGYuZW1pdCgnZGVsZXRlJywgY2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5jaGFuZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgY2hhbmdlLmNoYW5nZXNbMF0ucmV2LnNsaWNlKDAsIDIpID09PSAnMS0nKSB7XG4gICAgICBzZWxmLmVtaXQoJ2NyZWF0ZScsIGNoYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgdXRpbHMuUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XG4gICAgb3B0cy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocmVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgc2VsZi5vbmNlKCdjYW5jZWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9sZE9uQ2hhbmdlKSB7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCBvbGRPbkNoYW5nZSk7XG4gICAgfVxuICAgIG9wdHMuY29tcGxldGUobnVsbCwge3N0YXR1czogJ2NhbmNlbGxlZCd9KTtcbiAgfSk7XG4gIHRoaXMudGhlbiA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpO1xuICB0aGlzWydjYXRjaCddID0gcHJvbWlzZVsnY2F0Y2gnXS5iaW5kKHByb21pc2UpO1xuICB0aGlzLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGNvbXBsZXRlKG51bGwsIHJlc3VsdCk7XG4gIH0sIGNvbXBsZXRlKTtcblxuXG5cbiAgaWYgKCFkYi50YXNrcXVldWUuaXNSZWFkeSkge1xuICAgIGRiLnRhc2txdWV1ZS5hZGRUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2FuY2VsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmRvQ2hhbmdlcyhvcHRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRvQ2hhbmdlcyhvcHRzKTtcbiAgfVxufVxuQ2hhbmdlcy5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgaWYgKHRoaXMuZGIudGFza3F1ZXVlLmlzUmVhZHkpIHtcbiAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xuICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NoYW5nZShkb2MsIG1ldGFkYXRhLCBvcHRzKSB7XG4gIHZhciBjaGFuZ2VMaXN0ID0gW3tyZXY6IGRvYy5fcmV2fV07XG4gIGlmIChvcHRzLnN0eWxlID09PSAnYWxsX2RvY3MnKSB7XG4gICAgY2hhbmdlTGlzdCA9IG1lcmdlLmNvbGxlY3RMZWF2ZXMobWV0YWRhdGEucmV2X3RyZWUpXG4gICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4ge3JldjogeC5yZXZ9OyB9KTtcbiAgfVxuICB2YXIgY2hhbmdlID0ge1xuICAgIGlkOiBtZXRhZGF0YS5pZCxcbiAgICBjaGFuZ2VzOiBjaGFuZ2VMaXN0LFxuICAgIGRvYzogZG9jXG4gIH07XG5cbiAgaWYgKHV0aWxzLmlzRGVsZXRlZChtZXRhZGF0YSwgZG9jLl9yZXYpKSB7XG4gICAgY2hhbmdlLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRzLmNvbmZsaWN0cykge1xuICAgIGNoYW5nZS5kb2MuX2NvbmZsaWN0cyA9IG1lcmdlLmNvbGxlY3RDb25mbGljdHMobWV0YWRhdGEpO1xuICAgIGlmICghY2hhbmdlLmRvYy5fY29uZmxpY3RzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIGNoYW5nZS5kb2MuX2NvbmZsaWN0cztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZTtcbn1cblxuQ2hhbmdlcy5wcm90b3R5cGUuZG9DaGFuZ2VzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FsbGJhY2sgPSBvcHRzLmNvbXBsZXRlO1xuXG4gIG9wdHMgPSB1dGlscy5jbG9uZShvcHRzKTtcbiAgaWYgKCdsaXZlJyBpbiBvcHRzICYmICEoJ2NvbnRpbnVvdXMnIGluIG9wdHMpKSB7XG4gICAgb3B0cy5jb250aW51b3VzID0gb3B0cy5saXZlO1xuICB9XG4gIG9wdHMucHJvY2Vzc0NoYW5nZSA9IHByb2Nlc3NDaGFuZ2U7XG5cbiAgaWYgKG9wdHMuc2luY2UgPT09ICdsYXRlc3QnKSB7XG4gICAgb3B0cy5zaW5jZSA9ICdub3cnO1xuICB9XG4gIGlmICghb3B0cy5zaW5jZSkge1xuICAgIG9wdHMuc2luY2UgPSAwO1xuICB9XG4gIGlmIChvcHRzLnNpbmNlID09PSAnbm93Jykge1xuICAgIHRoaXMuZGIuaW5mbygpLnRoZW4oZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIGlmIChzZWxmLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHtzdGF0dXM6ICdjYW5jZWxsZWQnfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9wdHMuc2luY2UgPSBpbmZvLnVwZGF0ZV9zZXEgIC0gMTtcbiAgICAgIHNlbGYuZG9DaGFuZ2VzKG9wdHMpO1xuICAgIH0sIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob3B0cy5jb250aW51b3VzICYmIG9wdHMuc2luY2UgIT09ICdub3cnKSB7XG4gICAgdGhpcy5kYi5pbmZvKCkudGhlbihmdW5jdGlvbiAoaW5mbykge1xuICAgICAgc2VsZi5zdGFydFNlcSA9IGluZm8udXBkYXRlX3NlcSAtIDE7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVyci5pZCA9PT0gJ2lkYk51bGwnKSB7XG4gICAgICAgIC8vZGIgY2xvc2VkIGJlZm9yZSB0aGlzIHJldHVybmVkXG4gICAgICAgIC8vdGhhdHMgb2tcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuZGIudHlwZSgpICE9PSAnaHR0cCcgJiZcbiAgICBvcHRzLmZpbHRlciAmJiB0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyQ2hhbmdlcyhvcHRzKTtcbiAgfVxuXG4gIGlmICghKCdkZXNjZW5kaW5nJyBpbiBvcHRzKSkge1xuICAgIG9wdHMuZGVzY2VuZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gMCBhbmQgMSBzaG91bGQgcmV0dXJuIDEgZG9jdW1lbnRcbiAgb3B0cy5saW1pdCA9IG9wdHMubGltaXQgPT09IDAgPyAxIDogb3B0cy5saW1pdDtcbiAgb3B0cy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xuICB2YXIgbmV3UHJvbWlzZSA9IHRoaXMuZGIuX2NoYW5nZXMob3B0cyk7XG4gIGlmIChuZXdQcm9taXNlICYmIHR5cGVvZiBuZXdQcm9taXNlLmNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBjYW5jZWwgPSBzZWxmLmNhbmNlbDtcbiAgICBzZWxmLmNhbmNlbCA9IHV0aWxzLmdldEFyZ3VtZW50cyhmdW5jdGlvbiAoYXJncykge1xuICAgICAgbmV3UHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgIGNhbmNlbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufTtcblxuQ2hhbmdlcy5wcm90b3R5cGUuZmlsdGVyQ2hhbmdlcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhbGxiYWNrID0gb3B0cy5jb21wbGV0ZTtcbiAgaWYgKG9wdHMuZmlsdGVyID09PSAnX3ZpZXcnKSB7XG4gICAgaWYgKCFvcHRzLnZpZXcgfHwgdHlwZW9mIG9wdHMudmlldyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgIEVycm9yKCdgdmlld2AgZmlsdGVyIHBhcmFtZXRlciBpcyBub3QgcHJvdmlkZWQuJyk7XG4gICAgICBlcnIuc3RhdHVzID0gZXJyb3JzLkJBRF9SRVFVRVNULnN0YXR1cztcbiAgICAgIGVyci5uYW1lID0gZXJyb3JzLkJBRF9SRVFVRVNULm5hbWU7XG4gICAgICBlcnIuZXJyb3IgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZmV0Y2ggYSB2aWV3IGZyb20gYSBkZXNpZ24gZG9jLCBtYWtlIGl0IGJlaGF2ZSBsaWtlIGEgZmlsdGVyXG4gICAgdmFyIHZpZXdOYW1lID0gb3B0cy52aWV3LnNwbGl0KCcvJyk7XG4gICAgdGhpcy5kYi5nZXQoJ19kZXNpZ24vJyArIHZpZXdOYW1lWzBdLCBmdW5jdGlvbiAoZXJyLCBkZG9jKSB7XG4gICAgICBpZiAoc2VsZi5pc0NhbmNlbGxlZCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB7c3RhdHVzOiAnY2FuY2VsbGVkJ30pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkZG9jICYmIGRkb2Mudmlld3MgJiYgZGRvYy52aWV3c1t2aWV3TmFtZVsxXV0pIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBmaWx0ZXIgPSBldmFsVmlldyhkZG9jLnZpZXdzW3ZpZXdOYW1lWzFdXS5tYXApO1xuICAgICAgICBvcHRzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgc2VsZi5kb0NoYW5nZXMob3B0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtc2cgPSBkZG9jLnZpZXdzID8gJ21pc3NpbmcganNvbiBrZXk6ICcgKyB2aWV3TmFtZVsxXSA6XG4gICAgICAgICdtaXNzaW5nIGpzb24ga2V5OiB2aWV3cyc7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBlcnIgPSBuZXcgIEVycm9yKG1zZyk7XG4gICAgICAgIGVyci5zdGF0dXMgPSBlcnJvcnMuTUlTU0lOR19ET0Muc3RhdHVzO1xuICAgICAgICBlcnIubmFtZSA9IGVycm9ycy5NSVNTSU5HX0RPQy5uYW1lO1xuICAgICAgICBlcnIuZXJyb3IgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmZXRjaCBhIGZpbHRlciBmcm9tIGEgZGVzaWduIGRvY1xuICAgIHZhciBmaWx0ZXJOYW1lID0gb3B0cy5maWx0ZXIuc3BsaXQoJy8nKTtcbiAgICB0aGlzLmRiLmdldCgnX2Rlc2lnbi8nICsgZmlsdGVyTmFtZVswXSwgZnVuY3Rpb24gKGVyciwgZGRvYykge1xuICAgICAgaWYgKHNlbGYuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwge3N0YXR1czogJ2NhbmNlbGxlZCd9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGRvYyAmJiBkZG9jLmZpbHRlcnMgJiYgZGRvYy5maWx0ZXJzW2ZpbHRlck5hbWVbMV1dKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBldmFsRmlsdGVyKGRkb2MuZmlsdGVyc1tmaWx0ZXJOYW1lWzFdXSk7XG4gICAgICAgIG9wdHMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICBzZWxmLmRvQ2hhbmdlcyhvcHRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1zZyA9IChkZG9jICYmIGRkb2MuZmlsdGVycykgPyAnbWlzc2luZyBqc29uIGtleTogJyArIGZpbHRlck5hbWVbMV1cbiAgICAgICAgICA6ICdtaXNzaW5nIGpzb24ga2V5OiBmaWx0ZXJzJztcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgIEVycm9yKG1zZyk7XG4gICAgICAgICAgZXJyLnN0YXR1cyA9IGVycm9ycy5NSVNTSU5HX0RPQy5zdGF0dXM7XG4gICAgICAgICAgZXJyLm5hbWUgPSBlcnJvcnMuTUlTU0lOR19ET0MubmFtZTtcbiAgICAgICAgICBlcnIuZXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbn0se1wiLi9kZXBzL2Vycm9yc1wiOjEyLFwiLi9ldmFsRmlsdGVyXCI6MTgsXCIuL2V2YWxWaWV3XCI6MTksXCIuL21lcmdlXCI6MjEsXCIuL3V0aWxzXCI6MjYsXCJldmVudHNcIjozMH1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrcG9pbnQoZGIsIGlkLCBjaGVja3BvaW50LCByZXR1cm5WYWx1ZSkge1xuICByZXR1cm4gZGIuZ2V0KGlkKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICBpZiAoZGIudHlwZSgpID09PSAnaHR0cCcpIHtcbiAgICAgICAgdXRpbHMuZXhwbGFpbjQwNChcbiAgICAgICAgICAnUG91Y2hEQiBpcyBqdXN0IGNoZWNraW5nIGlmIGEgcmVtb3RlIGNoZWNrcG9pbnQgZXhpc3RzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtfaWQ6IGlkfTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9KS50aGVuKGZ1bmN0aW9uIChkb2MpIHtcbiAgICBpZiAocmV0dXJuVmFsdWUuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvYy5sYXN0X3NlcSA9IGNoZWNrcG9pbnQ7XG4gICAgcmV0dXJuIGRiLnB1dChkb2MpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gQ2hlY2twb2ludGVyKHNyYywgdGFyZ2V0LCBpZCwgcmV0dXJuVmFsdWUpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcbn1cblxuQ2hlY2twb2ludGVyLnByb3RvdHlwZS53cml0ZUNoZWNrcG9pbnQgPSBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLnVwZGF0ZVRhcmdldChjaGVja3BvaW50KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZi51cGRhdGVTb3VyY2UoY2hlY2twb2ludCk7XG4gIH0pO1xufTtcblxuQ2hlY2twb2ludGVyLnByb3RvdHlwZS51cGRhdGVUYXJnZXQgPSBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICByZXR1cm4gdXBkYXRlQ2hlY2twb2ludCh0aGlzLnRhcmdldCwgdGhpcy5pZCwgY2hlY2twb2ludCwgdGhpcy5yZXR1cm5WYWx1ZSk7XG59O1xuXG5DaGVja3BvaW50ZXIucHJvdG90eXBlLnVwZGF0ZVNvdXJjZSA9IGZ1bmN0aW9uIChjaGVja3BvaW50KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMucmVhZE9ubHlTb3VyY2UpIHtcbiAgICByZXR1cm4gdXRpbHMuUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICB9XG4gIHJldHVybiB1cGRhdGVDaGVja3BvaW50KHRoaXMuc3JjLCB0aGlzLmlkLCBjaGVja3BvaW50LCB0aGlzLnJldHVyblZhbHVlKVtcbiAgICBcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHZhciBpc0ZvcmJpZGRlbiA9IHR5cGVvZiBlcnIuc3RhdHVzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBNYXRoLmZsb29yKGVyci5zdGF0dXMgLyAxMDApID09PSA0O1xuICAgICAgaWYgKGlzRm9yYmlkZGVuKSB7XG4gICAgICAgIHNlbGYucmVhZE9ubHlTb3VyY2UgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn07XG5cbkNoZWNrcG9pbnRlci5wcm90b3R5cGUuZ2V0Q2hlY2twb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gc2VsZi50YXJnZXQuZ2V0KHNlbGYuaWQpLnRoZW4oZnVuY3Rpb24gKHRhcmdldERvYykge1xuICAgIHJldHVybiBzZWxmLnNyYy5nZXQoc2VsZi5pZCkudGhlbihmdW5jdGlvbiAoc291cmNlRG9jKSB7XG4gICAgICBpZiAodGFyZ2V0RG9jLmxhc3Rfc2VxID09PSBzb3VyY2VEb2MubGFzdF9zZXEpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZURvYy5sYXN0X3NlcTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQgJiYgdGFyZ2V0RG9jLmxhc3Rfc2VxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNyYy5wdXQoe1xuICAgICAgICAgIF9pZDogc2VsZi5pZCxcbiAgICAgICAgICBsYXN0X3NlcTogMFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIHNlbGYucmVhZE9ubHlTb3VyY2UgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldERvYy5sYXN0X3NlcTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyLnN0YXR1cyAhPT0gNDA0KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hlY2twb2ludGVyO1xuXG59LHtcIi4vdXRpbHNcIjoyNn1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLypnbG9iYWxzIGNvcmRvdmEgKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQWRhcHRlciA9IF9kZXJlcV8oJy4vYWRhcHRlcicpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xudmFyIFRhc2tRdWV1ZSA9IF9kZXJlcV8oJy4vdGFza3F1ZXVlJyk7XG52YXIgUHJvbWlzZSA9IHV0aWxzLlByb21pc2U7XG5cbmZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhlcnIpIHtcbiAgaWYgKGVyciAmJiBnbG9iYWwuZGVidWcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxudXRpbHMuaW5oZXJpdHMoUG91Y2hEQiwgQWRhcHRlcik7XG5mdW5jdGlvbiBQb3VjaERCKG5hbWUsIG9wdHMsIGNhbGxiYWNrKSB7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvdWNoREIpKSB7XG4gICAgcmV0dXJuIG5ldyBQb3VjaERCKG5hbWUsIG9wdHMsIGNhbGxiYWNrKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IG5hbWU7XG4gICAgbmFtZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIGNhbGxiYWNrID0gZGVmYXVsdENhbGxiYWNrO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLl9fb3B0cyA9IG9wdHM7XG4gIHZhciBvbGRDQiA9IGNhbGxiYWNrO1xuICBzZWxmLmF1dG9fY29tcGFjdGlvbiA9IG9wdHMuYXV0b19jb21wYWN0aW9uO1xuICBzZWxmLnByZWZpeCA9IFBvdWNoREIucHJlZml4O1xuICBBZGFwdGVyLmNhbGwoc2VsZik7XG4gIHNlbGYudGFza3F1ZXVlID0gbmV3IFRhc2tRdWV1ZSgpO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlc3AudGhlbjtcbiAgICAgIGZ1bGZpbGwocmVzcCk7XG4gICAgfTtcbiAgXG4gICAgb3B0cyA9IHV0aWxzLmNsb25lKG9wdHMpO1xuICAgIHZhciBvcmlnaW5hbE5hbWUgPSBvcHRzLm5hbWUgfHwgbmFtZTtcbiAgICB2YXIgYmFja2VuZCwgZXJyb3I7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pc3NpbmcvaW52YWxpZCBEQiBuYW1lJyk7XG4gICAgICAgICAgZXJyb3IuY29kZSA9IDQwMDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2tlbmQgPSBQb3VjaERCLnBhcnNlQWRhcHRlcihvcmlnaW5hbE5hbWUsIG9wdHMpO1xuICAgICAgICBcbiAgICAgICAgb3B0cy5vcmlnaW5hbE5hbWUgPSBvcmlnaW5hbE5hbWU7XG4gICAgICAgIG9wdHMubmFtZSA9IGJhY2tlbmQubmFtZTtcbiAgICAgICAgaWYgKG9wdHMucHJlZml4ICYmIGJhY2tlbmQuYWRhcHRlciAhPT0gJ2h0dHAnICYmXG4gICAgICAgICAgICBiYWNrZW5kLmFkYXB0ZXIgIT09ICdodHRwcycpIHtcbiAgICAgICAgICBvcHRzLm5hbWUgPSBvcHRzLnByZWZpeCArIG9wdHMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmFkYXB0ZXIgPSBvcHRzLmFkYXB0ZXIgfHwgYmFja2VuZC5hZGFwdGVyO1xuICAgICAgICBzZWxmLl9hZGFwdGVyID0gb3B0cy5hZGFwdGVyO1xuICAgICAgICBzZWxmLl9kYl9uYW1lID0gb3JpZ2luYWxOYW1lO1xuICAgICAgICBpZiAoIVBvdWNoREIuYWRhcHRlcnNbb3B0cy5hZGFwdGVyXSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBZGFwdGVyIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICBlcnJvci5jb2RlID0gNDA0O1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFQb3VjaERCLmFkYXB0ZXJzW29wdHMuYWRhcHRlcl0udmFsaWQoKSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIEFkYXB0ZXInKTtcbiAgICAgICAgICBlcnJvci5jb2RlID0gNDA0O1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi50YXNrcXVldWUuZmFpbChlcnIpO1xuICAgICAgICBzZWxmLmNoYW5nZXMgPSB1dGlscy50b1Byb21pc2UoZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICBpZiAob3B0cy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgb3B0cy5jb21wbGV0ZShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSgpKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiByZWplY3QoZXJyb3IpOyAvLyBjb25zdHJ1Y3RvciBlcnJvciwgc2VlIGFib3ZlXG4gICAgfVxuICAgIHNlbGYuYWRhcHRlciA9IG9wdHMuYWRhcHRlcjtcblxuICAgIC8vIG5lZWRzIGFjY2VzcyB0byBQb3VjaERCO1xuICAgIHNlbGYucmVwbGljYXRlID0ge307XG5cbiAgICBzZWxmLnJlcGxpY2F0ZS5mcm9tID0gZnVuY3Rpb24gKHVybCwgb3B0cywgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBzZWxmLmNvbnN0cnVjdG9yLnJlcGxpY2F0ZSh1cmwsIHNlbGYsIG9wdHMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXBsaWNhdGUudG8gPSBmdW5jdGlvbiAodXJsLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNlbGYuY29uc3RydWN0b3IucmVwbGljYXRlKHNlbGYsIHVybCwgb3B0cywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBzZWxmLnN5bmMgPSBmdW5jdGlvbiAoZGJOYW1lLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNlbGYuY29uc3RydWN0b3Iuc3luYyhzZWxmLCBkYk5hbWUsIG9wdHMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXBsaWNhdGUuc3luYyA9IHNlbGYuc3luYztcblxuICAgIHNlbGYuZGVzdHJveSA9IHV0aWxzLmFkYXB0ZXJGdW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYuaW5mbyhmdW5jdGlvbiAoZXJyLCBpbmZvKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmNvbnN0cnVjdG9yLmRlc3Ryb3koaW5mby5kYl9uYW1lLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIFBvdWNoREIuYWRhcHRlcnNbb3B0cy5hZGFwdGVyXS5jYWxsKHNlbGYsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIGRiKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHNlbGYudGFza3F1ZXVlLmZhaWwoZXJyKTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRlc3RydWN0aW9uTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnZGVzdHJveWVkJykge1xuICAgICAgICAgIHNlbGYuZW1pdCgnZGVzdHJveWVkJyk7XG4gICAgICAgICAgUG91Y2hEQi5yZW1vdmVMaXN0ZW5lcihvcmlnaW5hbE5hbWUsIGRlc3RydWN0aW9uTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBQb3VjaERCLm9uKG9yaWdpbmFsTmFtZSwgZGVzdHJ1Y3Rpb25MaXN0ZW5lcik7XG4gICAgICBzZWxmLmVtaXQoJ2NyZWF0ZWQnLCBzZWxmKTtcbiAgICAgIFBvdWNoREIuZW1pdCgnY3JlYXRlZCcsIG9wdHMub3JpZ2luYWxOYW1lKTtcbiAgICAgIHNlbGYudGFza3F1ZXVlLnJlYWR5KHNlbGYpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgc2VsZik7XG4gICAgICBcbiAgICB9KTtcbiAgICBpZiAob3B0cy5za2lwU2V0dXApIHtcbiAgICAgIHNlbGYudGFza3F1ZXVlLnJlYWR5KHNlbGYpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0NvcmRvdmEoKSkge1xuICAgICAgLy90byBpbmZvcm0gd2Vic3FsIGFkYXB0ZXIgdGhhdCB3ZSBjYW4gdXNlIGFwaVxuICAgICAgY29yZG92YS5maXJlV2luZG93RXZlbnQob3B0cy5uYW1lICsgXCJfcG91Y2hcIiwge30pO1xuICAgIH1cbiAgfSk7XG4gIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgIG9sZENCKG51bGwsIHJlc3ApO1xuICB9LCBvbGRDQik7XG4gIHNlbGYudGhlbiA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpO1xuICBzZWxmW1wiY2F0Y2hcIl0gPSBwcm9taXNlW1wiY2F0Y2hcIl0uYmluZChwcm9taXNlKTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvdWNoREI7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vYWRhcHRlclwiOjEsXCIuL3Rhc2txdWV1ZVwiOjI1LFwiLi91dGlsc1wiOjI2fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZUJsb2IgPSBfZGVyZXFfKCcuL2Jsb2IuanMnKTtcbnZhciBlcnJvcnMgPSBfZGVyZXFfKCcuL2Vycm9ycycpO1xudmFyIHV0aWxzID0gX2RlcmVxXyhcIi4uL3V0aWxzXCIpO1xudmFyIGhhc1VwbG9hZDtcblxuZnVuY3Rpb24gYWpheChvcHRpb25zLCBhZGFwdGVyQ2FsbGJhY2spIHtcblxuICB2YXIgcmVxdWVzdENvbXBsZXRlZCA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2sgPSB1dGlscy5nZXRBcmd1bWVudHMoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAocmVxdWVzdENvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhZGFwdGVyQ2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgcmVxdWVzdENvbXBsZXRlZCA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMgPSB1dGlscy5jbG9uZShvcHRpb25zKTtcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kIDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiB7fSxcbiAgICBqc29uOiB0cnVlLFxuICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwMDAwLFxuICAgIGNhY2hlOiBmYWxzZVxuICB9O1xuXG4gIG9wdGlvbnMgPSB1dGlscy5leHRlbmQodHJ1ZSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIGNhY2hlLWJ1c3Rlciwgc3BlY2lmaWNhbGx5IGRlc2lnbmVkIHRvIHdvcmsgYXJvdW5kIElFJ3MgYWdncmVzc2l2ZSBjYWNoaW5nXG4gIC8vIHNlZSBodHRwOi8vd3d3LmRhc2hiYXkuY29tLzIwMTEvMDUvaW50ZXJuZXQtZXhwbG9yZXItY2FjaGVzLWFqYXgvXG4gIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcgJiYgIW9wdGlvbnMuY2FjaGUpIHtcbiAgICB2YXIgaGFzQXJncyA9IG9wdGlvbnMudXJsLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgb3B0aW9ucy51cmwgKz0gKGhhc0FyZ3MgPyAnJicgOiAnPycpICsgJ19ub25jZT0nICsgdXRpbHMudXVpZCgxNik7XG4gIH1cblxuICBmdW5jdGlvbiBvblN1Y2Nlc3Mob2JqLCByZXNwLCBjYikge1xuICAgIGlmICghb3B0aW9ucy5iaW5hcnkgJiYgIW9wdGlvbnMuanNvbiAmJiBvcHRpb25zLnByb2Nlc3NEYXRhICYmXG4gICAgICB0eXBlb2Ygb2JqICE9PSAnc3RyaW5nJykge1xuICAgICAgb2JqID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmJpbmFyeSAmJiBvcHRpb25zLmpzb24gJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUHJvYmFibHkgYSBtYWxmb3JtZWQgSlNPTiBmcm9tIHNlcnZlclxuICAgICAgICByZXR1cm4gY2IoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIG9iaiA9IG9iai5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgaWYgKHYub2spIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2LmVycm9yICYmIHYuZXJyb3IgPT09ICdjb25mbGljdCcpIHtcbiAgICAgICAgICBvYmogPSBlcnJvcnMuUkVWX0NPTkZMSUNUO1xuICAgICAgICAgIG9iai5pZCA9IHYuaWQ7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBlbHNlIGlmICh2LmVycm9yICYmIHYuZXJyb3IgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgb2JqID0gZXJyb3JzLkZPUkJJRERFTjtcbiAgICAgICAgICBvYmouaWQgPSB2LmlkO1xuICAgICAgICAgIG9iai5yZWFzb24gPSB2LnJlYXNvbjtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9IGVsc2UgaWYgKHYubWlzc2luZykge1xuICAgICAgICAgIG9iaiA9IGVycm9ycy5NSVNTSU5HX0RPQztcbiAgICAgICAgICBvYmoubWlzc2luZyA9IHYubWlzc2luZztcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2IobnVsbCwgb2JqLCByZXNwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyLCBjYikge1xuICAgIHZhciBlcnJQYXJzZWQsIGVyck9iaiwgZXJyVHlwZSwga2V5O1xuICAgIHRyeSB7XG4gICAgICBlcnJQYXJzZWQgPSBKU09OLnBhcnNlKGVyci5yZXNwb25zZVRleHQpO1xuICAgICAgLy93b3VsZCBwcmVmZXIgbm90IHRvIGhhdmUgYSB0cnkvY2F0Y2ggY2xhdXNlXG4gICAgICBmb3IgKGtleSBpbiBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICBlcnJvcnNba2V5XS5uYW1lID09PSBlcnJQYXJzZWQuZXJyb3IpIHtcbiAgICAgICAgICBlcnJUeXBlID0gZXJyb3JzW2tleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZXJyVHlwZSkge1xuICAgICAgICBlcnJUeXBlID0gZXJyb3JzLlVOS05PV05fRVJST1I7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzKSB7XG4gICAgICAgICAgZXJyVHlwZS5zdGF0dXMgPSBlcnIuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIuc3RhdHVzVGV4dCkge1xuICAgICAgICAgIGVyci5uYW1lID0gZXJyLnN0YXR1c1RleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVyck9iaiA9IGVycm9ycy5lcnJvcihlcnJUeXBlLCBlcnJQYXJzZWQucmVhc29uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXJyb3JzKSB7XG4gICAgICAgIGlmIChlcnJvcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBlcnJvcnNba2V5XS5zdGF0dXMgPT09IGVyci5zdGF0dXMpIHtcbiAgICAgICAgICBlcnJUeXBlID0gZXJyb3JzW2tleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZXJyVHlwZSkge1xuICAgICAgICBlcnJUeXBlID0gZXJyb3JzLlVOS05PV05fRVJST1I7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzKSB7XG4gICAgICAgICAgZXJyVHlwZS5zdGF0dXMgPSBlcnIuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIuc3RhdHVzVGV4dCkge1xuICAgICAgICAgIGVyci5uYW1lID0gZXJyLnN0YXR1c1RleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVyck9iaiA9IGVycm9ycy5lcnJvcihlcnJUeXBlKTtcbiAgICB9XG4gICAgaWYgKGVyci53aXRoQ3JlZGVudGlhbHMgJiYgZXJyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgLy8gYXBwYXJlbnRseSB0aGlzIGlzIHdoYXQgd2UgZ2V0IHdoZW4gdGhlIG1ldGhvZFxuICAgICAgLy8gaXMgcmVwb3J0ZWQgYXMgbm90IGFsbG93ZWQgYnkgQ09SUy4gc28gZnVkZ2UgaXRcbiAgICAgIGVyck9iai5zdGF0dXMgPSA0MDU7XG4gICAgICBlcnJPYmouc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgfVxuICAgIGNiKGVyck9iaik7XG4gIH1cblxuICB2YXIgdGltZXI7XG4gIHZhciB4aHI7XG4gIGlmIChvcHRpb25zLnhocikge1xuICAgIHhociA9IG5ldyBvcHRpb25zLnhocigpO1xuICB9IGVsc2Uge1xuICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG4gIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCk7XG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zLmpzb24pIHtcbiAgICBvcHRpb25zLmhlYWRlcnMuQWNjZXB0ID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8XG4gICAgICAnYXBwbGljYXRpb24vanNvbic7XG4gICAgaWYgKG9wdGlvbnMuYm9keSAmJlxuICAgICAgICBvcHRpb25zLnByb2Nlc3NEYXRhICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuYmluYXJ5KSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB2YXIgY3JlYXRlQ29va2llID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBkYXlzKSB7XG4gICAgdmFyIGV4cGlyZXMgPSBcIlwiO1xuICAgIGlmIChkYXlzKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgIGV4cGlyZXMgPSBcIjsgZXhwaXJlcz1cIiArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuY29va2llID0gbmFtZSArIFwiPVwiICsgdmFsdWUgKyBleHBpcmVzICsgXCI7IHBhdGg9L1wiO1xuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBpZiAoa2V5ID09PSAnQ29va2llJykge1xuICAgICAgdmFyIGNvb2tpZSA9IG9wdGlvbnMuaGVhZGVyc1trZXldLnNwbGl0KCc9Jyk7XG4gICAgICBjcmVhdGVDb29raWUoY29va2llWzBdLCBjb29raWVbMV0sIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRpb25zLmhlYWRlcnNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEoXCJib2R5XCIgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmJvZHkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGFib3J0UmVxID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXF1ZXN0Q29tcGxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHhoci5hYm9ydCgpO1xuICAgIG9uRXJyb3IoeGhyLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQgfHwgcmVxdWVzdENvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmIChvcHRpb25zLmJpbmFyeSkge1xuICAgICAgICBkYXRhID0gY3JlYXRlQmxvYihbeGhyLnJlc3BvbnNlIHx8ICcnXSwge1xuICAgICAgICAgIHR5cGU6IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJylcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH1cbiAgICAgIG9uU3VjY2VzcyhkYXRhLCB4aHIsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcih4aHIsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoYWJvcnRSZXEsIG9wdGlvbnMudGltZW91dCk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGFib3J0UmVxLCBvcHRpb25zLnRpbWVvdXQpO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBoYXNVcGxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJRSB0aHJvd3MgYW4gZXJyb3IgaWYgeW91IHRyeSB0byBhY2Nlc3MgaXQgZGlyZWN0bHlcbiAgICAgIGhhc1VwbG9hZCA9IE9iamVjdC5rZXlzKHhocikuaW5kZXhPZigndXBsb2FkJykgIT09IC0xO1xuICAgIH1cbiAgICBpZiAoaGFzVXBsb2FkKSB7IC8vIGRvZXMgbm90IGV4aXN0IGluIGllOVxuICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0geGhyLm9ucHJvZ3Jlc3M7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmJvZHkgJiYgKG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgdXRpbHMucmVhZEFzQmluYXJ5U3RyaW5nKG9wdGlvbnMuYm9keSwgZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgICAgeGhyLnNlbmQodXRpbHMuZml4QmluYXJ5KGJpbmFyeSkpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHhoci5zZW5kKG9wdGlvbnMuYm9keSk7XG4gIH1cbiAgcmV0dXJuIHthYm9ydDogYWJvcnRSZXF9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFqYXg7XG5cbn0se1wiLi4vdXRpbHNcIjoyNixcIi4vYmxvYi5qc1wiOjEwLFwiLi9lcnJvcnNcIjoxMn1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblwidXNlIHN0cmljdFwiO1xuXG4vL0Fic3RyYWN0cyBjb25zdHJ1Y3RpbmcgYSBCbG9iIG9iamVjdCwgc28gaXQgYWxzbyB3b3JrcyBpbiBvbGRlclxuLy9icm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBCbG9iIGNvbnN0cnVjdG9yLiAoaS5lLlxuLy9vbGQgUXRXZWJLaXQgdmVyc2lvbnMsIGF0IGxlYXN0KS5cbmZ1bmN0aW9uIGNyZWF0ZUJsb2IocGFydHMsIHByb3BlcnRpZXMpIHtcbiAgcGFydHMgPSBwYXJ0cyB8fCBbXTtcbiAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKHBhcnRzLCBwcm9wZXJ0aWVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLm5hbWUgIT09IFwiVHlwZUVycm9yXCIpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHZhciBCbG9iQnVpbGRlciA9IGdsb2JhbC5CbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5NU0Jsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLk1vekJsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyO1xuICAgIHZhciBidWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgYnVpbGRlci5hcHBlbmQocGFydHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHByb3BlcnRpZXMudHlwZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCbG9iO1xuXG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5leHBvcnRzLk1hcCA9IExhenlNYXA7IC8vIFRPRE86IHVzZSBFUzYgbWFwXG5leHBvcnRzLlNldCA9IExhenlTZXQ7IC8vIFRPRE86IHVzZSBFUzYgc2V0XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbW9udGFnZWpzL2NvbGxlY3Rpb25zXG5mdW5jdGlvbiBMYXp5TWFwKCkge1xuICB0aGlzLnN0b3JlID0ge307XG59XG5MYXp5TWFwLnByb3RvdHlwZS5tYW5nbGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleSBtdXN0IGJlIGEgc3RyaW5nIGJ1dCBHb3QgXCIgKyBrZXkpO1xuICB9XG4gIHJldHVybiAnJCcgKyBrZXk7XG59O1xuTGF6eU1hcC5wcm90b3R5cGUudW5tYW5nbGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXkuc3Vic3RyaW5nKDEpO1xufTtcbkxhenlNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG1hbmdsZWQgPSB0aGlzLm1hbmdsZShrZXkpO1xuICBpZiAobWFuZ2xlZCBpbiB0aGlzLnN0b3JlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVbbWFuZ2xlZF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcbkxhenlNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBtYW5nbGVkID0gdGhpcy5tYW5nbGUoa2V5KTtcbiAgdGhpcy5zdG9yZVttYW5nbGVkXSA9IHZhbHVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5MYXp5TWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBtYW5nbGVkID0gdGhpcy5tYW5nbGUoa2V5KTtcbiAgcmV0dXJuIG1hbmdsZWQgaW4gdGhpcy5zdG9yZTtcbn07XG5MYXp5TWFwLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG1hbmdsZWQgPSB0aGlzLm1hbmdsZShrZXkpO1xuICBpZiAobWFuZ2xlZCBpbiB0aGlzLnN0b3JlKSB7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmVbbWFuZ2xlZF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbkxhenlNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNlbGYuc3RvcmUpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWx1ZSA9IHNlbGYuc3RvcmVba2V5XTtcbiAgICBrZXkgPSBzZWxmLnVubWFuZ2xlKGtleSk7XG4gICAgY2IodmFsdWUsIGtleSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gTGF6eVNldCgpIHtcbiAgdGhpcy5zdG9yZSA9IG5ldyBMYXp5TWFwKCk7XG59XG5MYXp5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiB0aGlzLnN0b3JlLnNldChrZXksIHRydWUpO1xufTtcbkxhenlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuc3RvcmUuaGFzKGtleSk7XG59O1xuTGF6eVNldC5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiB0aGlzLnN0b3JlW1wiZGVsZXRlXCJdKGtleSk7XG59O1xufSx7fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIFBvdWNoRXJyb3Iob3B0cykge1xuICB0aGlzLnN0YXR1cyA9IG9wdHMuc3RhdHVzO1xuICB0aGlzLm5hbWUgPSBvcHRzLmVycm9yO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRzLnJlYXNvbjtcbiAgdGhpcy5lcnJvciA9IHRydWU7XG59XG5cblBvdWNoRXJyb3IucHJvdG90eXBlX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG5Qb3VjaEVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgfSk7XG59O1xuXG5leHBvcnRzLlVOQVVUSE9SSVpFRCA9IG5ldyBQb3VjaEVycm9yKHtcbiAgc3RhdHVzOiA0MDEsXG4gIGVycm9yOiAndW5hdXRob3JpemVkJyxcbiAgcmVhc29uOiBcIk5hbWUgb3IgcGFzc3dvcmQgaXMgaW5jb3JyZWN0LlwiXG59KTtcbmV4cG9ydHMuTUlTU0lOR19CVUxLX0RPQ1MgPSBuZXcgUG91Y2hFcnJvcih7XG4gIHN0YXR1czogNDAwLFxuICBlcnJvcjogJ2JhZF9yZXF1ZXN0JyxcbiAgcmVhc29uOiBcIk1pc3NpbmcgSlNPTiBsaXN0IG9mICdkb2NzJ1wiXG59KTtcbmV4cG9ydHMuTUlTU0lOR19ET0MgPSBuZXcgUG91Y2hFcnJvcih7XG4gIHN0YXR1czogNDA0LFxuICBlcnJvcjogJ25vdF9mb3VuZCcsXG4gIHJlYXNvbjogJ21pc3NpbmcnXG59KTtcbmV4cG9ydHMuUkVWX0NPTkZMSUNUID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDQwOSxcbiAgZXJyb3I6ICdjb25mbGljdCcsXG4gIHJlYXNvbjogJ0RvY3VtZW50IHVwZGF0ZSBjb25mbGljdCdcbn0pO1xuZXhwb3J0cy5JTlZBTElEX0lEID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDQwMCxcbiAgZXJyb3I6ICdpbnZhbGlkX2lkJyxcbiAgcmVhc29uOiAnX2lkIGZpZWxkIG11c3QgY29udGFpbiBhIHN0cmluZydcbn0pO1xuZXhwb3J0cy5NSVNTSU5HX0lEID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDQxMixcbiAgZXJyb3I6ICdtaXNzaW5nX2lkJyxcbiAgcmVhc29uOiAnX2lkIGlzIHJlcXVpcmVkIGZvciBwdXRzJ1xufSk7XG5leHBvcnRzLlJFU0VSVkVEX0lEID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDQwMCxcbiAgZXJyb3I6ICdiYWRfcmVxdWVzdCcsXG4gIHJlYXNvbjogJ09ubHkgcmVzZXJ2ZWQgZG9jdW1lbnQgaWRzIG1heSBzdGFydCB3aXRoIHVuZGVyc2NvcmUuJ1xufSk7XG5leHBvcnRzLk5PVF9PUEVOID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDQxMixcbiAgZXJyb3I6ICdwcmVjb25kaXRpb25fZmFpbGVkJyxcbiAgcmVhc29uOiAnRGF0YWJhc2Ugbm90IG9wZW4nXG59KTtcbmV4cG9ydHMuVU5LTk9XTl9FUlJPUiA9IG5ldyBQb3VjaEVycm9yKHtcbiAgc3RhdHVzOiA1MDAsXG4gIGVycm9yOiAndW5rbm93bl9lcnJvcicsXG4gIHJlYXNvbjogJ0RhdGFiYXNlIGVuY291bnRlcmVkIGFuIHVua25vd24gZXJyb3InXG59KTtcbmV4cG9ydHMuQkFEX0FSRyA9IG5ldyBQb3VjaEVycm9yKHtcbiAgc3RhdHVzOiA1MDAsXG4gIGVycm9yOiAnYmFkYXJnJyxcbiAgcmVhc29uOiAnU29tZSBxdWVyeSBhcmd1bWVudCBpcyBpbnZhbGlkJ1xufSk7XG5leHBvcnRzLklOVkFMSURfUkVRVUVTVCA9IG5ldyBQb3VjaEVycm9yKHtcbiAgc3RhdHVzOiA0MDAsXG4gIGVycm9yOiAnaW52YWxpZF9yZXF1ZXN0JyxcbiAgcmVhc29uOiAnUmVxdWVzdCB3YXMgaW52YWxpZCdcbn0pO1xuZXhwb3J0cy5RVUVSWV9QQVJTRV9FUlJPUiA9IG5ldyBQb3VjaEVycm9yKHtcbiAgc3RhdHVzOiA0MDAsXG4gIGVycm9yOiAncXVlcnlfcGFyc2VfZXJyb3InLFxuICByZWFzb246ICdTb21lIHF1ZXJ5IHBhcmFtZXRlciBpcyBpbnZhbGlkJ1xufSk7XG5leHBvcnRzLkRPQ19WQUxJREFUSU9OID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDUwMCxcbiAgZXJyb3I6ICdkb2NfdmFsaWRhdGlvbicsXG4gIHJlYXNvbjogJ0JhZCBzcGVjaWFsIGRvY3VtZW50IG1lbWJlcidcbn0pO1xuZXhwb3J0cy5CQURfUkVRVUVTVCA9IG5ldyBQb3VjaEVycm9yKHtcbiAgc3RhdHVzOiA0MDAsXG4gIGVycm9yOiAnYmFkX3JlcXVlc3QnLFxuICByZWFzb246ICdTb21ldGhpbmcgd3Jvbmcgd2l0aCB0aGUgcmVxdWVzdCdcbn0pO1xuZXhwb3J0cy5OT1RfQU5fT0JKRUNUID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDQwMCxcbiAgZXJyb3I6ICdiYWRfcmVxdWVzdCcsXG4gIHJlYXNvbjogJ0RvY3VtZW50IG11c3QgYmUgYSBKU09OIG9iamVjdCdcbn0pO1xuZXhwb3J0cy5EQl9NSVNTSU5HID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDQwNCxcbiAgZXJyb3I6ICdub3RfZm91bmQnLFxuICByZWFzb246ICdEYXRhYmFzZSBub3QgZm91bmQnXG59KTtcbmV4cG9ydHMuSURCX0VSUk9SID0gbmV3IFBvdWNoRXJyb3Ioe1xuICBzdGF0dXM6IDUwMCxcbiAgZXJyb3I6ICdpbmRleGVkX2RiX3dlbnRfYmFkJyxcbiAgcmVhc29uOiAndW5rbm93bidcbn0pO1xuZXhwb3J0cy5XU1FfRVJST1IgPSBuZXcgUG91Y2hFcnJvcih7XG4gIHN0YXR1czogNTAwLFxuICBlcnJvcjogJ3dlYl9zcWxfd2VudF9iYWQnLFxuICByZWFzb246ICd1bmtub3duJ1xufSk7XG5leHBvcnRzLkxEQl9FUlJPUiA9IG5ldyBQb3VjaEVycm9yKHtcbiAgc3RhdHVzOiA1MDAsXG4gIGVycm9yOiAnbGV2ZWxEQl93ZW50X3dlbnRfYmFkJyxcbiAgcmVhc29uOiAndW5rbm93bidcbn0pO1xuZXhwb3J0cy5GT1JCSURERU4gPSBuZXcgUG91Y2hFcnJvcih7XG4gIHN0YXR1czogNDAzLFxuICBlcnJvcjogJ2ZvcmJpZGRlbicsXG4gIHJlYXNvbjogJ0ZvcmJpZGRlbiBieSBkZXNpZ24gZG9jIHZhbGlkYXRlX2RvY191cGRhdGUgZnVuY3Rpb24nXG59KTtcbmV4cG9ydHMuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIHJlYXNvbiwgbmFtZSkge1xuICBmdW5jdGlvbiBDdXN0b21Qb3VjaEVycm9yKG1zZykge1xuICAgIHRoaXMubWVzc2FnZSA9IHJlYXNvbjtcbiAgICBpZiAobmFtZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gIH1cbiAgQ3VzdG9tUG91Y2hFcnJvci5wcm90b3R5cGUgPSBlcnJvcjtcbiAgcmV0dXJuIG5ldyBDdXN0b21Qb3VjaEVycm9yKHJlYXNvbik7XG59O1xuXG59LHt9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGNyeXB0byA9IF9kZXJlcV8oJ2NyeXB0bycpO1xudmFyIE1kNSA9IF9kZXJlcV8oJ3NwYXJrLW1kNScpO1xudmFyIHNldEltbWVkaWF0ZVNoaW0gPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IGdsb2JhbC5zZXRUaW1lb3V0O1xudmFyIE1ENV9DSFVOS19TSVpFID0gMzI3Njg7XG5cbmZ1bmN0aW9uIHNsaWNlU2hpbShhcnJheUJ1ZmZlciwgYmVnaW4sIGVuZCkge1xuICBpZiAodHlwZW9mIGFycmF5QnVmZmVyLnNsaWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFiZWdpbikge1xuICAgICAgcmV0dXJuIGFycmF5QnVmZmVyLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICghZW5kKSB7XG4gICAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gICAgfVxuICB9XG4gIC8vXG4gIC8vIHNoaW0gZm9yIElFIGNvdXJ0ZXN5IG9mIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxNDQwMjE3XG4gIC8vXG5cbiAgLy9JZiBgYmVnaW5gL2BlbmRgIGlzIHVuc3BlY2lmaWVkLCBDaHJvbWUgYXNzdW1lcyAwLCBzbyB3ZSBkbyB0aGUgc2FtZVxuICAvL0Nocm9tZSBhbHNvIGNvbnZlcnRzIHRoZSB2YWx1ZXMgdG8gaW50ZWdlcnMgdmlhIGZsb29yaW5nXG4gIGJlZ2luID0gTWF0aC5mbG9vcihiZWdpbiB8fCAwKTtcbiAgZW5kID0gTWF0aC5mbG9vcihlbmQgfHwgMCk7XG5cbiAgdmFyIGxlbiA9IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7XG5cbiAgLy9JZiBlaXRoZXIgYGJlZ2luYCBvciBgZW5kYCBpcyBuZWdhdGl2ZSwgaXQgcmVmZXJzIHRvIGFuXG4gIC8vaW5kZXggZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheSwgYXMgb3Bwb3NlZCB0byBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gIC8vVGhlIHJhbmdlIHNwZWNpZmllZCBieSB0aGUgYGJlZ2luYCBhbmQgYGVuZGAgdmFsdWVzIGlzIGNsYW1wZWQgdG8gdGhlXG4gIC8vdmFsaWQgaW5kZXggcmFuZ2UgZm9yIHRoZSBjdXJyZW50IGFycmF5LlxuICBiZWdpbiA9IGJlZ2luIDwgMCA/IE1hdGgubWF4KGJlZ2luICsgbGVuLCAwKSA6IE1hdGgubWluKGxlbiwgYmVnaW4pO1xuICBlbmQgPSBlbmQgPCAwID8gTWF0aC5tYXgoZW5kICsgbGVuLCAwKSA6IE1hdGgubWluKGxlbiwgZW5kKTtcblxuICAvL0lmIHRoZSBjb21wdXRlZCBsZW5ndGggb2YgdGhlIG5ldyBBcnJheUJ1ZmZlciB3b3VsZCBiZSBuZWdhdGl2ZSwgaXRcbiAgLy9pcyBjbGFtcGVkIHRvIHplcm8uXG4gIGlmIChlbmQgLSBiZWdpbiA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoZW5kIC0gYmVnaW4pO1xuICB2YXIgcmVzdWx0Qnl0ZXMgPSBuZXcgVWludDhBcnJheShyZXN1bHQpO1xuICB2YXIgc291cmNlQnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgYmVnaW4sIGVuZCAtIGJlZ2luKTtcblxuICByZXN1bHRCeXRlcy5zZXQoc291cmNlQnl0ZXMpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGNvbnZlcnQgYSA2NC1iaXQgaW50IHRvIGEgYmluYXJ5IHN0cmluZ1xuZnVuY3Rpb24gaW50VG9TdHJpbmcoaW50KSB7XG4gIHZhciBieXRlcyA9IFtcbiAgICAoaW50ICYgMHhmZiksXG4gICAgKChpbnQgPj4+IDgpICYgMHhmZiksXG4gICAgKChpbnQgPj4+IDE2KSAmIDB4ZmYpLFxuICAgICgoaW50ID4+PiAyNCkgJiAweGZmKVxuICBdO1xuICByZXR1cm4gYnl0ZXMubWFwKGZ1bmN0aW9uIChieXRlKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSk7XG4gIH0pLmpvaW4oJycpO1xufVxuXG4vLyBjb252ZXJ0IGFuIGFycmF5IG9mIDY0LWJpdCBpbnRzIGludG9cbi8vIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nXG5mdW5jdGlvbiByYXdUb0Jhc2U2NChyYXcpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgIHJlcyArPSBpbnRUb1N0cmluZyhyYXdbaV0pO1xuICB9XG4gIHJldHVybiBnbG9iYWwuYnRvYShyZXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICBpZiAoIXByb2Nlc3MuYnJvd3Nlcikge1xuICAgIHZhciBiYXNlNjQgPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKGRhdGEpLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgY2FsbGJhY2sobnVsbCwgYmFzZTY0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlucHV0SXNTdHJpbmcgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZyc7XG4gIHZhciBsZW4gPSBpbnB1dElzU3RyaW5nID8gZGF0YS5sZW5ndGggOiBkYXRhLmJ5dGVMZW5ndGg7XG4gIHZhciBjaHVua1NpemUgPSBNYXRoLm1pbihNRDVfQ0hVTktfU0laRSwgbGVuKTtcbiAgdmFyIGNodW5rcyA9IE1hdGguY2VpbChsZW4gLyBjaHVua1NpemUpO1xuICB2YXIgY3VycmVudENodW5rID0gMDtcbiAgdmFyIGJ1ZmZlciA9IGlucHV0SXNTdHJpbmcgPyBuZXcgTWQ1KCkgOiBuZXcgTWQ1LkFycmF5QnVmZmVyKCk7XG5cbiAgZnVuY3Rpb24gYXBwZW5kKGJ1ZmZlciwgZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGlmIChpbnB1dElzU3RyaW5nKSB7XG4gICAgICBidWZmZXIuYXBwZW5kQmluYXJ5KGRhdGEuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyLmFwcGVuZChzbGljZVNoaW0oZGF0YSwgc3RhcnQsIGVuZCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWROZXh0Q2h1bmsoKSB7XG4gICAgdmFyIHN0YXJ0ID0gY3VycmVudENodW5rICogY2h1bmtTaXplO1xuICAgIHZhciBlbmQgPSBzdGFydCArIGNodW5rU2l6ZTtcbiAgICBpZiAoKHN0YXJ0ICsgY2h1bmtTaXplKSA+PSBkYXRhLnNpemUpIHtcbiAgICAgIGVuZCA9IGRhdGEuc2l6ZTtcbiAgICB9XG4gICAgY3VycmVudENodW5rKys7XG4gICAgaWYgKGN1cnJlbnRDaHVuayA8IGNodW5rcykge1xuICAgICAgYXBwZW5kKGJ1ZmZlciwgZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgICBzZXRJbW1lZGlhdGVTaGltKGxvYWROZXh0Q2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmQoYnVmZmVyLCBkYXRhLCBzdGFydCwgZW5kKTtcbiAgICAgIHZhciByYXcgPSBidWZmZXIuZW5kKHRydWUpO1xuICAgICAgdmFyIGJhc2U2NCA9IHJhd1RvQmFzZTY0KHJhdyk7XG4gICAgICBjYWxsYmFjayhudWxsLCBiYXNlNjQpO1xuICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgbG9hZE5leHRDaHVuaygpO1xufTtcblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvVXNlcnMvZGFsZWhhcnZleS9zcmMvcG91Y2hkYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIvVXNlcnMvZGFsZWhhcnZleS9zcmMvcG91Y2hkYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjozMSxcImNyeXB0b1wiOjI5LFwic3BhcmstbWQ1XCI6NjB9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBQYXJzaW5nIGhleCBzdHJpbmdzLiBZZWFoLlxuLy9cbi8vIFNvIGJhc2ljYWxseSB3ZSBuZWVkIHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBXZWJTUUw6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDIyNjkwXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3NjM3XG4vL1xuLy8gVVRGLTggYW5kIFVURi0xNiBhcmUgcHJvdmlkZWQgYXMgc2VwYXJhdGUgZnVuY3Rpb25zXG4vLyBmb3IgbWVhZ2VyIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50c1xuLy9cblxuZnVuY3Rpb24gZGVjb2RlVXRmOChzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cuZXNjYXBlKHN0cikpO1xufVxuXG5mdW5jdGlvbiBoZXhUb0ludChjaGFyQ29kZSkge1xuICAvLyAnMCctJzknIGlzIDQ4LTU3XG4gIC8vICdBJy0nRicgaXMgNjUtNzBcbiAgLy8gU1FMaXRlIHdpbGwgb25seSBnaXZlIHVzIHVwcGVyY2FzZSBoZXhcbiAgcmV0dXJuIGNoYXJDb2RlIDwgNjUgPyAoY2hhckNvZGUgLSA0OCkgOiAoY2hhckNvZGUgLSA1NSk7XG59XG5cblxuLy8gRXhhbXBsZTpcbi8vIHByYWdtYSBlbmNvZGluZz11dGY4O1xuLy8gc2VsZWN0IGhleCgnQScpO1xuLy8gcmV0dXJucyAnNDEnXG5mdW5jdGlvbiBwYXJzZUhleFV0Zjgoc3RyLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAoaGV4VG9JbnQoc3RyLmNoYXJDb2RlQXQoc3RhcnQrKykpIDw8IDQpIHxcbiAgICAgICAgaGV4VG9JbnQoc3RyLmNoYXJDb2RlQXQoc3RhcnQrKykpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBFeGFtcGxlOlxuLy8gcHJhZ21hIGVuY29kaW5nPXV0ZjE2O1xuLy8gc2VsZWN0IGhleCgnQScpO1xuLy8gcmV0dXJucyAnNDEwMCdcbi8vIG5vdGljZSB0aGF0IHRoZSAwMCBjb21lcyBhZnRlciB0aGUgNDEgKGkuZS4gaXQncyBzd2l6emxlZClcbmZ1bmN0aW9uIHBhcnNlSGV4VXRmMTYoc3RyLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gVVRGLTE2LCBzbyBzd2l6emxlIHRoZSBieXRlc1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgKGhleFRvSW50KHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMikpIDw8IDEyKSB8XG4gICAgICAgIChoZXhUb0ludChzdHIuY2hhckNvZGVBdChzdGFydCArIDMpKSA8PCA4KSB8XG4gICAgICAgIChoZXhUb0ludChzdHIuY2hhckNvZGVBdChzdGFydCkpIDw8IDQpIHxcbiAgICAgICAgaGV4VG9JbnQoc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSkpO1xuICAgIHN0YXJ0ICs9IDQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VIZXhTdHJpbmcoc3RyLCBlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgPT09ICdVVEYtOCcpIHtcbiAgICByZXR1cm4gZGVjb2RlVXRmOChwYXJzZUhleFV0Zjgoc3RyLCAwLCBzdHIubGVuZ3RoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlSGV4VXRmMTYoc3RyLCAwLCBzdHIubGVuZ3RoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlSGV4U3RyaW5nO1xufSx7fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBvcmlnaW5hbGx5IHBhcnNlVXJpIDEuMi4yLCBub3cgcGF0Y2hlZCBieSB1c1xuLy8gKGMpIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuLy8gTUlUIExpY2Vuc2VcbnZhciBvcHRpb25zID0ge1xuICBzdHJpY3RNb2RlOiBmYWxzZSxcbiAga2V5OiBbXCJzb3VyY2VcIiwgXCJwcm90b2NvbFwiLCBcImF1dGhvcml0eVwiLCBcInVzZXJJbmZvXCIsIFwidXNlclwiLCBcInBhc3N3b3JkXCIsXG4gICAgXCJob3N0XCIsIFwicG9ydFwiLCBcInJlbGF0aXZlXCIsIFwicGF0aFwiLCBcImRpcmVjdG9yeVwiLCBcImZpbGVcIiwgXCJxdWVyeVwiLFxuICAgIFwiYW5jaG9yXCJdLFxuICBxOiAgIHtcbiAgICBuYW1lOiAgIFwicXVlcnlLZXlcIixcbiAgICBwYXJzZXI6IC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZ1xuICB9LFxuICBwYXJzZXI6IHtcbiAgICAvKiBqc2hpbnQgbWF4bGVuOiBmYWxzZSAqL1xuICAgIHN0cmljdDogL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygoKCg/OltePyNcXC9dKlxcLykqKShbXj8jXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLyxcbiAgICBsb29zZTogIC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pL1xuICB9XG59O1xuZnVuY3Rpb24gcGFyc2VVcmkoc3RyKSB7XG4gIHZhciBvID0gb3B0aW9ucztcbiAgdmFyIG0gPSBvLnBhcnNlcltvLnN0cmljdE1vZGUgPyBcInN0cmljdFwiIDogXCJsb29zZVwiXS5leGVjKHN0cik7XG4gIHZhciB1cmkgPSB7fTtcbiAgdmFyIGkgPSAxNDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IG8ua2V5W2ldO1xuICAgIHZhciB2YWx1ZSA9IG1baV0gfHwgXCJcIjtcbiAgICB2YXIgZW5jb2RlZCA9IFsndXNlcicsICdwYXNzd29yZCddLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgdXJpW2tleV0gPSBlbmNvZGVkID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICB9XG5cbiAgdXJpW28ucS5uYW1lXSA9IHt9O1xuICB1cmlbby5rZXlbMTJdXS5yZXBsYWNlKG8ucS5wYXJzZXIsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgaWYgKCQxKSB7XG4gICAgICB1cmlbby5xLm5hbWVdWyQxXSA9ICQyO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVyaTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVXJpO1xufSx7fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIFByb21pc2UgPSBfZGVyZXFfKCcuLi91dGlscycpLlByb21pc2U7XG5cbi8vIHRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIFwidXBkYXRlIHN1Z2FyXCIgZnVuY3Rpb24gZnJvbSBkYWxlaGFydmV5L3BvdWNoZGIjMTM4OFxuLy8gdGhlIGRpZmZGdW4gdGVsbHMgdXMgd2hhdCBkZWx0YSB0byBhcHBseSB0byB0aGUgZG9jLiAgaXQgZWl0aGVyIHJldHVybnNcbi8vIHRoZSBkb2MsIG9yIGZhbHNlIGlmIGl0IGRvZXNuJ3QgbmVlZCB0byBkbyBhbiB1cGRhdGUgYWZ0ZXIgYWxsXG5mdW5jdGlvbiB1cHNlcnQoZGIsIGRvY0lkLCBkaWZmRnVuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XG4gICAgaWYgKGRvY0lkICYmIHR5cGVvZiBkb2NJZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRvY0lkID0gZG9jSWQuX2lkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRvY0lkICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ2RvYyBpZCBpcyByZXF1aXJlZCcpKTtcbiAgICB9XG5cbiAgICBkYi5nZXQoZG9jSWQsIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLnN0YXR1cyAhPT0gNDA0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxmaWxsKHRyeUFuZFB1dChkYiwgZGlmZkZ1bih7X2lkIDogZG9jSWR9KSwgZGlmZkZ1bikpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RvYyA9IGRpZmZGdW4oZG9jKTtcbiAgICAgIGlmICghbmV3RG9jKSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsKGRvYyk7XG4gICAgICB9XG4gICAgICBmdWxmaWxsKHRyeUFuZFB1dChkYiwgbmV3RG9jLCBkaWZmRnVuKSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cnlBbmRQdXQoZGIsIGRvYywgZGlmZkZ1bikge1xuICByZXR1cm4gZGIucHV0KGRvYylbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyci5zdGF0dXMgIT09IDQwOSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gdXBzZXJ0KGRiLCBkb2MsIGRpZmZGdW4pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGIsIGRvY0lkLCBkaWZmRnVuLCBjYikge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBzZXJ0KGRiLCBkb2NJZCwgZGlmZkZ1bikudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgY2IobnVsbCwgcmVzcCk7XG4gICAgfSwgY2IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1cHNlcnQoZGIsIGRvY0lkLCBkaWZmRnVuKTtcbiAgfVxufTtcblxufSx7XCIuLi91dGlsc1wiOjI2fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEJFR0lOIE1hdGgudXVpZC5qc1xuXG4vKiFcbk1hdGgudXVpZC5qcyAodjEuNClcbmh0dHA6Ly93d3cuYnJvb2ZhLmNvbVxubWFpbHRvOnJvYmVydEBicm9vZmEuY29tXG5cbkNvcHlyaWdodCAoYykgMjAxMCBSb2JlcnQgS2llZmZlclxuRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG4qL1xuXG4vKlxuICogR2VuZXJhdGUgYSByYW5kb20gdXVpZC5cbiAqXG4gKiBVU0FHRTogTWF0aC51dWlkKGxlbmd0aCwgcmFkaXgpXG4gKiAgIGxlbmd0aCAtIHRoZSBkZXNpcmVkIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gKiAgIHJhZGl4ICAtIHRoZSBudW1iZXIgb2YgYWxsb3dhYmxlIHZhbHVlcyBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogRVhBTVBMRVM6XG4gKiAgIC8vIE5vIGFyZ3VtZW50cyAgLSByZXR1cm5zIFJGQzQxMjIsIHZlcnNpb24gNCBJRFxuICogICA+Pj4gTWF0aC51dWlkKClcbiAqICAgXCI5MjMyOUQzOS02RjVDLTQ1MjAtQUJGQy1BQUI2NDU0NEUxNzJcIlxuICpcbiAqICAgLy8gT25lIGFyZ3VtZW50IC0gcmV0dXJucyBJRCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aFxuICogICA+Pj4gTWF0aC51dWlkKDE1KSAgICAgLy8gMTUgY2hhcmFjdGVyIElEIChkZWZhdWx0IGJhc2U9NjIpXG4gKiAgIFwiVmN5ZHhnbHR4clZaU1RWXCJcbiAqXG4gKiAgIC8vIFR3byBhcmd1bWVudHMgLSByZXR1cm5zIElEIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLCBhbmQgcmFkaXguIFxuICogICAvLyAoUmFkaXggbXVzdCBiZSA8PSA2MilcbiAqICAgPj4+IE1hdGgudXVpZCg4LCAyKSAgLy8gOCBjaGFyYWN0ZXIgSUQgKGJhc2U9MilcbiAqICAgXCIwMTAwMTAxMFwiXG4gKiAgID4+PiBNYXRoLnV1aWQoOCwgMTApIC8vIDggY2hhcmFjdGVyIElEIChiYXNlPTEwKVxuICogICBcIjQ3NDczMDQ2XCJcbiAqICAgPj4+IE1hdGgudXVpZCg4LCAxNikgLy8gOCBjaGFyYWN0ZXIgSUQgKGJhc2U9MTYpXG4gKiAgIFwiMDk4RjREMzVcIlxuICovXG52YXIgY2hhcnMgPSAoXG4gICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICtcbiAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J1xuKS5zcGxpdCgnJyk7XG5mdW5jdGlvbiBnZXRWYWx1ZShyYWRpeCkge1xuICByZXR1cm4gMCB8IE1hdGgucmFuZG9tKCkgKiByYWRpeDtcbn1cbmZ1bmN0aW9uIHV1aWQobGVuLCByYWRpeCkge1xuICByYWRpeCA9IHJhZGl4IHx8IGNoYXJzLmxlbmd0aDtcbiAgdmFyIG91dCA9ICcnO1xuICB2YXIgaSA9IC0xO1xuXG4gIGlmIChsZW4pIHtcbiAgICAvLyBDb21wYWN0IGZvcm1cbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvdXQgKz0gY2hhcnNbZ2V0VmFsdWUocmFkaXgpXTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAgIC8vIHJmYzQxMjIsIHZlcnNpb24gNCBmb3JtXG4gICAgLy8gRmlsbCBpbiByYW5kb20gZGF0YS4gIEF0IGk9PTE5IHNldCB0aGUgaGlnaCBiaXRzIG9mIGNsb2NrIHNlcXVlbmNlIGFzXG4gICAgLy8gcGVyIHJmYzQxMjIsIHNlYy4gNC4xLjVcbiAgd2hpbGUgKCsraSA8IDM2KSB7XG4gICAgc3dpdGNoIChpKSB7XG4gICAgICBjYXNlIDg6XG4gICAgICBjYXNlIDEzOlxuICAgICAgY2FzZSAxODpcbiAgICAgIGNhc2UgMjM6XG4gICAgICAgIG91dCArPSAnLSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOTpcbiAgICAgICAgb3V0ICs9IGNoYXJzWyhnZXRWYWx1ZSgxNikgJiAweDMpIHwgMHg4XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvdXQgKz0gY2hhcnNbZ2V0VmFsdWUoMTYpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuXG5cbn0se31dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBldmFsRmlsdGVyO1xuZnVuY3Rpb24gZXZhbEZpbHRlcihpbnB1dCkge1xuICAvKmpzaGludCBldmlsOiB0cnVlICovXG4gIHJldHVybiBldmFsKFtcbiAgICAnKGZ1bmN0aW9uICgpIHsgcmV0dXJuICcsXG4gICAgaW5wdXQsXG4gICAgJyB9KSgpJ1xuICBdLmpvaW4oJycpKTtcbn1cbn0se31dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBldmFsVmlldztcbmZ1bmN0aW9uIGV2YWxWaWV3KGlucHV0KSB7XG4gIC8qanNoaW50IGV2aWw6IHRydWUgKi9cbiAgcmV0dXJuIGV2YWwoW1xuICAgICcoZnVuY3Rpb24gKCkgeycsXG4gICAgJyAgcmV0dXJuIGZ1bmN0aW9uIChkb2MpIHsnLFxuICAgICcgICAgdmFyIGVtaXR0ZWQgPSBmYWxzZTsnLFxuICAgICcgICAgdmFyIGVtaXQgPSBmdW5jdGlvbiAoYSwgYikgeycsXG4gICAgJyAgICAgIGVtaXR0ZWQgPSB0cnVlOycsXG4gICAgJyAgICB9OycsXG4gICAgJyAgICB2YXIgdmlldyA9ICcgKyBpbnB1dCArICc7JyxcbiAgICAnICAgIHZpZXcoZG9jKTsnLFxuICAgICcgICAgaWYgKGVtaXR0ZWQpIHsnLFxuICAgICcgICAgICByZXR1cm4gdHJ1ZTsnLFxuICAgICcgICAgfScsXG4gICAgJyAgfScsXG4gICAgJ30pKCknXG4gIF0uam9pbignXFxuJykpO1xufVxufSx7fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG91Y2hEQiA9IF9kZXJlcV8oJy4vc2V0dXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb3VjaERCO1xuXG5Qb3VjaERCLmFqYXggPSBfZGVyZXFfKCcuL2RlcHMvYWpheCcpO1xuUG91Y2hEQi5leHRlbmQgPSBfZGVyZXFfKCdwb3VjaGRiLWV4dGVuZCcpO1xuUG91Y2hEQi51dGlscyA9IF9kZXJlcV8oJy4vdXRpbHMnKTtcblBvdWNoREIuRXJyb3JzID0gX2RlcmVxXygnLi9kZXBzL2Vycm9ycycpO1xuUG91Y2hEQi5yZXBsaWNhdGUgPSBfZGVyZXFfKCcuL3JlcGxpY2F0ZScpLnJlcGxpY2F0ZTtcblBvdWNoREIuc3luYyA9IF9kZXJlcV8oJy4vc3luYycpO1xuUG91Y2hEQi52ZXJzaW9uID0gX2RlcmVxXygnLi92ZXJzaW9uJyk7XG52YXIgaHR0cEFkYXB0ZXIgPSBfZGVyZXFfKCcuL2FkYXB0ZXJzL2h0dHAnKTtcblBvdWNoREIuYWRhcHRlcignaHR0cCcsIGh0dHBBZGFwdGVyKTtcblBvdWNoREIuYWRhcHRlcignaHR0cHMnLCBodHRwQWRhcHRlcik7XG5cblBvdWNoREIuYWRhcHRlcignaWRiJywgX2RlcmVxXygnLi9hZGFwdGVycy9pZGInKSk7XG5Qb3VjaERCLmFkYXB0ZXIoJ3dlYnNxbCcsIF9kZXJlcV8oJy4vYWRhcHRlcnMvd2Vic3FsJykpO1xuUG91Y2hEQi5wbHVnaW4oX2RlcmVxXygncG91Y2hkYi1tYXByZWR1Y2UnKSk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyKSB7XG4gIHZhciBsZGJBZGFwdGVyID0gX2RlcmVxXygnLi9hZGFwdGVycy9sZXZlbGRiJyk7XG4gIFBvdWNoREIuYWRhcHRlcignbGRiJywgbGRiQWRhcHRlcik7XG4gIFBvdWNoREIuYWRhcHRlcignbGV2ZWxkYicsIGxkYkFkYXB0ZXIpO1xufVxuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9Vc2Vycy9kYWxlaGFydmV5L3NyYy9wb3VjaGRiL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSlcbn0se1wiLi9hZGFwdGVycy9odHRwXCI6MixcIi4vYWRhcHRlcnMvaWRiXCI6MyxcIi4vYWRhcHRlcnMvbGV2ZWxkYlwiOjI5LFwiLi9hZGFwdGVycy93ZWJzcWxcIjo1LFwiLi9kZXBzL2FqYXhcIjo5LFwiLi9kZXBzL2Vycm9yc1wiOjEyLFwiLi9yZXBsaWNhdGVcIjoyMixcIi4vc2V0dXBcIjoyMyxcIi4vc3luY1wiOjI0LFwiLi91dGlsc1wiOjI2LFwiLi92ZXJzaW9uXCI6MjcsXCIvVXNlcnMvZGFsZWhhcnZleS9zcmMvcG91Y2hkYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjozMSxcInBvdWNoZGItZXh0ZW5kXCI6NTEsXCJwb3VjaGRiLW1hcHJlZHVjZVwiOjU0fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIGV4dGVuZCA9IF9kZXJlcV8oJ3BvdWNoZGItZXh0ZW5kJyk7XG5cblxuLy8gZm9yIGEgYmV0dGVyIG92ZXJ2aWV3IG9mIHdoYXQgdGhpcyBpcyBkb2luZywgcmVhZDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGFjaGUvY291Y2hkYi9ibG9iL21hc3Rlci9zcmMvY291Y2hkYi9jb3VjaF9rZXlfdHJlZS5lcmxcbi8vXG4vLyBCdXQgZm9yIGEgcXVpY2sgaW50cm8sIENvdWNoREIgdXNlcyBhIHJldmlzaW9uIHRyZWUgdG8gc3RvcmUgYSBkb2N1bWVudHNcbi8vIGhpc3RvcnksIEEgLT4gQiAtPiBDLCB3aGVuIGEgZG9jdW1lbnQgaGFzIGNvbmZsaWN0cywgdGhhdCBpcyBhIGJyYW5jaCBpbiB0aGVcbi8vIHRyZWUsIEEgLT4gKEIxIHwgQjIgLT4gQyksIFdlIHN0b3JlIHRoZXNlIGFzIGEgbmVzdGVkIGFycmF5IGluIHRoZSBmb3JtYXRcbi8vXG4vLyBLZXlUcmVlID0gW1BhdGggLi4uIF1cbi8vIFBhdGggPSB7cG9zOiBwb3NpdGlvbl9mcm9tX3Jvb3QsIGlkczogVHJlZX1cbi8vIFRyZWUgPSBbS2V5LCBPcHRzLCBbVHJlZSwgLi4uXV0sIGluIHBhcnRpY3VsYXIgc2luZ2xlIG5vZGU6IFtLZXksIFtdXVxuXG4vLyBUdXJuIGEgcGF0aCBhcyBhIGZsYXQgYXJyYXkgaW50byBhIHRyZWUgd2l0aCBhIHNpbmdsZSBicmFuY2hcbmZ1bmN0aW9uIHBhdGhUb1RyZWUocGF0aCkge1xuICB2YXIgZG9jID0gcGF0aC5zaGlmdCgpO1xuICB2YXIgcm9vdCA9IFtkb2MuaWQsIGRvYy5vcHRzLCBbXV07XG4gIHZhciBsZWFmID0gcm9vdDtcbiAgdmFyIG5sZWFmO1xuXG4gIHdoaWxlIChwYXRoLmxlbmd0aCkge1xuICAgIGRvYyA9IHBhdGguc2hpZnQoKTtcbiAgICBubGVhZiA9IFtkb2MuaWQsIGRvYy5vcHRzLCBbXV07XG4gICAgbGVhZlsyXS5wdXNoKG5sZWFmKTtcbiAgICBsZWFmID0gbmxlYWY7XG4gIH1cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbi8vIE1lcmdlIHR3byB0cmVlcyB0b2dldGhlclxuLy8gVGhlIHJvb3RzIG9mIHRyZWUxIGFuZCB0cmVlMiBtdXN0IGJlIHRoZSBzYW1lIHJldmlzaW9uXG5mdW5jdGlvbiBtZXJnZVRyZWUoaW5fdHJlZTEsIGluX3RyZWUyKSB7XG4gIHZhciBxdWV1ZSA9IFt7dHJlZTE6IGluX3RyZWUxLCB0cmVlMjogaW5fdHJlZTJ9XTtcbiAgdmFyIGNvbmZsaWN0cyA9IGZhbHNlO1xuICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgdmFyIHRyZWUxID0gaXRlbS50cmVlMTtcbiAgICB2YXIgdHJlZTIgPSBpdGVtLnRyZWUyO1xuXG4gICAgaWYgKHRyZWUxWzFdLnN0YXR1cyB8fCB0cmVlMlsxXS5zdGF0dXMpIHtcbiAgICAgIHRyZWUxWzFdLnN0YXR1cyA9XG4gICAgICAgICh0cmVlMVsxXS5zdGF0dXMgPT09ICAnYXZhaWxhYmxlJyB8fFxuICAgICAgICAgdHJlZTJbMV0uc3RhdHVzID09PSAnYXZhaWxhYmxlJykgPyAnYXZhaWxhYmxlJyA6ICdtaXNzaW5nJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUyWzJdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRyZWUxWzJdWzBdKSB7XG4gICAgICAgIGNvbmZsaWN0cyA9ICduZXdfbGVhZic7XG4gICAgICAgIHRyZWUxWzJdWzBdID0gdHJlZTJbMl1baV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRyZWUxWzJdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICh0cmVlMVsyXVtqXVswXSA9PT0gdHJlZTJbMl1baV1bMF0pIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKHt0cmVlMTogdHJlZTFbMl1bal0sIHRyZWUyOiB0cmVlMlsyXVtpXX0pO1xuICAgICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICAgIGNvbmZsaWN0cyA9ICduZXdfYnJhbmNoJztcbiAgICAgICAgdHJlZTFbMl0ucHVzaCh0cmVlMlsyXVtpXSk7XG4gICAgICAgIHRyZWUxWzJdLnNvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtjb25mbGljdHM6IGNvbmZsaWN0cywgdHJlZTogaW5fdHJlZTF9O1xufVxuXG5mdW5jdGlvbiBkb01lcmdlKHRyZWUsIHBhdGgsIGRvbnRFeHBhbmQpIHtcbiAgdmFyIHJlc3RyZWUgPSBbXTtcbiAgdmFyIGNvbmZsaWN0cyA9IGZhbHNlO1xuICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gIHZhciByZXM7XG5cbiAgaWYgKCF0cmVlLmxlbmd0aCkge1xuICAgIHJldHVybiB7dHJlZTogW3BhdGhdLCBjb25mbGljdHM6ICduZXdfbGVhZid9O1xuICB9XG5cbiAgdHJlZS5mb3JFYWNoKGZ1bmN0aW9uIChicmFuY2gpIHtcbiAgICBpZiAoYnJhbmNoLnBvcyA9PT0gcGF0aC5wb3MgJiYgYnJhbmNoLmlkc1swXSA9PT0gcGF0aC5pZHNbMF0pIHtcbiAgICAgIC8vIFBhdGhzIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFuZCBoYXZlIHRoZSBzYW1lIHJvb3QsIHNvIHRoZXkgbmVlZFxuICAgICAgLy8gbWVyZ2VkXG4gICAgICByZXMgPSBtZXJnZVRyZWUoYnJhbmNoLmlkcywgcGF0aC5pZHMpO1xuICAgICAgcmVzdHJlZS5wdXNoKHtwb3M6IGJyYW5jaC5wb3MsIGlkczogcmVzLnRyZWV9KTtcbiAgICAgIGNvbmZsaWN0cyA9IGNvbmZsaWN0cyB8fCByZXMuY29uZmxpY3RzO1xuICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRvbnRFeHBhbmQgIT09IHRydWUpIHtcbiAgICAgIC8vIFRoZSBwYXRocyBzdGFydCBhdCBhIGRpZmZlcmVudCBwb3NpdGlvbiwgdGFrZSB0aGUgZWFybGllc3QgcGF0aCBhbmRcbiAgICAgIC8vIHRyYXZlcnNlIHVwIHVudGlsIGl0IGFzIGF0IHRoZSBzYW1lIHBvaW50IGZyb20gcm9vdCBhcyB0aGUgcGF0aCB3ZVxuICAgICAgLy8gd2FudCB0byBtZXJnZS4gIElmIHRoZSBrZXlzIG1hdGNoIHdlIHJldHVybiB0aGUgbG9uZ2VyIHBhdGggd2l0aCB0aGVcbiAgICAgIC8vIG90aGVyIG1lcmdlZCBBZnRlciBzdGVtbWluZyB3ZSBkb250IHdhbnQgdG8gZXhwYW5kIHRoZSB0cmVlc1xuXG4gICAgICB2YXIgdDEgPSBicmFuY2gucG9zIDwgcGF0aC5wb3MgPyBicmFuY2ggOiBwYXRoO1xuICAgICAgdmFyIHQyID0gYnJhbmNoLnBvcyA8IHBhdGgucG9zID8gcGF0aCA6IGJyYW5jaDtcbiAgICAgIHZhciBkaWZmID0gdDIucG9zIC0gdDEucG9zO1xuXG4gICAgICB2YXIgY2FuZGlkYXRlUGFyZW50cyA9IFtdO1xuXG4gICAgICB2YXIgdHJlZXMgPSBbXTtcbiAgICAgIHRyZWVzLnB1c2goe2lkczogdDEuaWRzLCBkaWZmOiBkaWZmLCBwYXJlbnQ6IG51bGwsIHBhcmVudElkeDogbnVsbH0pO1xuICAgICAgd2hpbGUgKHRyZWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0cmVlcy5wb3AoKTtcbiAgICAgICAgaWYgKGl0ZW0uZGlmZiA9PT0gMCkge1xuICAgICAgICAgIGlmIChpdGVtLmlkc1swXSA9PT0gdDIuaWRzWzBdKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVQYXJlbnRzLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXRlbS5pZHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgIGl0ZW0uaWRzWzJdLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICB0cmVlcy5wdXNoKFxuICAgICAgICAgICAge2lkczogZWwsIGRpZmY6IGl0ZW0uZGlmZiAtIDEsIHBhcmVudDogaXRlbS5pZHMsIHBhcmVudElkeDogaWR4fSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWwgPSBjYW5kaWRhdGVQYXJlbnRzWzBdO1xuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJlc3RyZWUucHVzaChicmFuY2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gbWVyZ2VUcmVlKGVsLmlkcywgdDIuaWRzKTtcbiAgICAgICAgZWwucGFyZW50WzJdW2VsLnBhcmVudElkeF0gPSByZXMudHJlZTtcbiAgICAgICAgcmVzdHJlZS5wdXNoKHtwb3M6IHQxLnBvcywgaWRzOiB0MS5pZHN9KTtcbiAgICAgICAgY29uZmxpY3RzID0gY29uZmxpY3RzIHx8IHJlcy5jb25mbGljdHM7XG4gICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RyZWUucHVzaChicmFuY2gpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gV2UgZGlkbnQgZmluZFxuICBpZiAoIW1lcmdlZCkge1xuICAgIHJlc3RyZWUucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJlc3RyZWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnBvcyAtIGIucG9zO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHRyZWU6IHJlc3RyZWUsXG4gICAgY29uZmxpY3RzOiBjb25mbGljdHMgfHwgJ2ludGVybmFsX25vZGUnXG4gIH07XG59XG5cbi8vIFRvIGVuc3VyZSB3ZSBkb250IGdyb3cgdGhlIHJldmlzaW9uIHRyZWUgaW5maW5pdGVseSwgd2Ugc3RlbSBvbGQgcmV2aXNpb25zXG5mdW5jdGlvbiBzdGVtKHRyZWUsIGRlcHRoKSB7XG4gIC8vIEZpcnN0IHdlIGJyZWFrIG91dCB0aGUgdHJlZSBpbnRvIGEgY29tcGxldGUgbGlzdCBvZiByb290IHRvIGxlYWYgcGF0aHMsXG4gIC8vIHdlIGN1dCBvZmYgdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIGFuZCBnZW5lcmF0ZSBhIG5ldyBzZXQgb2YgZmxhdCB0cmVlc1xuICB2YXIgc3RlbW1lZFBhdGhzID0gUG91Y2hNZXJnZS5yb290VG9MZWFmKHRyZWUpLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBzdGVtbWVkID0gcGF0aC5pZHMuc2xpY2UoLWRlcHRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiBwYXRoLnBvcyArIChwYXRoLmlkcy5sZW5ndGggLSBzdGVtbWVkLmxlbmd0aCksXG4gICAgICBpZHM6IHBhdGhUb1RyZWUoc3RlbW1lZClcbiAgICB9O1xuICB9KTtcbiAgLy8gVGhlbiB3ZSByZW1lcmdlIGFsbCB0aG9zZSBmbGF0IHRyZWVzIHRvZ2V0aGVyLCBlbnN1cmluZyB0aGF0IHdlIGRvbnRcbiAgLy8gY29ubmVjdCB0cmVlcyB0aGF0IHdvdWxkIGdvIGJleW9uZCB0aGUgZGVwdGggbGltaXRcbiAgcmV0dXJuIHN0ZW1tZWRQYXRocy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQsIGksIGFycikge1xuICAgIHJldHVybiBkb01lcmdlKHByZXYsIGN1cnJlbnQsIHRydWUpLnRyZWU7XG4gIH0sIFtzdGVtbWVkUGF0aHMuc2hpZnQoKV0pO1xufVxuXG52YXIgUG91Y2hNZXJnZSA9IHt9O1xuXG5Qb3VjaE1lcmdlLm1lcmdlID0gZnVuY3Rpb24gKHRyZWUsIHBhdGgsIGRlcHRoKSB7XG4gIC8vIFVnaCwgbmljZXIgd2F5IHRvIG5vdCBtb2RpZnkgYXJndW1lbnRzIGluIHBsYWNlP1xuICB0cmVlID0gZXh0ZW5kKHRydWUsIFtdLCB0cmVlKTtcbiAgcGF0aCA9IGV4dGVuZCh0cnVlLCB7fSwgcGF0aCk7XG4gIHZhciBuZXdUcmVlID0gZG9NZXJnZSh0cmVlLCBwYXRoKTtcbiAgcmV0dXJuIHtcbiAgICB0cmVlOiBzdGVtKG5ld1RyZWUudHJlZSwgZGVwdGgpLFxuICAgIGNvbmZsaWN0czogbmV3VHJlZS5jb25mbGljdHNcbiAgfTtcbn07XG5cbi8vIFdlIGZldGNoIGFsbCBsZWFmcyBvZiB0aGUgcmV2aXNpb24gdHJlZSwgYW5kIHNvcnQgdGhlbSBiYXNlZCBvbiB0cmVlIGxlbmd0aFxuLy8gYW5kIHdoZXRoZXIgdGhleSB3ZXJlIGRlbGV0ZWQsIHVuZGVsZXRlZCBkb2N1bWVudHMgd2l0aCB0aGUgbG9uZ2VzdCByZXZpc2lvblxuLy8gdHJlZSAobW9zdCBlZGl0cykgd2luXG4vLyBUaGUgZmluYWwgc29ydCBhbGdvcml0aG0gaXMgc2xpZ2h0bHkgZG9jdW1lbnRlZCBpbiBhIHNpZGViYXIgaGVyZTpcbi8vIGh0dHA6Ly9ndWlkZS5jb3VjaGRiLm9yZy9kcmFmdC9jb25mbGljdHMuaHRtbFxuUG91Y2hNZXJnZS53aW5uaW5nUmV2ID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gIHZhciBsZWFmcyA9IFtdO1xuICBQb3VjaE1lcmdlLnRyYXZlcnNlUmV2VHJlZShtZXRhZGF0YS5yZXZfdHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpc0xlYWYsIHBvcywgaWQsIHNvbWV0aGluZywgb3B0cykge1xuICAgIGlmIChpc0xlYWYpIHtcbiAgICAgIGxlYWZzLnB1c2goe3BvczogcG9zLCBpZDogaWQsIGRlbGV0ZWQ6ICEhb3B0cy5kZWxldGVkfSk7XG4gICAgfVxuICB9KTtcbiAgbGVhZnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmRlbGV0ZWQgIT09IGIuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIGEuZGVsZXRlZCA+IGIuZGVsZXRlZCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKGEucG9zICE9PSBiLnBvcykge1xuICAgICAgcmV0dXJuIGIucG9zIC0gYS5wb3M7XG4gICAgfVxuICAgIHJldHVybiBhLmlkIDwgYi5pZCA/IDEgOiAtMTtcbiAgfSk7XG5cbiAgcmV0dXJuIGxlYWZzWzBdLnBvcyArICctJyArIGxlYWZzWzBdLmlkO1xufTtcblxuLy8gUHJldHR5IG11Y2ggYWxsIGJlbG93IGNhbiBiZSBjb21iaW5lZCBpbnRvIGEgaGlnaGVyIG9yZGVyIGZ1bmN0aW9uIHRvXG4vLyB0cmF2ZXJzZSByZXZpc2lvbnNcbi8vIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBwYXNzZWQgYXMgY29udGV4dCB0byBhbGxcbi8vIGNoaWxkcmVuIG9mIHRoYXQgbm9kZVxuUG91Y2hNZXJnZS50cmF2ZXJzZVJldlRyZWUgPSBmdW5jdGlvbiAocmV2cywgY2FsbGJhY2spIHtcbiAgdmFyIHRvVmlzaXQgPSByZXZzLnNsaWNlKCk7XG5cbiAgdmFyIG5vZGU7XG4gIHdoaWxlICgobm9kZSA9IHRvVmlzaXQucG9wKCkpKSB7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zO1xuICAgIHZhciB0cmVlID0gbm9kZS5pZHM7XG4gICAgdmFyIGJyYW5jaGVzID0gdHJlZVsyXTtcbiAgICB2YXIgbmV3Q3R4ID1cbiAgICAgIGNhbGxiYWNrKGJyYW5jaGVzLmxlbmd0aCA9PT0gMCwgcG9zLCB0cmVlWzBdLCBub2RlLmN0eCwgdHJlZVsxXSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJyYW5jaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0b1Zpc2l0LnB1c2goe3BvczogcG9zICsgMSwgaWRzOiBicmFuY2hlc1tpXSwgY3R4OiBuZXdDdHh9KTtcbiAgICB9XG4gIH1cbn07XG5cblBvdWNoTWVyZ2UuY29sbGVjdExlYXZlcyA9IGZ1bmN0aW9uIChyZXZzKSB7XG4gIHZhciBsZWF2ZXMgPSBbXTtcbiAgUG91Y2hNZXJnZS50cmF2ZXJzZVJldlRyZWUocmV2cywgZnVuY3Rpb24gKGlzTGVhZiwgcG9zLCBpZCwgYWNjLCBvcHRzKSB7XG4gICAgaWYgKGlzTGVhZikge1xuICAgICAgbGVhdmVzLnVuc2hpZnQoe3JldjogcG9zICsgXCItXCIgKyBpZCwgcG9zOiBwb3MsIG9wdHM6IG9wdHN9KTtcbiAgICB9XG4gIH0pO1xuICBsZWF2ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnBvcyAtIGEucG9zO1xuICB9KTtcbiAgbGVhdmVzLm1hcChmdW5jdGlvbiAobGVhZikgeyBkZWxldGUgbGVhZi5wb3M7IH0pO1xuICByZXR1cm4gbGVhdmVzO1xufTtcblxuLy8gcmV0dXJucyByZXZzIG9mIGFsbCBjb25mbGljdHMgdGhhdCBpcyBsZWF2ZXMgc3VjaCB0aGF0XG4vLyAxLiBhcmUgbm90IGRlbGV0ZWQgYW5kXG4vLyAyLiBhcmUgZGlmZmVyZW50IHRoYW4gd2lubmluZyByZXZpc2lvblxuUG91Y2hNZXJnZS5jb2xsZWN0Q29uZmxpY3RzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gIHZhciB3aW4gPSBQb3VjaE1lcmdlLndpbm5pbmdSZXYobWV0YWRhdGEpO1xuICB2YXIgbGVhdmVzID0gUG91Y2hNZXJnZS5jb2xsZWN0TGVhdmVzKG1ldGFkYXRhLnJldl90cmVlKTtcbiAgdmFyIGNvbmZsaWN0cyA9IFtdO1xuICBsZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAobGVhZikge1xuICAgIGlmIChsZWFmLnJldiAhPT0gd2luICYmICFsZWFmLm9wdHMuZGVsZXRlZCkge1xuICAgICAgY29uZmxpY3RzLnB1c2gobGVhZi5yZXYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb25mbGljdHM7XG59O1xuXG5Qb3VjaE1lcmdlLnJvb3RUb0xlYWYgPSBmdW5jdGlvbiAodHJlZSkge1xuICB2YXIgcGF0aHMgPSBbXTtcbiAgUG91Y2hNZXJnZS50cmF2ZXJzZVJldlRyZWUodHJlZSwgZnVuY3Rpb24gKGlzTGVhZiwgcG9zLCBpZCwgaGlzdG9yeSwgb3B0cykge1xuICAgIGhpc3RvcnkgPSBoaXN0b3J5ID8gaGlzdG9yeS5zbGljZSgwKSA6IFtdO1xuICAgIGhpc3RvcnkucHVzaCh7aWQ6IGlkLCBvcHRzOiBvcHRzfSk7XG4gICAgaWYgKGlzTGVhZikge1xuICAgICAgdmFyIHJvb3RQb3MgPSBwb3MgKyAxIC0gaGlzdG9yeS5sZW5ndGg7XG4gICAgICBwYXRocy51bnNoaWZ0KHtwb3M6IHJvb3RQb3MsIGlkczogaGlzdG9yeX0pO1xuICAgIH1cbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfSk7XG4gIHJldHVybiBwYXRocztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQb3VjaE1lcmdlO1xuXG59LHtcInBvdWNoZGItZXh0ZW5kXCI6NTF9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbHMnKTtcbnZhciBFRSA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBDaGVja3BvaW50ZXIgPSBfZGVyZXFfKCcuL2NoZWNrcG9pbnRlcicpO1xudmFyIE1BWF9TSU1VTFRBTkVPVVNfUkVWUyA9IDUwO1xuXG5mdW5jdGlvbiByYW5kb21OdW1iZXIobWluLCBtYXgpIHtcbiAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gIG1heCA9IHBhcnNlSW50KG1heCwgMTApO1xuICBpZiAobWluICE9PSBtaW4pIHtcbiAgICBtaW4gPSAwO1xuICB9XG4gIGlmIChtYXggIT09IG1heCB8fCBtYXggPD0gbWluKSB7XG4gICAgbWF4ID0gKG1pbiB8fCAxKSA8PCAxOyAvL2RvdWJsaW5nXG4gIH0gZWxzZSB7XG4gICAgbWF4ID0gbWF4ICsgMTtcbiAgfVxuICB2YXIgcmF0aW8gPSBNYXRoLnJhbmRvbSgpO1xuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG5cbiAgcmV0dXJuIH5+KHJhbmdlICogcmF0aW8gKyBtaW4pOyAvLyB+fiBjb2VyY2VzIHRvIGFuIGludCwgYnV0IGZhc3QuXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRCYWNrT2ZmKG1pbikge1xuICB2YXIgbWF4ID0gMDtcbiAgaWYgKCFtaW4pIHtcbiAgICBtYXggPSAyMDAwO1xuICB9XG4gIHJldHVybiByYW5kb21OdW1iZXIobWluLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBiYWNrT2ZmKHJlcElkLCBzcmMsIHRhcmdldCwgb3B0cywgcmV0dXJuVmFsdWUsIHJlc3VsdCwgZXJyb3IpIHtcbiAgaWYgKG9wdHMucmV0cnkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuVmFsdWUuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgcmV0dXJuVmFsdWUucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9wdHMuZGVmYXVsdF9iYWNrX29mZiA9IG9wdHMuZGVmYXVsdF9iYWNrX29mZiB8fCAwO1xuICBvcHRzLnJldHJpZXMgPSBvcHRzLnJldHJpZXMgfHwgMDtcbiAgaWYgKHR5cGVvZiBvcHRzLmJhY2tfb2ZmX2Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cy5iYWNrX29mZl9mdW5jdGlvbiA9IGRlZmF1bHRCYWNrT2ZmO1xuICB9XG4gIG9wdHMucmV0cmllcysrO1xuICBpZiAob3B0cy5tYXhfcmV0cmllcyAmJiBvcHRzLnJldHJpZXMgPiBvcHRzLm1heF9yZXRyaWVzKSB7XG4gICAgcmV0dXJuVmFsdWUuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3RyaWVkICcgK1xuICAgICAgb3B0cy5yZXRyaWVzICsgJyB0aW1lcyBidXQgcmVwbGljYXRpb24gZmFpbGVkJykpO1xuICAgIHJldHVyblZhbHVlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm5WYWx1ZS5lbWl0KCdyZXF1ZXN0RXJyb3InLCBlcnJvcik7XG4gIGlmIChyZXR1cm5WYWx1ZS5zdGF0ZSA9PT0gJ2FjdGl2ZScpIHtcbiAgICByZXR1cm5WYWx1ZS5lbWl0KCdzeW5jU3RvcHBlZCcpO1xuICAgIHJldHVyblZhbHVlLnN0YXRlID0gJ3N0b3BwZWQnO1xuICAgIHJldHVyblZhbHVlLm9uY2UoJ3N5bmNSZXN0YXJ0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvcHRzLmN1cnJlbnRfYmFja19vZmYgPSBvcHRzLmRlZmF1bHRfYmFja19vZmY7XG4gICAgfSk7XG4gIH1cblxuICBvcHRzLmN1cnJlbnRfYmFja19vZmYgPSBvcHRzLmN1cnJlbnRfYmFja19vZmYgfHwgb3B0cy5kZWZhdWx0X2JhY2tfb2ZmO1xuICBvcHRzLmN1cnJlbnRfYmFja19vZmYgPSBvcHRzLmJhY2tfb2ZmX2Z1bmN0aW9uKG9wdHMuY3VycmVudF9iYWNrX29mZik7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJlcGxpY2F0ZShyZXBJZCwgc3JjLCB0YXJnZXQsIG9wdHMsIHJldHVyblZhbHVlKTtcbiAgfSwgb3B0cy5jdXJyZW50X2JhY2tfb2ZmKTtcbn1cblxuLy8gV2UgY3JlYXRlIGEgYmFzaWMgcHJvbWlzZSBzbyB0aGUgY2FsbGVyIGNhbiBjYW5jZWwgdGhlIHJlcGxpY2F0aW9uIHBvc3NpYmx5XG4vLyBiZWZvcmUgd2UgaGF2ZSBhY3R1YWxseSBzdGFydGVkIGxpc3RlbmluZyB0byBjaGFuZ2VzIGV0Y1xudXRpbHMuaW5oZXJpdHMoUmVwbGljYXRpb24sIEVFKTtcbmZ1bmN0aW9uIFJlcGxpY2F0aW9uKG9wdHMpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbiAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgdGhpcy5zdGF0ZSA9ICdwZW5kaW5nJztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB1dGlscy5Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICBzZWxmLm9uY2UoJ2NvbXBsZXRlJywgZnVsZmlsbCk7XG4gICAgc2VsZi5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gIH0pO1xuICBzZWxmLnRoZW4gPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9O1xuICBzZWxmW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAocmVqZWN0KSB7XG4gICAgcmV0dXJuIHByb21pc2VbXCJjYXRjaFwiXShyZWplY3QpO1xuICB9O1xuICAvLyBBcyB3ZSBhbGxvdyBlcnJvciBoYW5kbGluZyB2aWEgXCJlcnJvclwiIGV2ZW50IGFzIHdlbGwsXG4gIC8vIHB1dCBhIHN0dWIgaW4gaGVyZSBzbyB0aGF0IHJlamVjdGluZyBuZXZlciB0aHJvd3MgVW5oYW5kbGVkRXJyb3IuXG4gIHNlbGZbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7fSk7XG5cbn1cblxuUmVwbGljYXRpb24ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICB0aGlzLnN0YXRlID0gJ2NhbmNlbGxlZCc7XG4gIHRoaXMuZW1pdCgnY2FuY2VsJyk7XG59O1xuXG5SZXBsaWNhdGlvbi5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoc3JjLCB0YXJnZXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm9uY2UoJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICBzZWxmLnN0YXRlID0gJ2FjdGl2ZSc7XG4gICAgICBzZWxmLmVtaXQoJ3N5bmNTdGFydGVkJyk7XG4gICAgfSBlbHNlIGlmIChzZWxmLnN0YXRlID09PSAnc3RvcHBlZCcpIHtcbiAgICAgIHNlbGYuc3RhdGUgPSAnYWN0aXZlJztcbiAgICAgIHNlbGYuZW1pdCgnc3luY1Jlc3RhcnRlZCcpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICBzZWxmLmNhbmNlbCgpO1xuICB9XG4gIHNyYy5vbmNlKCdkZXN0cm95ZWQnLCBvbkRlc3Ryb3kpO1xuICB0YXJnZXQub25jZSgnZGVzdHJveWVkJywgb25EZXN0cm95KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2Rlc3Ryb3llZCcsIG9uRGVzdHJveSk7XG4gICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKCdkZXN0cm95ZWQnLCBvbkRlc3Ryb3kpO1xuICB9XG4gIHRoaXMudGhlbihjbGVhbnVwLCBjbGVhbnVwKTtcbn07XG5cblxuLy8gVE9ETzogY2hlY2sgQ291Y2hEQidzIHJlcGxpY2F0aW9uIGlkIGdlbmVyYXRpb25cbi8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkIHBhcnRpY3VsYXIgdG8gdGhpcyByZXBsaWNhdGlvblxuZnVuY3Rpb24gZ2VuUmVwbGljYXRpb25JZChzcmMsIHRhcmdldCwgb3B0cykge1xuICB2YXIgZmlsdGVyRnVuID0gb3B0cy5maWx0ZXIgPyBvcHRzLmZpbHRlci50b1N0cmluZygpIDogJyc7XG4gIHJldHVybiBzcmMuaWQoKS50aGVuKGZ1bmN0aW9uIChzcmNfaWQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmlkKCkudGhlbihmdW5jdGlvbiAodGFyZ2V0X2lkKSB7XG4gICAgICB2YXIgcXVlcnlEYXRhID0gc3JjX2lkICsgdGFyZ2V0X2lkICsgZmlsdGVyRnVuICtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0cy5xdWVyeV9wYXJhbXMpICsgb3B0cy5kb2NfaWRzO1xuICAgICAgcmV0dXJuIHV0aWxzLk1ENShxdWVyeURhdGEpLnRoZW4oZnVuY3Rpb24gKG1kNSkge1xuICAgICAgICAvLyBjYW4ndCB1c2Ugc3RyYWlnaHQtdXAgbWQ1IGFscGhhYmV0LCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBjaGFyICcvJyBpcyBpbnRlcnByZXRlZCBhcyBiZWluZyBmb3IgYXR0YWNobWVudHMsXG4gICAgICAgIC8vIGFuZCArIGlzIGFsc28gbm90IHVybC1zYWZlXG4gICAgICAgIG1kNSA9IG1kNS5yZXBsYWNlKC9cXC8vZywgJy4nKS5yZXBsYWNlKC9cXCsvZywgJ18nKTtcbiAgICAgICAgcmV0dXJuICdfbG9jYWwvJyArIG1kNTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGljYXRlKHJlcElkLCBzcmMsIHRhcmdldCwgb3B0cywgcmV0dXJuVmFsdWUsIHJlc3VsdCkge1xuICB2YXIgYmF0Y2hlcyA9IFtdOyAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYmF0Y2hlcyB0byBiZSBwcm9jZXNzZWRcbiAgdmFyIGN1cnJlbnRCYXRjaDsgICAgICAgICAgICAgICAvLyB0aGUgYmF0Y2ggY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZFxuICB2YXIgcGVuZGluZ0JhdGNoID0ge1xuICAgIHNlcTogMCxcbiAgICBjaGFuZ2VzOiBbXSxcbiAgICBkb2NzOiBbXVxuICB9OyAvLyBuZXh0IGJhdGNoLCBub3QgeWV0IHJlYWR5IHRvIGJlIHByb2Nlc3NlZFxuICB2YXIgd3JpdGluZ0NoZWNrcG9pbnQgPSBmYWxzZTsgIC8vIHRydWUgd2hpbGUgY2hlY2twb2ludCBpcyBiZWluZyB3cml0dGVuXG4gIHZhciBjaGFuZ2VzQ29tcGxldGVkID0gZmFsc2U7ICAgLy8gdHJ1ZSB3aGVuIGFsbCBjaGFuZ2VzIHJlY2VpdmVkXG4gIHZhciByZXBsaWNhdGlvbkNvbXBsZXRlZCA9IGZhbHNlOyAvLyB0cnVlIHdoZW4gcmVwbGljYXRpb24gaGFzIGNvbXBsZXRlZFxuICB2YXIgbGFzdF9zZXEgPSAwO1xuICB2YXIgY29udGludW91cyA9IG9wdHMuY29udGludW91cyB8fCBvcHRzLmxpdmUgfHwgZmFsc2U7XG4gIHZhciBiYXRjaF9zaXplID0gb3B0cy5iYXRjaF9zaXplIHx8IDEwMDtcbiAgdmFyIGJhdGNoZXNfbGltaXQgPSBvcHRzLmJhdGNoZXNfbGltaXQgfHwgMTA7XG4gIHZhciBjaGFuZ2VzUGVuZGluZyA9IGZhbHNlOyAgICAgLy8gdHJ1ZSB3aGlsZSBzcmMuY2hhbmdlcyBpcyBydW5uaW5nXG4gIHZhciBkb2NfaWRzID0gb3B0cy5kb2NfaWRzO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgY2FuY2VsbGVkOiBmYWxzZVxuICB9O1xuICB2YXIgY2hlY2twb2ludGVyID0gbmV3IENoZWNrcG9pbnRlcihzcmMsIHRhcmdldCwgcmVwSWQsIHN0YXRlKTtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IHtcbiAgICBvazogdHJ1ZSxcbiAgICBzdGFydF90aW1lOiBuZXcgRGF0ZSgpLFxuICAgIGRvY3NfcmVhZDogMCxcbiAgICBkb2NzX3dyaXR0ZW46IDAsXG4gICAgZG9jX3dyaXRlX2ZhaWx1cmVzOiAwLFxuICAgIGVycm9yczogW11cbiAgfTtcbiAgdmFyIGNoYW5nZXNPcHRzID0ge307XG4gIHJldHVyblZhbHVlLnJlYWR5KHNyYywgdGFyZ2V0KTtcblxuICBmdW5jdGlvbiB3cml0ZURvY3MoKSB7XG4gICAgaWYgKGN1cnJlbnRCYXRjaC5kb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZG9jcyA9IGN1cnJlbnRCYXRjaC5kb2NzO1xuICAgIHJldHVybiB0YXJnZXQuYnVsa0RvY3Moe1xuICAgICAgZG9jczogZG9jc1xuICAgIH0sIHtcbiAgICAgIG5ld19lZGl0czogZmFsc2VcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmIChzdGF0ZS5jYW5jZWxsZWQpIHtcbiAgICAgICAgY29tcGxldGVSZXBsaWNhdGlvbigpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbmNlbGxlZCcpO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0LmRvY193cml0ZV9mYWlsdXJlcysrO1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihyZXMucmVhc29uIHx8IHJlcy5tZXNzYWdlIHx8ICdVbmtub3duIHJlYXNvbicpO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSByZXMubmFtZSB8fCByZXMuZXJyb3I7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5lcnJvcnMgPSByZXN1bHQuZXJyb3JzLmNvbmNhdChlcnJvcnMpO1xuICAgICAgcmVzdWx0LmRvY3Nfd3JpdHRlbiArPSBjdXJyZW50QmF0Y2guZG9jcy5sZW5ndGggLSBlcnJvcnMubGVuZ3RoO1xuICAgICAgdmFyIG5vbjQwM3MgPSBlcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubmFtZSAhPT0gJ3VuYXV0aG9yaXplZCcgJiYgZXJyb3IubmFtZSAhPT0gJ2ZvcmJpZGRlbic7XG4gICAgICB9KTtcbiAgICAgIGlmIChub240MDNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdidWxrRG9jcyBlcnJvcicpO1xuICAgICAgICBlcnJvci5vdGhlcl9lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIGFib3J0UmVwbGljYXRpb24oJ3RhcmdldC5idWxrRG9jcyBmYWlsZWQgdG8gd3JpdGUgZG9jcycsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWxrV3JpdGUgcGFydGlhbCBmYWlsdXJlJyk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVzdWx0LmRvY193cml0ZV9mYWlsdXJlcyArPSBkb2NzLmxlbmd0aDtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZ2V0TmV4dERvYygpIHtcbiAgICB2YXIgZGlmZnMgPSBjdXJyZW50QmF0Y2guZGlmZnM7XG4gICAgdmFyIGlkID0gT2JqZWN0LmtleXMoZGlmZnMpWzBdO1xuICAgIHZhciBhbGxNaXNzaW5nID0gZGlmZnNbaWRdLm1pc3Npbmc7XG4gICAgLy8gYXZvaWQgdXJsIHRvbyBsb25nIGVycm9yIGJ5IGJhdGNoaW5nXG4gICAgdmFyIG1pc3NpbmdCYXRjaGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxNaXNzaW5nLmxlbmd0aDsgaSArPSBNQVhfU0lNVUxUQU5FT1VTX1JFVlMpIHtcbiAgICAgIG1pc3NpbmdCYXRjaGVzLnB1c2goYWxsTWlzc2luZy5zbGljZShpLCBNYXRoLm1pbihhbGxNaXNzaW5nLmxlbmd0aCxcbiAgICAgICAgaSArIE1BWF9TSU1VTFRBTkVPVVNfUkVWUykpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMuUHJvbWlzZS5hbGwobWlzc2luZ0JhdGNoZXMubWFwKGZ1bmN0aW9uIChtaXNzaW5nKSB7XG4gICAgICByZXR1cm4gc3JjLmdldChpZCwge3JldnM6IHRydWUsIG9wZW5fcmV2czogbWlzc2luZywgYXR0YWNobWVudHM6IHRydWV9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZG9jcykge1xuICAgICAgICAgIGRvY3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVJlcGxpY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9jLm9rKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5kb2NzX3JlYWQrKztcbiAgICAgICAgICAgICAgY3VycmVudEJhdGNoLnBlbmRpbmdSZXZzKys7XG4gICAgICAgICAgICAgIGN1cnJlbnRCYXRjaC5kb2NzLnB1c2goZG9jLm9rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgZGlmZnNbaWRdO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbGxEb2NzKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyhjdXJyZW50QmF0Y2guZGlmZnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBnZXROZXh0RG9jKCkudGhlbihnZXRBbGxEb2NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHV0aWxzLlByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gZ2V0UmV2aXNpb25PbmVEb2NzKCkge1xuICAgIC8vIGZpbHRlciBvdXQgdGhlIGdlbmVyYXRpb24gMSBkb2NzIGFuZCBnZXQgdGhlbVxuICAgIC8vIGxlYXZpbmcgdGhlIG5vbi1nZW5lcmF0aW9uIG9uZSBkb2NzIHRvIGJlIGdvdCBvdGhlcndpc2VcbiAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoY3VycmVudEJhdGNoLmRpZmZzKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgbWlzc2luZyA9IGN1cnJlbnRCYXRjaC5kaWZmc1tpZF0ubWlzc2luZztcbiAgICAgIHJldHVybiBtaXNzaW5nLmxlbmd0aCA9PT0gMSAmJiBtaXNzaW5nWzBdLnNsaWNlKDAsIDIpID09PSAnMS0nO1xuICAgIH0pO1xuICAgIHJldHVybiBzcmMuYWxsRG9jcyh7XG4gICAgICBrZXlzOiBpZHMsXG4gICAgICBpbmNsdWRlX2RvY3M6IHRydWVcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmIChzdGF0ZS5jYW5jZWxsZWQpIHtcbiAgICAgICAgY29tcGxldGVSZXBsaWNhdGlvbigpO1xuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdjYW5jZWxsZWQnKSk7XG4gICAgICB9XG4gICAgICByZXMucm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgaWYgKHJvdy5kb2MgJiYgIXJvdy5kZWxldGVkICYmXG4gICAgICAgICAgcm93LnZhbHVlLnJldi5zbGljZSgwLCAyKSA9PT0gJzEtJyAmJiAoXG4gICAgICAgICAgICAhcm93LmRvYy5fYXR0YWNobWVudHMgfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdy5kb2MuX2F0dGFjaG1lbnRzKS5sZW5ndGggPT09IDBcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHJlc3VsdC5kb2NzX3JlYWQrKztcbiAgICAgICAgICBjdXJyZW50QmF0Y2gucGVuZGluZ1JldnMrKztcbiAgICAgICAgICBjdXJyZW50QmF0Y2guZG9jcy5wdXNoKHJvdy5kb2MpO1xuICAgICAgICAgIGRlbGV0ZSBjdXJyZW50QmF0Y2guZGlmZnNbcm93LmlkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGdldERvY3MoKSB7XG4gICAgcmV0dXJuIGdldFJldmlzaW9uT25lRG9jcygpLnRoZW4oZ2V0QWxsRG9jcyk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZpbmlzaEJhdGNoKCkge1xuICAgIHdyaXRpbmdDaGVja3BvaW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hlY2twb2ludGVyLndyaXRlQ2hlY2twb2ludChcbiAgICAgIGN1cnJlbnRCYXRjaC5zZXFcbiAgICApLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgd3JpdGluZ0NoZWNrcG9pbnQgPSBmYWxzZTtcbiAgICAgIGlmIChzdGF0ZS5jYW5jZWxsZWQpIHtcbiAgICAgICAgY29tcGxldGVSZXBsaWNhdGlvbigpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbmNlbGxlZCcpO1xuICAgICAgfVxuICAgICAgcmVzdWx0Lmxhc3Rfc2VxID0gbGFzdF9zZXEgPSBjdXJyZW50QmF0Y2guc2VxO1xuICAgICAgcmV0dXJuVmFsdWUuZW1pdCgnY2hhbmdlJywgdXRpbHMuY2xvbmUocmVzdWx0KSk7XG4gICAgICBjdXJyZW50QmF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICBnZXRDaGFuZ2VzKCk7XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB3cml0aW5nQ2hlY2twb2ludCA9IGZhbHNlO1xuICAgICAgYWJvcnRSZXBsaWNhdGlvbignd3JpdGVDaGVja3BvaW50IGNvbXBsZXRlZCB3aXRoIGVycm9yJywgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZ2V0RGlmZnMoKSB7XG4gICAgdmFyIGRpZmYgPSB7fTtcbiAgICBjdXJyZW50QmF0Y2guY2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgIGRpZmZbY2hhbmdlLmlkXSA9IGNoYW5nZS5jaGFuZ2VzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5yZXY7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0LnJldnNEaWZmKGRpZmYpLnRoZW4oZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICBpZiAoc3RhdGUuY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbXBsZXRlUmVwbGljYXRpb24oKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5jZWxsZWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGN1cnJlbnRCYXRjaC5kaWZmcyBlbGVtZW50cyBhcmUgZGVsZXRlZCBhcyB0aGUgZG9jdW1lbnRzIGFyZSB3cml0dGVuXG4gICAgICBjdXJyZW50QmF0Y2guZGlmZnMgPSBkaWZmcztcbiAgICAgIGN1cnJlbnRCYXRjaC5wZW5kaW5nUmV2cyA9IDA7XG4gICAgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHN0YXJ0TmV4dEJhdGNoKCkge1xuICAgIGlmIChzdGF0ZS5jYW5jZWxsZWQgfHwgY3VycmVudEJhdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChiYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcHJvY2Vzc1BlbmRpbmdCYXRjaCh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudEJhdGNoID0gYmF0Y2hlcy5zaGlmdCgpO1xuICAgIGdldERpZmZzKClcbiAgICAudGhlbihnZXREb2NzKVxuICAgIC50aGVuKHdyaXRlRG9jcylcbiAgICAudGhlbihmaW5pc2hCYXRjaClcbiAgICAudGhlbihzdGFydE5leHRCYXRjaClbXG4gICAgXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBhYm9ydFJlcGxpY2F0aW9uKCdiYXRjaCBwcm9jZXNzaW5nIHRlcm1pbmF0ZWQgd2l0aCBlcnJvcicsIGVycik7XG4gICAgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NQZW5kaW5nQmF0Y2goaW1tZWRpYXRlKSB7XG4gICAgaWYgKHBlbmRpbmdCYXRjaC5jaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGJhdGNoZXMubGVuZ3RoID09PSAwICYmICFjdXJyZW50QmF0Y2gpIHtcbiAgICAgICAgaWYgKChjb250aW51b3VzICYmIGNoYW5nZXNPcHRzLmxpdmUpIHx8IGNoYW5nZXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZS5lbWl0KCd1cHRvZGF0ZScsIHV0aWxzLmNsb25lKHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzQ29tcGxldGVkKSB7XG4gICAgICAgICAgY29tcGxldGVSZXBsaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGltbWVkaWF0ZSB8fFxuICAgICAgY2hhbmdlc0NvbXBsZXRlZCB8fFxuICAgICAgcGVuZGluZ0JhdGNoLmNoYW5nZXMubGVuZ3RoID49IGJhdGNoX3NpemVcbiAgICApIHtcbiAgICAgIGJhdGNoZXMucHVzaChwZW5kaW5nQmF0Y2gpO1xuICAgICAgcGVuZGluZ0JhdGNoID0ge1xuICAgICAgICBzZXE6IDAsXG4gICAgICAgIGNoYW5nZXM6IFtdLFxuICAgICAgICBkb2NzOiBbXVxuICAgICAgfTtcbiAgICAgIHN0YXJ0TmV4dEJhdGNoKCk7XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBhYm9ydFJlcGxpY2F0aW9uKHJlYXNvbiwgZXJyKSB7XG4gICAgaWYgKHJlcGxpY2F0aW9uQ29tcGxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc3VsdC5vayA9IGZhbHNlO1xuICAgIHJlc3VsdC5zdGF0dXMgPSAnYWJvcnRpbmcnO1xuICAgIHJlc3VsdC5lcnJvcnMucHVzaChlcnIpO1xuICAgIGJhdGNoZXMgPSBbXTtcbiAgICBwZW5kaW5nQmF0Y2ggPSB7XG4gICAgICBzZXE6IDAsXG4gICAgICBjaGFuZ2VzOiBbXSxcbiAgICAgIGRvY3M6IFtdXG4gICAgfTtcbiAgICBjb21wbGV0ZVJlcGxpY2F0aW9uKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlUmVwbGljYXRpb24oKSB7XG4gICAgaWYgKHJlcGxpY2F0aW9uQ29tcGxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jYW5jZWxsZWQpIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnY2FuY2VsbGVkJztcbiAgICAgIGlmICh3cml0aW5nQ2hlY2twb2ludCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zdGF0dXMgPSByZXN1bHQuc3RhdHVzIHx8ICdjb21wbGV0ZSc7XG4gICAgcmVzdWx0LmVuZF90aW1lID0gbmV3IERhdGUoKTtcbiAgICByZXN1bHQubGFzdF9zZXEgPSBsYXN0X3NlcTtcbiAgICByZXBsaWNhdGlvbkNvbXBsZXRlZCA9IHN0YXRlLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgdmFyIG5vbjQwM3MgPSByZXN1bHQuZXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvci5uYW1lICE9PSAndW5hdXRob3JpemVkJyAmJiBlcnJvci5uYW1lICE9PSAnZm9yYmlkZGVuJztcbiAgICB9KTtcbiAgICBpZiAobm9uNDAzcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZXJyb3IgPSByZXN1bHQuZXJyb3JzLnBvcCgpO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBlcnJvci5vdGhlcl9lcnJvcnMgPSByZXN1bHQuZXJyb3JzO1xuICAgICAgfVxuICAgICAgZXJyb3IucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgYmFja09mZihyZXBJZCwgc3JjLCB0YXJnZXQsIG9wdHMsIHJldHVyblZhbHVlLCByZXN1bHQsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuVmFsdWUuZW1pdCgnY29tcGxldGUnLCByZXN1bHQpO1xuICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBvbkNoYW5nZShjaGFuZ2UpIHtcbiAgICBpZiAoc3RhdGUuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm4gY29tcGxldGVSZXBsaWNhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBwZW5kaW5nQmF0Y2guY2hhbmdlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIGJhdGNoZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAhY3VycmVudEJhdGNoXG4gICAgKSB7XG4gICAgICByZXR1cm5WYWx1ZS5lbWl0KCdvdXRvZmRhdGUnLCB1dGlscy5jbG9uZShyZXN1bHQpKTtcbiAgICB9XG4gICAgcGVuZGluZ0JhdGNoLnNlcSA9IGNoYW5nZS5zZXE7XG4gICAgcGVuZGluZ0JhdGNoLmNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgIHByb2Nlc3NQZW5kaW5nQmF0Y2goYmF0Y2hlcy5sZW5ndGggPT09IDApO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbkNoYW5nZXNDb21wbGV0ZShjaGFuZ2VzKSB7XG4gICAgY2hhbmdlc1BlbmRpbmcgPSBmYWxzZTtcbiAgICBpZiAoc3RhdGUuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm4gY29tcGxldGVSZXBsaWNhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlc09wdHMuc2luY2UgPCBjaGFuZ2VzLmxhc3Rfc2VxKSB7XG4gICAgICBjaGFuZ2VzT3B0cy5zaW5jZSA9IGNoYW5nZXMubGFzdF9zZXE7XG4gICAgICBnZXRDaGFuZ2VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250aW51b3VzKSB7XG4gICAgICAgIGNoYW5nZXNPcHRzLmxpdmUgPSB0cnVlO1xuICAgICAgICBnZXRDaGFuZ2VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFuZ2VzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdCYXRjaCh0cnVlKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VzRXJyb3IoZXJyKSB7XG4gICAgY2hhbmdlc1BlbmRpbmcgPSBmYWxzZTtcbiAgICBpZiAoc3RhdGUuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm4gY29tcGxldGVSZXBsaWNhdGlvbigpO1xuICAgIH1cbiAgICBhYm9ydFJlcGxpY2F0aW9uKCdjaGFuZ2VzIHJlamVjdGVkJywgZXJyKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZ2V0Q2hhbmdlcygpIHtcbiAgICBpZiAoIShcbiAgICAgICFjaGFuZ2VzUGVuZGluZyAmJlxuICAgICAgIWNoYW5nZXNDb21wbGV0ZWQgJiZcbiAgICAgIGJhdGNoZXMubGVuZ3RoIDwgYmF0Y2hlc19saW1pdFxuICAgICkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2hhbmdlc1BlbmRpbmcgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGFib3J0Q2hhbmdlcygpIHtcbiAgICAgIGNoYW5nZXMuY2FuY2VsKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlTGlzdGVuZXIoJ2NhbmNlbCcsIGFib3J0Q2hhbmdlcyk7XG4gICAgfVxuICAgIHJldHVyblZhbHVlLm9uY2UoJ2NhbmNlbCcsIGFib3J0Q2hhbmdlcyk7XG4gICAgdmFyIGNoYW5nZXMgPSBzcmMuY2hhbmdlcyhjaGFuZ2VzT3B0cylcbiAgICAub24oJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBjaGFuZ2VzLnRoZW4ocmVtb3ZlTGlzdGVuZXIsIHJlbW92ZUxpc3RlbmVyKTtcbiAgICBjaGFuZ2VzLnRoZW4ob25DaGFuZ2VzQ29tcGxldGUpW1xuICAgIFwiY2F0Y2hcIl0ob25DaGFuZ2VzRXJyb3IpO1xuICB9XG5cblxuICBmdW5jdGlvbiBzdGFydENoYW5nZXMoKSB7XG4gICAgY2hlY2twb2ludGVyLmdldENoZWNrcG9pbnQoKS50aGVuKGZ1bmN0aW9uIChjaGVja3BvaW50KSB7XG4gICAgICBsYXN0X3NlcSA9IGNoZWNrcG9pbnQ7XG4gICAgICBjaGFuZ2VzT3B0cyA9IHtcbiAgICAgICAgc2luY2U6IGxhc3Rfc2VxLFxuICAgICAgICBsaW1pdDogYmF0Y2hfc2l6ZSxcbiAgICAgICAgYmF0Y2hfc2l6ZTogYmF0Y2hfc2l6ZSxcbiAgICAgICAgc3R5bGU6ICdhbGxfZG9jcycsXG4gICAgICAgIGRvY19pZHM6IGRvY19pZHMsXG4gICAgICAgIHJldHVybkRvY3M6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKG9wdHMuZmlsdGVyKSB7XG4gICAgICAgIGNoYW5nZXNPcHRzLmZpbHRlciA9IG9wdHMuZmlsdGVyO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMucXVlcnlfcGFyYW1zKSB7XG4gICAgICAgIGNoYW5nZXNPcHRzLnF1ZXJ5X3BhcmFtcyA9IG9wdHMucXVlcnlfcGFyYW1zO1xuICAgICAgfVxuICAgICAgZ2V0Q2hhbmdlcygpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgYWJvcnRSZXBsaWNhdGlvbignZ2V0Q2hlY2twb2ludCByZWplY3RlZCB3aXRoICcsIGVycik7XG4gICAgfSk7XG4gIH1cblxuXG4gIHJldHVyblZhbHVlLm9uY2UoJ2NhbmNlbCcsIGNvbXBsZXRlUmVwbGljYXRpb24pO1xuXG4gIGlmICh0eXBlb2Ygb3B0cy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVyblZhbHVlLm9uKCdjaGFuZ2UnLCBvcHRzLm9uQ2hhbmdlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cy5jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVyblZhbHVlLm9uY2UoJ2Vycm9yJywgb3B0cy5jb21wbGV0ZSk7XG4gICAgcmV0dXJuVmFsdWUub25jZSgnY29tcGxldGUnLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBvcHRzLmNvbXBsZXRlKG51bGwsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMuc2luY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhcnRDaGFuZ2VzKCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGluZ0NoZWNrcG9pbnQgPSB0cnVlO1xuICAgIGNoZWNrcG9pbnRlci53cml0ZUNoZWNrcG9pbnQob3B0cy5zaW5jZSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICB3cml0aW5nQ2hlY2twb2ludCA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXRlLmNhbmNlbGxlZCkge1xuICAgICAgICBjb21wbGV0ZVJlcGxpY2F0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhc3Rfc2VxID0gb3B0cy5zaW5jZTtcbiAgICAgIHN0YXJ0Q2hhbmdlcygpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgd3JpdGluZ0NoZWNrcG9pbnQgPSBmYWxzZTtcbiAgICAgIGFib3J0UmVwbGljYXRpb24oJ3dyaXRlQ2hlY2twb2ludCBjb21wbGV0ZWQgd2l0aCBlcnJvcicsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy50b1BvdWNoID0gdG9Qb3VjaDtcbmZ1bmN0aW9uIHRvUG91Y2goZGIsIG9wdHMpIHtcbiAgdmFyIFBvdWNoQ29uc3RydWN0b3IgPSBvcHRzLlBvdWNoQ29uc3RydWN0b3I7XG4gIGlmICh0eXBlb2YgZGIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBQb3VjaENvbnN0cnVjdG9yKGRiKTtcbiAgfSBlbHNlIGlmIChkYi50aGVuKSB7XG4gICAgcmV0dXJuIGRiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1dGlscy5Qcm9taXNlLnJlc29sdmUoZGIpO1xuICB9XG59XG5cblxuZXhwb3J0cy5yZXBsaWNhdGUgPSByZXBsaWNhdGVXcmFwcGVyO1xuZnVuY3Rpb24gcmVwbGljYXRlV3JhcHBlcihzcmMsIHRhcmdldCwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGlmICghb3B0cy5jb21wbGV0ZSkge1xuICAgIG9wdHMuY29tcGxldGUgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuICBvcHRzID0gdXRpbHMuY2xvbmUob3B0cyk7XG4gIG9wdHMuY29udGludW91cyA9IG9wdHMuY29udGludW91cyB8fCBvcHRzLmxpdmU7XG4gIG9wdHMucmV0cnkgPSBvcHRzLnJldHJ5IHx8IGZhbHNlO1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBvcHRzLlBvdWNoQ29uc3RydWN0b3IgPSBvcHRzLlBvdWNoQ29uc3RydWN0b3IgfHwgdGhpcztcbiAgdmFyIHJlcGxpY2F0ZVJldCA9IG5ldyBSZXBsaWNhdGlvbihvcHRzKTtcbiAgdG9Qb3VjaChzcmMsIG9wdHMpLnRoZW4oZnVuY3Rpb24gKHNyYykge1xuICAgIHJldHVybiB0b1BvdWNoKHRhcmdldCwgb3B0cykudGhlbihmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2VuUmVwbGljYXRpb25JZChzcmMsIHRhcmdldCwgb3B0cykudGhlbihmdW5jdGlvbiAocmVwSWQpIHtcbiAgICAgICAgcmVwbGljYXRlKHJlcElkLCBzcmMsIHRhcmdldCwgb3B0cywgcmVwbGljYXRlUmV0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXBsaWNhdGVSZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIG9wdHMuY29tcGxldGUoZXJyKTtcbiAgfSk7XG4gIHJldHVybiByZXBsaWNhdGVSZXQ7XG59XG5cbn0se1wiLi9jaGVja3BvaW50ZXJcIjo3LFwiLi91dGlsc1wiOjI2LFwiZXZlbnRzXCI6MzB9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFBvdWNoREIgPSBfZGVyZXFfKFwiLi9jb25zdHJ1Y3RvclwiKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbHMnKTtcbnZhciBQcm9taXNlID0gdXRpbHMuUHJvbWlzZTtcbnZhciBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5Qb3VjaERCLmFkYXB0ZXJzID0ge307XG5Qb3VjaERCLnByZWZlcnJlZEFkYXB0ZXJzID0gX2RlcmVxXygnLi9hZGFwdGVycy9wcmVmZXJyZWRBZGFwdGVycy5qcycpO1xuXG5Qb3VjaERCLnByZWZpeCA9ICdfcG91Y2hfJztcblxudmFyIGV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxudmFyIGV2ZW50RW1pdHRlck1ldGhvZHMgPSBbXG4gICdvbicsXG4gICdhZGRMaXN0ZW5lcicsXG4gICdlbWl0JyxcbiAgJ2xpc3RlbmVycycsXG4gICdvbmNlJyxcbiAgJ3JlbW92ZUFsbExpc3RlbmVycycsXG4gICdyZW1vdmVMaXN0ZW5lcicsXG4gICdzZXRNYXhMaXN0ZW5lcnMnXG5dO1xuXG5ldmVudEVtaXR0ZXJNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBQb3VjaERCW21ldGhvZF0gPSBldmVudEVtaXR0ZXJbbWV0aG9kXS5iaW5kKGV2ZW50RW1pdHRlcik7XG59KTtcblBvdWNoREIuc2V0TWF4TGlzdGVuZXJzKDApO1xuUG91Y2hEQi5wYXJzZUFkYXB0ZXIgPSBmdW5jdGlvbiAobmFtZSwgb3B0cykge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKC8oW2EtelxcLV0qKTpcXC9cXC8oLiopLyk7XG4gIHZhciBhZGFwdGVyLCBhZGFwdGVyTmFtZTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgLy8gdGhlIGh0dHAgYWRhcHRlciBleHBlY3RzIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZVxuICAgIG5hbWUgPSAvaHR0cChzPykvLnRlc3QobWF0Y2hbMV0pID8gbWF0Y2hbMV0gKyAnOi8vJyArIG1hdGNoWzJdIDogbWF0Y2hbMl07XG4gICAgYWRhcHRlciA9IG1hdGNoWzFdO1xuICAgIGlmICghUG91Y2hEQi5hZGFwdGVyc1thZGFwdGVyXS52YWxpZCgpKSB7XG4gICAgICB0aHJvdyAnSW52YWxpZCBhZGFwdGVyJztcbiAgICB9XG4gICAgcmV0dXJuIHtuYW1lOiBuYW1lLCBhZGFwdGVyOiBtYXRjaFsxXX07XG4gIH1cblxuICAvLyBjaGVjayBmb3IgYnJvd3NlcnMgdGhhdCBoYXZlIGJlZW4gdXBncmFkZWQgZnJvbSB3ZWJzcWwtb25seSB0byB3ZWJzcWwraWRiXG4gIHZhciBza2lwSWRiID0gJ2lkYicgaW4gUG91Y2hEQi5hZGFwdGVycyAmJiAnd2Vic3FsJyBpbiBQb3VjaERCLmFkYXB0ZXJzICYmXG4gICAgdXRpbHMuaGFzTG9jYWxTdG9yYWdlKCkgJiZcbiAgICBnbG9iYWwubG9jYWxTdG9yYWdlWydfcG91Y2hfX3dlYnNxbGRiXycgKyBQb3VjaERCLnByZWZpeCArIG5hbWVdO1xuXG4gIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5kYikge1xuICAgIGFkYXB0ZXJOYW1lID0gJ2xldmVsZGInO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUG91Y2hEQi5wcmVmZXJyZWRBZGFwdGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgYWRhcHRlck5hbWUgPSBQb3VjaERCLnByZWZlcnJlZEFkYXB0ZXJzW2ldO1xuICAgICAgaWYgKGFkYXB0ZXJOYW1lIGluIFBvdWNoREIuYWRhcHRlcnMpIHtcbiAgICAgICAgaWYgKHNraXBJZGIgJiYgYWRhcHRlck5hbWUgPT09ICdpZGInKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIGtlZXAgdXNpbmcgd2Vic3FsIHRvIGF2b2lkIHVzZXIgZGF0YSBsb3NzXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRhcHRlciA9IFBvdWNoREIuYWRhcHRlcnNbYWRhcHRlck5hbWVdO1xuICBpZiAoYWRhcHRlck5hbWUgJiYgYWRhcHRlcikge1xuICAgIHZhciB1c2VfcHJlZml4ID0gJ3VzZV9wcmVmaXgnIGluIGFkYXB0ZXIgPyBhZGFwdGVyLnVzZV9wcmVmaXggOiB0cnVlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHVzZV9wcmVmaXggPyBQb3VjaERCLnByZWZpeCArIG5hbWUgOiBuYW1lLFxuICAgICAgYWRhcHRlcjogYWRhcHRlck5hbWVcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgJ05vIHZhbGlkIGFkYXB0ZXIgZm91bmQnO1xufTtcblxuUG91Y2hEQi5kZXN0cm95ID0gdXRpbHMudG9Qcm9taXNlKGZ1bmN0aW9uIChuYW1lLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSBuYW1lO1xuICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgYmFja2VuZCA9IFBvdWNoREIucGFyc2VBZGFwdGVyKG9wdHMubmFtZSB8fCBuYW1lLCBvcHRzKTtcbiAgdmFyIGRiTmFtZSA9IGJhY2tlbmQubmFtZTtcbiAgdmFyIGFkYXB0ZXIgPSBQb3VjaERCLmFkYXB0ZXJzW2JhY2tlbmQuYWRhcHRlcl07XG4gIHZhciB1c2VQcmVmaXggPSAndXNlX3ByZWZpeCcgaW4gYWRhcHRlciA/IGFkYXB0ZXIudXNlX3ByZWZpeCA6IHRydWU7XG4gIHZhciBiYXNlTmFtZSA9IHVzZVByZWZpeCA/XG4gICAgZGJOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyBQb3VjaERCLnByZWZpeCksICcnKSA6IGRiTmFtZTtcbiAgdmFyIGZ1bGxOYW1lID0gKGJhY2tlbmQuYWRhcHRlciA9PT0gJ2h0dHAnIHx8IGJhY2tlbmQuYWRhcHRlciA9PT0gJ2h0dHBzJyA/XG4gICAgICAnJyA6IChvcHRzLnByZWZpeCB8fCAnJykpICsgZGJOYW1lO1xuICBmdW5jdGlvbiBkZXN0cm95RGIoKSB7XG4gICAgLy8gY2FsbCBkZXN0cm95IG1ldGhvZCBvZiB0aGUgcGFydGljdWxhciBhZGFwdG9yXG4gICAgYWRhcHRlci5kZXN0cm95KGZ1bGxOYW1lLCBvcHRzLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBQb3VjaERCLmVtaXQoJ2Rlc3Ryb3llZCcsIG5hbWUpO1xuICAgICAgICAvL3NvIHdlIGRvbid0IGhhdmUgdG8gc2lmdCB0aHJvdWdoIGFsbCBkYm5hbWVzXG4gICAgICAgIFBvdWNoREIuZW1pdChuYW1lLCAnZGVzdHJveWVkJyk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3AgfHwgeyAnb2snOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGNyZWF0ZU9wdHMgPSB1dGlscy5leHRlbmQodHJ1ZSwge30sIG9wdHMsIHthZGFwdGVyIDogYmFja2VuZC5hZGFwdGVyfSk7XG4gIG5ldyBQb3VjaERCKGJhc2VOYW1lLCBjcmVhdGVPcHRzLCBmdW5jdGlvbiAoZXJyLCBkYikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBkYi5nZXQoJ19sb2NhbC9fcG91Y2hfZGVwZW5kZW50RGJzJywgZnVuY3Rpb24gKGVyciwgbG9jYWxEb2MpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5zdGF0dXMgIT09IDQwNCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgeyAvLyBubyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICByZXR1cm4gZGVzdHJveURiKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkZXBlbmRlbnREYnMgPSBsb2NhbERvYy5kZXBlbmRlbnREYnM7XG4gICAgICB2YXIgZGVsZXRlZE1hcCA9IE9iamVjdC5rZXlzKGRlcGVuZGVudERicykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciB0cnVlTmFtZSA9IHVzZVByZWZpeCA/XG4gICAgICAgICAgbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgUG91Y2hEQi5wcmVmaXgpLCAnJykgOiBuYW1lO1xuICAgICAgICB2YXIgc3ViT3B0cyA9IHV0aWxzLmV4dGVuZCh0cnVlLCBvcHRzLCB7YWRhcHRlcjogYmFja2VuZC5hZGFwdGVyfSk7XG4gICAgICAgIHJldHVybiBQb3VjaERCLmRlc3Ryb3kodHJ1ZU5hbWUsIHN1Yk9wdHMpO1xuICAgICAgfSk7XG4gICAgICBQcm9taXNlLmFsbChkZWxldGVkTWFwKS50aGVuKGRlc3Ryb3lEYiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5Qb3VjaERCLmFsbERicyA9IHV0aWxzLnRvUHJvbWlzZShmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignYWxsRGJzIG1ldGhvZCByZW1vdmVkJyk7XG4gIGVyci5zdGF0cyA9ICc0MDAnO1xuICBjYWxsYmFjayhlcnIpO1xufSk7XG5Qb3VjaERCLmFkYXB0ZXIgPSBmdW5jdGlvbiAoaWQsIG9iaikge1xuICBpZiAob2JqLnZhbGlkKCkpIHtcbiAgICBQb3VjaERCLmFkYXB0ZXJzW2lkXSA9IG9iajtcbiAgfVxufTtcblxuUG91Y2hEQi5wbHVnaW4gPSBmdW5jdGlvbiAob2JqKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICBQb3VjaERCLnByb3RvdHlwZVtpZF0gPSBvYmpbaWRdO1xuICB9KTtcbn07XG5cblBvdWNoREIuZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmYXVsdE9wdHMpIHtcbiAgZnVuY3Rpb24gUG91Y2hBbHQobmFtZSwgb3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0cyA9IG5hbWU7XG4gICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG9wdHMgPSB1dGlscy5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRPcHRzLCBvcHRzKTtcbiAgICBQb3VjaERCLmNhbGwodGhpcywgbmFtZSwgb3B0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgdXRpbHMuaW5oZXJpdHMoUG91Y2hBbHQsIFBvdWNoREIpO1xuXG4gIFBvdWNoQWx0LmRlc3Ryb3kgPSB1dGlscy50b1Byb21pc2UoZnVuY3Rpb24gKG5hbWUsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0cyA9IG5hbWU7XG4gICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRzID0gdXRpbHMuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0T3B0cywgb3B0cyk7XG4gICAgcmV0dXJuIFBvdWNoREIuZGVzdHJveShuYW1lLCBvcHRzLCBjYWxsYmFjayk7XG4gIH0pO1xuXG4gIGV2ZW50RW1pdHRlck1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgUG91Y2hBbHRbbWV0aG9kXSA9IGV2ZW50RW1pdHRlclttZXRob2RdLmJpbmQoZXZlbnRFbWl0dGVyKTtcbiAgfSk7XG4gIFBvdWNoQWx0LnNldE1heExpc3RlbmVycygwKTtcblxuICBQb3VjaEFsdC5wcmVmZXJyZWRBZGFwdGVycyA9IFBvdWNoREIucHJlZmVycmVkQWRhcHRlcnMuc2xpY2UoKTtcbiAgT2JqZWN0LmtleXMoUG91Y2hEQikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCEoa2V5IGluIFBvdWNoQWx0KSkge1xuICAgICAgUG91Y2hBbHRba2V5XSA9IFBvdWNoREJba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBQb3VjaEFsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG91Y2hEQjtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9hZGFwdGVycy9wcmVmZXJyZWRBZGFwdGVycy5qc1wiOjQsXCIuL2NvbnN0cnVjdG9yXCI6OCxcIi4vdXRpbHNcIjoyNixcImV2ZW50c1wiOjMwfV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xudmFyIHJlcGxpY2F0aW9uID0gX2RlcmVxXygnLi9yZXBsaWNhdGUnKTtcbnZhciByZXBsaWNhdGUgPSByZXBsaWNhdGlvbi5yZXBsaWNhdGU7XG52YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnV0aWxzLmluaGVyaXRzKFN5bmMsIEVFKTtcbm1vZHVsZS5leHBvcnRzID0gc3luYztcbmZ1bmN0aW9uIHN5bmMoc3JjLCB0YXJnZXQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICBvcHRzID0gdXRpbHMuY2xvbmUob3B0cyk7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIG9wdHMuUG91Y2hDb25zdHJ1Y3RvciA9IG9wdHMuUG91Y2hDb25zdHJ1Y3RvciB8fCB0aGlzO1xuICBzcmMgPSByZXBsaWNhdGlvbi50b1BvdWNoKHNyYywgb3B0cyk7XG4gIHRhcmdldCA9IHJlcGxpY2F0aW9uLnRvUG91Y2godGFyZ2V0LCBvcHRzKTtcbiAgcmV0dXJuIG5ldyBTeW5jKHNyYywgdGFyZ2V0LCBvcHRzLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBTeW5jKHNyYywgdGFyZ2V0LCBvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcbiAgXG4gIHZhciBvbkNoYW5nZSwgY29tcGxldGU7XG4gIGlmICgnb25DaGFuZ2UnIGluIG9wdHMpIHtcbiAgICBvbkNoYW5nZSA9IG9wdHMub25DaGFuZ2U7XG4gICAgZGVsZXRlIG9wdHMub25DaGFuZ2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3B0cy5jb21wbGV0ZSkge1xuICAgIGNvbXBsZXRlID0gY2FsbGJhY2s7XG4gIH0gZWxzZSBpZiAoJ2NvbXBsZXRlJyBpbiBvcHRzKSB7XG4gICAgY29tcGxldGUgPSBvcHRzLmNvbXBsZXRlO1xuICAgIGRlbGV0ZSBvcHRzLmNvbXBsZXRlO1xuICB9XG5cbiAgdGhpcy5wdXNoID0gcmVwbGljYXRlKHNyYywgdGFyZ2V0LCBvcHRzKTtcblxuICB0aGlzLnB1bGwgPSByZXBsaWNhdGUodGFyZ2V0LCBzcmMsIG9wdHMpO1xuICB2YXIgZW1pdHRlZENhbmNlbCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbkNhbmNlbChkYXRhKSB7XG4gICAgaWYgKCFlbWl0dGVkQ2FuY2VsKSB7XG4gICAgICBlbWl0dGVkQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnY2FuY2VsJywgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHVsbENoYW5nZShjaGFuZ2UpIHtcbiAgICBzZWxmLmVtaXQoJ2NoYW5nZScsIHtcbiAgICAgIGRpcmVjdGlvbjogJ3B1bGwnLFxuICAgICAgY2hhbmdlOiBjaGFuZ2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwdXNoQ2hhbmdlKGNoYW5nZSkge1xuICAgIHNlbGYuZW1pdCgnY2hhbmdlJywge1xuICAgICAgZGlyZWN0aW9uOiAncHVzaCcsXG4gICAgICBjaGFuZ2U6IGNoYW5nZVxuICAgIH0pO1xuICB9XG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcblxuICB2YXIgcmVtb3ZlZCA9IHt9O1xuICBmdW5jdGlvbiByZW1vdmVBbGwodHlwZSkgeyAvLyB0eXBlIGlzICdwdXNoJyBvciAncHVsbCdcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBmdW5jKSB7XG4gICAgICB2YXIgaXNDaGFuZ2UgPSBldmVudCA9PT0gJ2NoYW5nZScgJiZcbiAgICAgICAgKGZ1bmMgPT09IHB1bGxDaGFuZ2UgfHwgZnVuYyA9PT0gcHVzaENoYW5nZSk7XG4gICAgICB2YXIgaXNDYW5jZWwgPSBldmVudCA9PT0gJ2NhbmNlbCcgJiYgZnVuYyA9PT0gb25DYW5jZWw7XG4gICAgICB2YXIgaXNPdGhlckV2ZW50ID0gZXZlbnQgaW4gbGlzdGVuZXJzICYmIGZ1bmMgPT09IGxpc3RlbmVyc1tldmVudF07XG5cbiAgICAgIGlmIChpc0NoYW5nZSB8fCBpc0NhbmNlbCB8fCBpc090aGVyRXZlbnQpIHtcbiAgICAgICAgaWYgKCEoZXZlbnQgaW4gcmVtb3ZlZCkpIHtcbiAgICAgICAgICByZW1vdmVkW2V2ZW50XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZWRbZXZlbnRdW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlbW92ZWRbZXZlbnRdKS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAvLyBib3RoIHB1c2ggYW5kIHB1bGwgaGF2ZSBhc2tlZCB0byBiZSByZW1vdmVkXG4gICAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMub24oJ25ld0xpc3RlbmVyJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSAnY2hhbmdlJykge1xuICAgICAgc2VsZi5wdWxsLm9uKCdjaGFuZ2UnLCBwdWxsQ2hhbmdlKTtcbiAgICAgIHNlbGYucHVzaC5vbignY2hhbmdlJywgcHVzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChldmVudCA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgIHNlbGYucHVsbC5vbignY2FuY2VsJywgb25DYW5jZWwpO1xuICAgICAgc2VsZi5wdXNoLm9uKCdjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgfSBlbHNlIGlmIChldmVudCAhPT0gJ2Vycm9yJyAmJlxuICAgICAgZXZlbnQgIT09ICdyZW1vdmVMaXN0ZW5lcicgJiZcbiAgICAgIGV2ZW50ICE9PSAnY29tcGxldGUnICYmICEoZXZlbnQgaW4gbGlzdGVuZXJzKSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZW1pdChldmVudCwgZSk7XG4gICAgICB9O1xuICAgICAgc2VsZi5wdWxsLm9uKGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdKTtcbiAgICAgIHNlbGYucHVzaC5vbihldmVudCwgbGlzdGVuZXJzW2V2ZW50XSk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLm9uKCdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZScpIHtcbiAgICAgIHNlbGYucHVsbC5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgcHVsbENoYW5nZSk7XG4gICAgICBzZWxmLnB1c2gucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHB1c2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdjYW5jZWwnKSB7XG4gICAgICBzZWxmLnB1bGwucmVtb3ZlTGlzdGVuZXIoJ2NhbmNlbCcsIG9uQ2FuY2VsKTtcbiAgICAgIHNlbGYucHVzaC5yZW1vdmVMaXN0ZW5lcignY2FuY2VsJywgb25DYW5jZWwpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyc1tldmVudF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2VsZi5wdWxsLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdKTtcbiAgICAgICAgc2VsZi5wdXNoLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF07XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB0aGlzLnB1bGwub24oJ3JlbW92ZUxpc3RlbmVyJywgcmVtb3ZlQWxsKCdwdWxsJykpO1xuICB0aGlzLnB1c2gub24oJ3JlbW92ZUxpc3RlbmVyJywgcmVtb3ZlQWxsKCdwdXNoJykpO1xuXG4gIHZhciBwcm9taXNlID0gdXRpbHMuUHJvbWlzZS5hbGwoW1xuICAgIHRoaXMucHVzaCxcbiAgICB0aGlzLnB1bGxcbiAgXSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgIHZhciBvdXQgPSB7XG4gICAgICBwdXNoOiByZXNwWzBdLFxuICAgICAgcHVsbDogcmVzcFsxXVxuICAgIH07XG4gICAgc2VsZi5lbWl0KCdjb21wbGV0ZScsIG91dCk7XG4gICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICBjb21wbGV0ZShudWxsLCBvdXQpO1xuICAgIH1cbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmNhbmNlbCgpO1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgY29tcGxldGUoZXJyKTtcbiAgICB9XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuXG4gIHRoaXMudGhlbiA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnIpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHN1Y2Nlc3MsIGVycik7XG4gIH07XG5cbiAgdGhpc1tcImNhdGNoXCJdID0gZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiBwcm9taXNlW1wiY2F0Y2hcIl0oZXJyKTtcbiAgfTtcbn1cblxuU3luYy5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2FuY2VsZWQpIHtcbiAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICB0aGlzLnB1c2guY2FuY2VsKCk7XG4gICAgdGhpcy5wdWxsLmNhbmNlbCgpO1xuICB9XG59O1xuXG59LHtcIi4vcmVwbGljYXRlXCI6MjIsXCIuL3V0aWxzXCI6MjYsXCJldmVudHNcIjozMH1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrUXVldWU7XG5cbmZ1bmN0aW9uIFRhc2tRdWV1ZSgpIHtcbiAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gIHRoaXMuZmFpbGVkID0gZmFsc2U7XG4gIHRoaXMucXVldWUgPSBbXTtcbn1cblxuVGFza1F1ZXVlLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZCwgZnVuYztcbiAgaWYgKHRoaXMuZmFpbGVkKSB7XG4gICAgd2hpbGUgKChkID0gdGhpcy5xdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgaWYgKHR5cGVvZiBkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGQodGhpcy5mYWlsZWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBkLnBhcmFtZXRlcnNbZC5wYXJhbWV0ZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZ1bmModGhpcy5mYWlsZWQpO1xuICAgICAgfSBlbHNlIGlmIChkLm5hbWUgPT09ICdjaGFuZ2VzJyAmJiB0eXBlb2YgZnVuYy5jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmdW5jLmNvbXBsZXRlKHRoaXMuZmFpbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5pc1JlYWR5KSB7XG4gICAgd2hpbGUgKChkID0gdGhpcy5xdWV1ZS5zaGlmdCgpKSkge1xuXG4gICAgICBpZiAodHlwZW9mIGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZC50YXNrID0gdGhpcy5kYltkLm5hbWVdLmFwcGx5KHRoaXMuZGIsIGQucGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5UYXNrUXVldWUucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZmFpbGVkID0gZXJyO1xuICB0aGlzLmV4ZWN1dGUoKTtcbn07XG5cblRhc2tRdWV1ZS5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoZGIpIHtcbiAgaWYgKHRoaXMuZmFpbGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5pc1JlYWR5O1xuICB9XG4gIHRoaXMuaXNSZWFkeSA9IGRiID8gdHJ1ZTogZmFsc2U7XG4gIHRoaXMuZGIgPSBkYjtcbiAgdGhpcy5leGVjdXRlKCk7XG59O1xuXG5UYXNrUXVldWUucHJvdG90eXBlLmFkZFRhc2sgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1ldGVycykge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmFtZSk7XG4gICAgaWYgKHRoaXMuZmFpbGVkKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhc2sgPSB7IG5hbWU6IG5hbWUsIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMgfTtcbiAgICB0aGlzLnF1ZXVlLnB1c2godGFzayk7XG4gICAgaWYgKHRoaXMuZmFpbGVkKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhc2s7XG4gIH1cbn07XG5cbn0se31dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLypqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuLypnbG9iYWwgY2hyb21lICovXG52YXIgbWVyZ2UgPSBfZGVyZXFfKCcuL21lcmdlJyk7XG5leHBvcnRzLmV4dGVuZCA9IF9kZXJlcV8oJ3BvdWNoZGItZXh0ZW5kJyk7XG5leHBvcnRzLmFqYXggPSBfZGVyZXFfKCcuL2RlcHMvYWpheCcpO1xuZXhwb3J0cy5jcmVhdGVCbG9iID0gX2RlcmVxXygnLi9kZXBzL2Jsb2InKTtcbmV4cG9ydHMudXVpZCA9IF9kZXJlcV8oJy4vZGVwcy91dWlkJyk7XG5leHBvcnRzLmdldEFyZ3VtZW50cyA9IF9kZXJlcV8oJ2FyZ3NhcnJheScpO1xudmFyIGJ1ZmZlciA9IF9kZXJlcV8oJy4vZGVwcy9idWZmZXInKTtcbnZhciBlcnJvcnMgPSBfZGVyZXFfKCcuL2RlcHMvZXJyb3JzJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGNvbGxlY3Rpb25zID0gX2RlcmVxXygnLi9kZXBzL2NvbGxlY3Rpb25zJyk7XG5leHBvcnRzLk1hcCA9IGNvbGxlY3Rpb25zLk1hcDtcbmV4cG9ydHMuU2V0ID0gY29sbGVjdGlvbnMuU2V0O1xuXG5pZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlID09PSAnZnVuY3Rpb24nKSB7XG4gIGV4cG9ydHMuUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xufSBlbHNlIHtcbiAgZXhwb3J0cy5Qcm9taXNlID0gX2RlcmVxXygnYmx1ZWJpcmQnKTtcbn1cbnZhciBQcm9taXNlID0gZXhwb3J0cy5Qcm9taXNlO1xuXG5mdW5jdGlvbiB0b09iamVjdChhcnJheSkge1xuICB2YXIgb2JqID0ge307XG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgb2JqW2l0ZW1dID0gdHJ1ZTsgfSk7XG4gIHJldHVybiBvYmo7XG59XG4vLyBMaXN0IG9mIHRvcCBsZXZlbCByZXNlcnZlZCB3b3JkcyBmb3IgZG9jXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHRvT2JqZWN0KFtcbiAgJ19pZCcsXG4gICdfcmV2JyxcbiAgJ19hdHRhY2htZW50cycsXG4gICdfZGVsZXRlZCcsXG4gICdfcmV2aXNpb25zJyxcbiAgJ19yZXZzX2luZm8nLFxuICAnX2NvbmZsaWN0cycsXG4gICdfZGVsZXRlZF9jb25mbGljdHMnLFxuICAnX2xvY2FsX3NlcScsXG4gICdfcmV2X3RyZWUnLFxuICAvL3JlcGxpY2F0aW9uIGRvY3VtZW50c1xuICAnX3JlcGxpY2F0aW9uX2lkJyxcbiAgJ19yZXBsaWNhdGlvbl9zdGF0ZScsXG4gICdfcmVwbGljYXRpb25fc3RhdGVfdGltZScsXG4gICdfcmVwbGljYXRpb25fc3RhdGVfcmVhc29uJyxcbiAgJ19yZXBsaWNhdGlvbl9zdGF0cydcbl0pO1xuXG4vLyBMaXN0IG9mIHJlc2VydmVkIHdvcmRzIHRoYXQgc2hvdWxkIGVuZCB1cCB0aGUgZG9jdW1lbnRcbnZhciBkYXRhV29yZHMgPSB0b09iamVjdChbXG4gICdfYXR0YWNobWVudHMnLFxuICAvL3JlcGxpY2F0aW9uIGRvY3VtZW50c1xuICAnX3JlcGxpY2F0aW9uX2lkJyxcbiAgJ19yZXBsaWNhdGlvbl9zdGF0ZScsXG4gICdfcmVwbGljYXRpb25fc3RhdGVfdGltZScsXG4gICdfcmVwbGljYXRpb25fc3RhdGVfcmVhc29uJyxcbiAgJ19yZXBsaWNhdGlvbl9zdGF0cydcbl0pO1xuXG5leHBvcnRzLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gKHN0ciwgY2hhcikge1xuICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoaSkgPT09IGNoYXIpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKHRydWUsIHt9LCBvYmopO1xufTtcbmV4cG9ydHMuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuLy8gRGV0ZXJtaW5lIGlkIGFuIElEIGlzIHZhbGlkXG4vLyAgIC0gaW52YWxpZCBJRHMgYmVnaW4gd2l0aCBhbiB1bmRlcmVzY29yZSB0aGF0IGRvZXMgbm90IGJlZ2luICdfZGVzaWduJyBvclxuLy8gICAgICdfbG9jYWwnXG4vLyAgIC0gYW55IG90aGVyIHN0cmluZyB2YWx1ZSBpcyBhIHZhbGlkIGlkXG4vLyBSZXR1cm5zIHRoZSBzcGVjaWZpYyBlcnJvciBvYmplY3QgZm9yIGVhY2ggY2FzZVxuZXhwb3J0cy5pbnZhbGlkSWRFcnJvciA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZXJyO1xuICBpZiAoIWlkKSB7XG4gICAgZXJyID0gbmV3IFR5cGVFcnJvcihlcnJvcnMuTUlTU0lOR19JRC5tZXNzYWdlKTtcbiAgICBlcnIuc3RhdHVzID0gNDEyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICBlcnIgPSBuZXcgVHlwZUVycm9yKGVycm9ycy5JTlZBTElEX0lELm1lc3NhZ2UpO1xuICAgIGVyci5zdGF0dXMgPSA0MDA7XG4gIH0gZWxzZSBpZiAoL15fLy50ZXN0KGlkKSAmJiAhKC9eXyhkZXNpZ258bG9jYWwpLykudGVzdChpZCkpIHtcbiAgICBlcnIgPSBuZXcgVHlwZUVycm9yKGVycm9ycy5SRVNFUlZFRF9JRC5tZXNzYWdlKTtcbiAgICBlcnIuc3RhdHVzID0gNDAwO1xuICB9XG4gIGlmIChlcnIpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzQ2hyb21lQXBwKCkge1xuICByZXR1cm4gKHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICB0eXBlb2YgY2hyb21lLnN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICB0eXBlb2YgY2hyb21lLnN0b3JhZ2UubG9jYWwgIT09IFwidW5kZWZpbmVkXCIpO1xufVxuXG4vLyBQcmV0dHkgZHVtYiBuYW1lIGZvciBhIGZ1bmN0aW9uLCBqdXN0IHdyYXBzIGNhbGxiYWNrIGNhbGxzIHNvIHdlIGRvbnRcbi8vIHRvIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKSBldmVyeXdoZXJlXG5leHBvcnRzLmNhbGwgPSBleHBvcnRzLmdldEFyZ3VtZW50cyhmdW5jdGlvbiAoYXJncykge1xuICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBmdW4gPSBhcmdzLnNoaWZ0KCk7XG4gIGlmICh0eXBlb2YgZnVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZnVuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59KTtcblxuZXhwb3J0cy5pc0xvY2FsSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuICgvXl9sb2NhbC8pLnRlc3QoaWQpO1xufTtcblxuLy8gY2hlY2sgaWYgYSBzcGVjaWZpYyByZXZpc2lvbiBvZiBhIGRvYyBoYXMgYmVlbiBkZWxldGVkXG4vLyAgLSBtZXRhZGF0YTogdGhlIG1ldGFkYXRhIG9iamVjdCBmcm9tIHRoZSBkb2Mgc3RvcmVcbi8vICAtIHJldjogKG9wdGlvbmFsKSB0aGUgcmV2aXNpb24gdG8gY2hlY2suIGRlZmF1bHRzIHRvIHdpbm5pbmcgcmV2aXNpb25cbmV4cG9ydHMuaXNEZWxldGVkID0gZnVuY3Rpb24gKG1ldGFkYXRhLCByZXYpIHtcbiAgaWYgKCFyZXYpIHtcbiAgICByZXYgPSBtZXJnZS53aW5uaW5nUmV2KG1ldGFkYXRhKTtcbiAgfVxuICB2YXIgZGFzaEluZGV4ID0gcmV2LmluZGV4T2YoJy0nKTtcbiAgaWYgKGRhc2hJbmRleCAhPT0gLTEpIHtcbiAgICByZXYgPSByZXYuc3Vic3RyaW5nKGRhc2hJbmRleCArIDEpO1xuICB9XG4gIHZhciBkZWxldGVkID0gZmFsc2U7XG4gIG1lcmdlLnRyYXZlcnNlUmV2VHJlZShtZXRhZGF0YS5yZXZfdHJlZSxcbiAgZnVuY3Rpb24gKGlzTGVhZiwgcG9zLCBpZCwgYWNjLCBvcHRzKSB7XG4gICAgaWYgKGlkID09PSByZXYpIHtcbiAgICAgIGRlbGV0ZWQgPSAhIW9wdHMuZGVsZXRlZDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkZWxldGVkO1xufTtcblxuZXhwb3J0cy5yZXZFeGlzdHMgPSBmdW5jdGlvbiAobWV0YWRhdGEsIHJldikge1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgbWVyZ2UudHJhdmVyc2VSZXZUcmVlKG1ldGFkYXRhLnJldl90cmVlLCBmdW5jdGlvbiAobGVhZiwgcG9zLCBpZCwgYWNjLCBvcHRzKSB7XG4gICAgaWYgKChwb3MgKyAnLScgKyBpZCkgPT09IHJldikge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmb3VuZDtcbn07XG5cbmV4cG9ydHMuZmlsdGVyQ2hhbmdlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICB2YXIgcmVxID0ge307XG4gICAgdmFyIGhhc0ZpbHRlciA9IG9wdHMuZmlsdGVyICYmIHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIHJlcS5xdWVyeSA9IG9wdHMucXVlcnlfcGFyYW1zO1xuICAgIGlmIChvcHRzLmZpbHRlciAmJiBoYXNGaWx0ZXIgJiYgIW9wdHMuZmlsdGVyLmNhbGwodGhpcywgY2hhbmdlLmRvYywgcmVxKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3B0cy5kb2NfaWRzICYmIG9wdHMuZG9jX2lkcy5pbmRleE9mKGNoYW5nZS5pZCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghb3B0cy5pbmNsdWRlX2RvY3MpIHtcbiAgICAgIGRlbGV0ZSBjaGFuZ2UuZG9jO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBhdHQgaW4gY2hhbmdlLmRvYy5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5kb2MuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGF0dCkpIHtcbiAgICAgICAgICBjaGFuZ2UuZG9jLl9hdHRhY2htZW50c1thdHRdLnN0dWIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufTtcblxuLy8gUHJlcHJvY2VzcyBkb2N1bWVudHMsIHBhcnNlIHRoZWlyIHJldmlzaW9ucywgYXNzaWduIGFuIGlkIGFuZCBhXG4vLyByZXZpc2lvbiBmb3IgbmV3IHdyaXRlcyB0aGF0IGFyZSBtaXNzaW5nIHRoZW0sIGV0Y1xuZXhwb3J0cy5wYXJzZURvYyA9IGZ1bmN0aW9uIChkb2MsIG5ld0VkaXRzKSB7XG4gIHZhciBuUmV2TnVtO1xuICB2YXIgbmV3UmV2SWQ7XG4gIHZhciByZXZJbmZvO1xuICB2YXIgZXJyb3I7XG4gIHZhciBvcHRzID0ge3N0YXR1czogJ2F2YWlsYWJsZSd9O1xuICBpZiAoZG9jLl9kZWxldGVkKSB7XG4gICAgb3B0cy5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChuZXdFZGl0cykge1xuICAgIGlmICghZG9jLl9pZCkge1xuICAgICAgZG9jLl9pZCA9IGV4cG9ydHMudXVpZCgpO1xuICAgIH1cbiAgICBuZXdSZXZJZCA9IGV4cG9ydHMudXVpZCgzMiwgMTYpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGRvYy5fcmV2KSB7XG4gICAgICByZXZJbmZvID0gL14oXFxkKyktKC4rKSQvLmV4ZWMoZG9jLl9yZXYpO1xuICAgICAgaWYgKCFyZXZJbmZvKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgcHJvcGVydHkgJ19yZXYnXCIpO1xuICAgICAgICBlcnIuc3RhdHVzID0gNDAwO1xuICAgICAgfVxuICAgICAgZG9jLl9yZXZfdHJlZSA9IFt7XG4gICAgICAgIHBvczogcGFyc2VJbnQocmV2SW5mb1sxXSwgMTApLFxuICAgICAgICBpZHM6IFtyZXZJbmZvWzJdLCB7c3RhdHVzOiAnbWlzc2luZyd9LCBbW25ld1JldklkLCBvcHRzLCBbXV1dXVxuICAgICAgfV07XG4gICAgICBuUmV2TnVtID0gcGFyc2VJbnQocmV2SW5mb1sxXSwgMTApICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jLl9yZXZfdHJlZSA9IFt7XG4gICAgICAgIHBvczogMSxcbiAgICAgICAgaWRzIDogW25ld1JldklkLCBvcHRzLCBbXV1cbiAgICAgIH1dO1xuICAgICAgblJldk51bSA9IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkb2MuX3JldmlzaW9ucykge1xuICAgICAgZG9jLl9yZXZfdHJlZSA9IFt7XG4gICAgICAgIHBvczogZG9jLl9yZXZpc2lvbnMuc3RhcnQgLSBkb2MuX3JldmlzaW9ucy5pZHMubGVuZ3RoICsgMSxcbiAgICAgICAgaWRzOiBkb2MuX3JldmlzaW9ucy5pZHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHgpIHtcbiAgICAgICAgICBpZiAoYWNjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIG9wdHMsIFtdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB7c3RhdHVzOiAnbWlzc2luZyd9LCBbYWNjXV07XG4gICAgICAgICAgfVxuICAgICAgICB9LCBudWxsKVxuICAgICAgfV07XG4gICAgICBuUmV2TnVtID0gZG9jLl9yZXZpc2lvbnMuc3RhcnQ7XG4gICAgICBuZXdSZXZJZCA9IGRvYy5fcmV2aXNpb25zLmlkc1swXTtcbiAgICB9XG4gICAgaWYgKCFkb2MuX3Jldl90cmVlKSB7XG4gICAgICByZXZJbmZvID0gL14oXFxkKyktKC4rKSQvLmV4ZWMoZG9jLl9yZXYpO1xuICAgICAgaWYgKCFyZXZJbmZvKSB7XG4gICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihlcnJvcnMuQkFEX0FSRy5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3Iuc3RhdHVzID0gZXJyb3JzLkJBRF9BUkcuc3RhdHVzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIG5SZXZOdW0gPSBwYXJzZUludChyZXZJbmZvWzFdLCAxMCk7XG4gICAgICBuZXdSZXZJZCA9IHJldkluZm9bMl07XG4gICAgICBkb2MuX3Jldl90cmVlID0gW3tcbiAgICAgICAgcG9zOiBwYXJzZUludChyZXZJbmZvWzFdLCAxMCksXG4gICAgICAgIGlkczogW3JldkluZm9bMl0sIG9wdHMsIFtdXVxuICAgICAgfV07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5pbnZhbGlkSWRFcnJvcihkb2MuX2lkKTtcblxuICBkb2MuX3JldiA9IFtuUmV2TnVtLCBuZXdSZXZJZF0uam9pbignLScpO1xuXG4gIHZhciByZXN1bHQgPSB7bWV0YWRhdGEgOiB7fSwgZGF0YSA6IHt9fTtcbiAgZm9yICh2YXIga2V5IGluIGRvYykge1xuICAgIGlmIChkb2MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHNwZWNpYWxLZXkgPSBrZXlbMF0gPT09ICdfJztcbiAgICAgIGlmIChzcGVjaWFsS2V5ICYmICFyZXNlcnZlZFdvcmRzW2tleV0pIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JzLkRPQ19WQUxJREFUSU9OLm1lc3NhZ2UgKyAnOiAnICsga2V5KTtcbiAgICAgICAgZXJyb3Iuc3RhdHVzID0gZXJyb3JzLkRPQ19WQUxJREFUSU9OLnN0YXR1cztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGVsc2UgaWYgKHNwZWNpYWxLZXkgJiYgIWRhdGFXb3Jkc1trZXldKSB7XG4gICAgICAgIHJlc3VsdC5tZXRhZGF0YVtrZXkuc2xpY2UoMSldID0gZG9jW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuZGF0YVtrZXldID0gZG9jW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLmlzQ29yZG92YSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0eXBlb2YgY29yZG92YSAhPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgIHR5cGVvZiBQaG9uZUdhcCAhPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgIHR5cGVvZiBwaG9uZWdhcCAhPT0gXCJ1bmRlZmluZWRcIik7XG59O1xuXG5leHBvcnRzLmhhc0xvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGlzQ2hyb21lQXBwKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2xvYmFsLmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbmV4cG9ydHMuQ2hhbmdlcyA9IENoYW5nZXM7XG5leHBvcnRzLmluaGVyaXRzKENoYW5nZXMsIEV2ZW50RW1pdHRlcik7XG5mdW5jdGlvbiBDaGFuZ2VzKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2hhbmdlcykpIHtcbiAgICByZXR1cm4gbmV3IENoYW5nZXMoKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLmlzQ2hyb21lID0gaXNDaHJvbWVBcHAoKTtcbiAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgdGhpcy5oYXNMb2NhbCA9IGZhbHNlO1xuICBpZiAoIXRoaXMuaXNDaHJvbWUpIHtcbiAgICB0aGlzLmhhc0xvY2FsID0gZXhwb3J0cy5oYXNMb2NhbFN0b3JhZ2UoKTtcbiAgfVxuICBpZiAodGhpcy5pc0Nocm9tZSkge1xuICAgIGNocm9tZS5zdG9yYWdlLm9uQ2hhbmdlZC5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoZSkge1xuICAgICAgLy8gbWFrZSBzdXJlIGl0J3MgZXZlbnQgYWRkcmVzc2VkIHRvIHVzXG4gICAgICBpZiAoZS5kYl9uYW1lICE9IG51bGwpIHtcbiAgICAgICAgLy9vYmplY3Qgb25seSBoYXMgb2xkVmFsdWUsIG5ld1ZhbHVlIG1lbWJlcnNcbiAgICAgICAgc2VsZi5lbWl0KGUuZGJOYW1lLm5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmhhc0xvY2FsKSB7XG4gICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lbWl0KGUua2V5KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJzdG9yYWdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZW1pdChlLmtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufVxuQ2hhbmdlcy5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZGJOYW1lLCBpZCwgZGIsIG9wdHMpIHtcbiAgaWYgKHRoaXMubGlzdGVuZXJzW2lkXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBmdW5jdGlvbiBldmVudEZ1bmN0aW9uKCkge1xuICAgIGRiLmNoYW5nZXMoe1xuICAgICAgaW5jbHVkZV9kb2NzOiBvcHRzLmluY2x1ZGVfZG9jcyxcbiAgICAgIGNvbmZsaWN0czogb3B0cy5jb25mbGljdHMsXG4gICAgICBjb250aW51b3VzOiBmYWxzZSxcbiAgICAgIGRlc2NlbmRpbmc6IGZhbHNlLFxuICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgIHZpZXc6IG9wdHMudmlldyxcbiAgICAgIHNpbmNlOiBvcHRzLnNpbmNlLFxuICAgICAgcXVlcnlfcGFyYW1zOiBvcHRzLnF1ZXJ5X3BhcmFtcyxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYy5zZXEgPiBvcHRzLnNpbmNlICYmICFvcHRzLmNhbmNlbGxlZCkge1xuICAgICAgICAgIG9wdHMuc2luY2UgPSBjLnNlcTtcbiAgICAgICAgICBleHBvcnRzLmNhbGwob3B0cy5vbkNoYW5nZSwgYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aGlzLmxpc3RlbmVyc1tpZF0gPSBldmVudEZ1bmN0aW9uO1xuICB0aGlzLm9uKGRiTmFtZSwgZXZlbnRGdW5jdGlvbik7XG59O1xuXG5DaGFuZ2VzLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChkYk5hbWUsIGlkKSB7XG4gIGlmICghKGlkIGluIHRoaXMubGlzdGVuZXJzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZGJOYW1lLFxuICAgIHRoaXMubGlzdGVuZXJzW2lkXSk7XG59O1xuXG5cbkNoYW5nZXMucHJvdG90eXBlLm5vdGlmeUxvY2FsV2luZG93cyA9IGZ1bmN0aW9uIChkYk5hbWUpIHtcbiAgLy9kbyBhIHVzZWxlc3MgY2hhbmdlIG9uIGEgc3RvcmFnZSB0aGluZ1xuICAvL2luIG9yZGVyIHRvIGdldCBvdGhlciB3aW5kb3dzJ3MgbGlzdGVuZXJzIHRvIGFjdGl2YXRlXG4gIGlmICh0aGlzLmlzQ2hyb21lKSB7XG4gICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHtkYk5hbWU6IGRiTmFtZX0pO1xuICB9IGVsc2UgaWYgKHRoaXMuaGFzTG9jYWwpIHtcbiAgICBsb2NhbFN0b3JhZ2VbZGJOYW1lXSA9IChsb2NhbFN0b3JhZ2VbZGJOYW1lXSA9PT0gXCJhXCIpID8gXCJiXCIgOiBcImFcIjtcbiAgfVxufTtcblxuQ2hhbmdlcy5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGRiTmFtZSkge1xuICB0aGlzLmVtaXQoZGJOYW1lKTtcbiAgdGhpcy5ub3RpZnlMb2NhbFdpbmRvd3MoZGJOYW1lKTtcbn07XG5cbmlmICghcHJvY2Vzcy5icm93c2VyIHx8ICEoJ2F0b2InIGluIGdsb2JhbCkpIHtcbiAgZXhwb3J0cy5hdG9iID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBiYXNlNjQgPSBuZXcgYnVmZmVyKHN0ciwgJ2Jhc2U2NCcpO1xuICAgIC8vIE5vZGUuanMgd2lsbCBqdXN0IHNraXAgdGhlIGNoYXJhY3RlcnMgaXQgY2FuJ3QgZW5jb2RlIGluc3RlYWQgb2ZcbiAgICAvLyB0aHJvd2luZyBhbmQgZXhjZXB0aW9uXG4gICAgaWYgKGJhc2U2NC50b1N0cmluZygnYmFzZTY0JykgIT09IHN0cikge1xuICAgICAgdGhyb3cgKFwiQ2Fubm90IGJhc2U2NCBlbmNvZGUgZnVsbCBzdHJpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQudG9TdHJpbmcoJ2JpbmFyeScpO1xuICB9O1xufSBlbHNlIHtcbiAgZXhwb3J0cy5hdG9iID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBhdG9iKHN0cik7XG4gIH07XG59XG5cbmlmICghcHJvY2Vzcy5icm93c2VyIHx8ICEoJ2J0b2EnIGluIGdsb2JhbCkpIHtcbiAgZXhwb3J0cy5idG9hID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgYnVmZmVyKHN0ciwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfTtcbn0gZWxzZSB7XG4gIGV4cG9ydHMuYnRvYSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gYnRvYShzdHIpO1xuICB9O1xufVxuXG4vLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ5Njc2NDcvIChjb250aW51ZXMgb24gbmV4dCBsaW5lKVxuLy8gZW5jb2RlLWRlY29kZS1pbWFnZS13aXRoLWJhc2U2NC1icmVha3MtaW1hZ2UgKDIwMTMtMDQtMjEpXG5leHBvcnRzLmZpeEJpbmFyeSA9IGZ1bmN0aW9uIChiaW4pIHtcbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICAvLyBkb24ndCBuZWVkIHRvIGRvIHRoaXMgaW4gTm9kZVxuICAgIHJldHVybiBiaW47XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYmluLmxlbmd0aDtcbiAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBzaGltIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXRcbmV4cG9ydHMucmVhZEFzQmluYXJ5U3RyaW5nID0gZnVuY3Rpb24gKGJsb2IsIGNhbGxiYWNrKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICB2YXIgaGFzQmluYXJ5U3RyaW5nID0gdHlwZW9mIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcgPT09ICdmdW5jdGlvbic7XG4gIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciByZXN1bHQgPSBlLnRhcmdldC5yZXN1bHQgfHwgJyc7XG4gICAgaWYgKGhhc0JpbmFyeVN0cmluZykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfVxuICAgIGNhbGxiYWNrKGV4cG9ydHMuYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhyZXN1bHQpKTtcbiAgfTtcbiAgaWYgKGhhc0JpbmFyeVN0cmluZykge1xuICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoYmxvYik7XG4gIH0gZWxzZSB7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICB9XG59O1xuXG5leHBvcnRzLm9uY2UgPSBmdW5jdGlvbiAoZnVuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGV4cG9ydHMuZ2V0QXJndW1lbnRzKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmNlIGNhbGxlZCAgbW9yZSB0aGFuIG9uY2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZ1bi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0cy50b1Byb21pc2UgPSBmdW5jdGlvbiAoZnVuYykge1xuICAvL2NyZWF0ZSB0aGUgZnVuY3Rpb24gd2Ugd2lsbCBiZSByZXR1cm5pbmdcbiAgcmV0dXJuIGV4cG9ydHMuZ2V0QXJndW1lbnRzKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0ZW1wQ0IgPVxuICAgICAgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpID8gYXJncy5wb3AoKSA6IGZhbHNlO1xuICAgIC8vIGlmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIGFzc3VtZSBpdHMgYSBjYWxsYmFja1xuICAgIHZhciB1c2VkQ0I7XG4gICAgaWYgKHRlbXBDQikge1xuICAgICAgLy8gaWYgaXQgd2FzIGEgY2FsbGJhY2ssIGNyZWF0ZSBhIG5ldyBjYWxsYmFjayB3aGljaCBjYWxscyBpdCxcbiAgICAgIC8vIGJ1dCBkbyBzbyBhc3luYyBzbyB3ZSBkb24ndCB0cmFwIGFueSBlcnJvcnNcbiAgICAgIHVzZWRDQiA9IGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGVtcENCKGVyciwgcmVzcCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVzcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGV4cG9ydHMub25jZShmdW5jdGlvbiAoZXJyLCBtZXNnKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGZpbGwobWVzZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY3JlYXRlIGEgY2FsbGJhY2sgZm9yIHRoaXMgaW52b2NhdGlvblxuICAgICAgICAvLyBhcHBseSB0aGUgZnVuY3Rpb24gaW4gdGhlIG9yaWcgY29udGV4dFxuICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXNwID0gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlc3AgJiYgdHlwZW9mIHJlc3AudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZ1bGZpbGwocmVzcCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIHRoZXJlIGlzIGEgY2FsbGJhY2ssIGNhbGwgaXQgYmFja1xuICAgIGlmICh1c2VkQ0IpIHtcbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHVzZWRDQihudWxsLCByZXN1bHQpO1xuICAgICAgfSwgdXNlZENCKTtcbiAgICB9XG4gICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuYWRhcHRlckZ1biA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICByZXR1cm4gZXhwb3J0cy50b1Byb21pc2UoZXhwb3J0cy5nZXRBcmd1bWVudHMoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdkYXRhYmFzZSBpcyBjbG9zZWQnKSk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIXRoaXMudGFza3F1ZXVlLmlzUmVhZHkpIHtcbiAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi50YXNrcXVldWUuYWRkVGFzayhmdW5jdGlvbiAoZmFpbGVkKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkge1xuICAgICAgICAgICAgcmVqZWN0KGZhaWxlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGZpbGwoc2VsZltuYW1lXS5hcHBseShzZWxmLCBhcmdzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH0pKTtcbn07XG4vL0Nhbid0IGZpbmQgb3JpZ2luYWwgcG9zdCwgYnV0IHRoaXMgaXMgY2xvc2Vcbi8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82OTY1MTA3LyAoY29udGludWVzIG9uIG5leHQgbGluZSlcbi8vY29udmVydGluZy1iZXR3ZWVuLXN0cmluZ3MtYW5kLWFycmF5YnVmZmVyc1xuZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB2YXIgYmluYXJ5ID0gXCJcIjtcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgdmFyIGxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGJpbmFyeTtcbn07XG5cbmV4cG9ydHMuY2FuY2VsbGFibGVGdW4gPSBmdW5jdGlvbiAoZnVuLCBzZWxmLCBvcHRzKSB7XG5cbiAgb3B0cyA9IG9wdHMgPyBleHBvcnRzLmNsb25lKHRydWUsIHt9LCBvcHRzKSA6IHt9O1xuXG4gIHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICB2YXIgb2xkQ29tcGxldGUgPSBvcHRzLmNvbXBsZXRlIHx8IGZ1bmN0aW9uICgpIHsgfTtcbiAgdmFyIGNvbXBsZXRlID0gb3B0cy5jb21wbGV0ZSA9IGV4cG9ydHMub25jZShmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgb2xkQ29tcGxldGUoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5lbWl0KCdlbmQnLCByZXNwKTtcbiAgICAgIG9sZENvbXBsZXRlKG51bGwsIHJlc3ApO1xuICAgIH1cbiAgICBlbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbiAgdmFyIG9sZE9uQ2hhbmdlID0gb3B0cy5vbkNoYW5nZSB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgdmFyIGxhc3RDaGFuZ2UgPSAwO1xuICBzZWxmLm9uKCdkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG4gIG9wdHMub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgb2xkT25DaGFuZ2UoY2hhbmdlKTtcbiAgICBpZiAoY2hhbmdlLnNlcSA8PSBsYXN0Q2hhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RDaGFuZ2UgPSBjaGFuZ2Uuc2VxO1xuICAgIGVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgY2hhbmdlKTtcbiAgICBpZiAoY2hhbmdlLmRlbGV0ZWQpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdCgnZGVsZXRlJywgY2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5jaGFuZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgY2hhbmdlLmNoYW5nZXNbMF0ucmV2LnNsaWNlKDAsIDEpID09PSAnMS0nKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoJ2NyZWF0ZScsIGNoYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcbiAgICB9XG4gIH07XG4gIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xuICAgIG9wdHMuY29tcGxldGUgPSBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHJlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBjb21wbGV0ZShudWxsLCByZXN1bHQpO1xuICB9LCBjb21wbGV0ZSk7XG5cbiAgLy8gdGhpcyBuZWVkcyB0byBiZSBvdmVyd3JpZGRlbiBieSBjYWxsZXIsIGRvbnQgZmlyZSBjb21wbGV0ZSB1bnRpbFxuICAvLyB0aGUgdGFzayBpcyByZWFkeVxuICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9taXNlLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBpZiAoc2VsZi50YXNrcXVldWUuaXNSZWFkeSkge1xuICAgICAgb3B0cy5jb21wbGV0ZShudWxsLCB7c3RhdHVzOiAnY2FuY2VsbGVkJ30pO1xuICAgIH1cbiAgfTtcblxuICBpZiAoIXNlbGYudGFza3F1ZXVlLmlzUmVhZHkpIHtcbiAgICBzZWxmLnRhc2txdWV1ZS5hZGRUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9taXNlLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgIG9wdHMuY29tcGxldGUobnVsbCwge3N0YXR1czogJ2NhbmNlbGxlZCd9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bihzZWxmLCBvcHRzLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmdW4oc2VsZiwgb3B0cywgcHJvbWlzZSk7XG4gIH1cbiAgcHJvbWlzZS5vbiA9IGVtaXR0ZXIub24uYmluZChlbWl0dGVyKTtcbiAgcHJvbWlzZS5vbmNlID0gZW1pdHRlci5vbmNlLmJpbmQoZW1pdHRlcik7XG4gIHByb21pc2UuYWRkTGlzdGVuZXIgPSBlbWl0dGVyLmFkZExpc3RlbmVyLmJpbmQoZW1pdHRlcik7XG4gIHByb21pc2UucmVtb3ZlTGlzdGVuZXIgPSBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyLmJpbmQoZW1pdHRlcik7XG4gIHByb21pc2UucmVtb3ZlQWxsTGlzdGVuZXJzID0gZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMuYmluZChlbWl0dGVyKTtcbiAgcHJvbWlzZS5zZXRNYXhMaXN0ZW5lcnMgPSBlbWl0dGVyLnNldE1heExpc3RlbmVycy5iaW5kKGVtaXR0ZXIpO1xuICBwcm9taXNlLmxpc3RlbmVycyA9IGVtaXR0ZXIubGlzdGVuZXJzLmJpbmQoZW1pdHRlcik7XG4gIHByb21pc2UuZW1pdCA9IGVtaXR0ZXIuZW1pdC5iaW5kKGVtaXR0ZXIpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbmV4cG9ydHMuTUQ1ID0gZXhwb3J0cy50b1Byb21pc2UoX2RlcmVxXygnLi9kZXBzL21kNScpKTtcblxuLy8gZGVzaWduZWQgdG8gZ2l2ZSBpbmZvIHRvIGJyb3dzZXIgdXNlcnMsIHdobyBhcmUgZGlzdHVyYmVkXG4vLyB3aGVuIHRoZXkgc2VlIDQwNHMgaW4gdGhlIGNvbnNvbGVcbmV4cG9ydHMuZXhwbGFpbjQwNCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHByb2Nlc3MuYnJvd3NlciAmJiAnY29uc29sZScgaW4gZ2xvYmFsICYmICdpbmZvJyBpbiBjb25zb2xlKSB7XG4gICAgY29uc29sZS5pbmZvKCdUaGUgYWJvdmUgNDA0IGlzIHRvdGFsbHkgbm9ybWFsLiAnICtcbiAgICAgIHN0ciArICdcXG5cXHUyNjY1IHRoZSBQb3VjaERCIHRlYW0nKTtcbiAgfVxufTtcblxuZXhwb3J0cy5wYXJzZVVyaSA9IF9kZXJlcV8oJy4vZGVwcy9wYXJzZS11cmknKTtcblxuZXhwb3J0cy5jb21wYXJlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0IDwgcmlnaHQgPyAtMSA6IGxlZnQgPiByaWdodCA/IDEgOiAwO1xufTtcbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL1VzZXJzL2RhbGVoYXJ2ZXkvc3JjL3BvdWNoZGIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9kZXBzL2FqYXhcIjo5LFwiLi9kZXBzL2Jsb2JcIjoxMCxcIi4vZGVwcy9idWZmZXJcIjoyOSxcIi4vZGVwcy9jb2xsZWN0aW9uc1wiOjExLFwiLi9kZXBzL2Vycm9yc1wiOjEyLFwiLi9kZXBzL21kNVwiOjEzLFwiLi9kZXBzL3BhcnNlLXVyaVwiOjE1LFwiLi9kZXBzL3V1aWRcIjoxNyxcIi4vbWVyZ2VcIjoyMSxcIi9Vc2Vycy9kYWxlaGFydmV5L3NyYy9wb3VjaGRiL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjMxLFwiYXJnc2FycmF5XCI6MjgsXCJibHVlYmlyZFwiOjM2LFwiZXZlbnRzXCI6MzAsXCJpbmhlcml0c1wiOjMyLFwicG91Y2hkYi1leHRlbmRcIjo1MX1dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gXCIzLjEuMFwiO1xuXG59LHt9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYXJnc0FycmF5O1xuXG5mdW5jdGlvbiBhcmdzQXJyYXkoZnVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbikge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIHZhciBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuLmNhbGwodGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW4uY2FsbCh0aGlzLCBbXSk7XG4gICAgfVxuICB9O1xufVxufSx7fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG59LHt9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cbn0se31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxufSx7fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBJTlRFUk5BTDtcblxuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxufSx7fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIFByb21pc2UgPSBfZGVyZXFfKCcuL3Byb21pc2UnKTtcbnZhciByZWplY3QgPSBfZGVyZXFfKCcuL3JlamVjdCcpO1xudmFyIHJlc29sdmUgPSBfZGVyZXFfKCcuL3Jlc29sdmUnKTtcbnZhciBJTlRFUk5BTCA9IF9kZXJlcV8oJy4vSU5URVJOQUwnKTtcbnZhciBoYW5kbGVycyA9IF9kZXJlcV8oJy4vaGFuZGxlcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gYWxsO1xuZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiByZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIHJlc29sdmVkID0gMDtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gIFxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZUZyb21BbGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiByZXNvbHZlRnJvbUFsbChvdXRWYWx1ZSkge1xuICAgICAgdmFsdWVzW2ldID0gb3V0VmFsdWU7XG4gICAgICBpZiAoKytyZXNvbHZlZCA9PT0gbGVuICYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG59LHtcIi4vSU5URVJOQUxcIjozMyxcIi4vaGFuZGxlcnNcIjozNSxcIi4vcHJvbWlzZVwiOjM3LFwiLi9yZWplY3RcIjo0MCxcIi4vcmVzb2x2ZVwiOjQxfV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIHRyeUNhdGNoID0gX2RlcmVxXygnLi90cnlDYXRjaCcpO1xudmFyIHJlc29sdmVUaGVuYWJsZSA9IF9kZXJlcV8oJy4vcmVzb2x2ZVRoZW5hYmxlJyk7XG52YXIgc3RhdGVzID0gX2RlcmVxXygnLi9zdGF0ZXMnKTtcblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmVqZWN0KHNlbGYsIHJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgdmFyIHRoZW5hYmxlID0gcmVzdWx0LnZhbHVlO1xuXG4gIGlmICh0aGVuYWJsZSkge1xuICAgIHJlc29sdmVUaGVuYWJsZS5zYWZlbHkoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBzdGF0ZXMuRlVMRklMTEVEO1xuICAgIHNlbGYub3V0Y29tZSA9IHZhbHVlO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIHNlbGYucXVldWVbaV0uY2FsbEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcbmV4cG9ydHMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBzdGF0ZXMuUkVKRUNURUQ7XG4gIHNlbGYub3V0Y29tZSA9IGVycm9yO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBzZWxmLnF1ZXVlW2ldLmNhbGxSZWplY3RlZChlcnJvcik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAvLyBNYWtlIHN1cmUgd2Ugb25seSBhY2Nlc3MgdGhlIGFjY2Vzc29yIG9uY2UgYXMgcmVxdWlyZWQgYnkgdGhlIHNwZWNcbiAgdmFyIHRoZW4gPSBvYmogJiYgb2JqLnRoZW47XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG59LHtcIi4vcmVzb2x2ZVRoZW5hYmxlXCI6NDIsXCIuL3N0YXRlc1wiOjQzLFwiLi90cnlDYXRjaFwiOjQ0fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gX2RlcmVxXygnLi9wcm9taXNlJyk7XG5cbmV4cG9ydHMucmVzb2x2ZSA9IF9kZXJlcV8oJy4vcmVzb2x2ZScpO1xuZXhwb3J0cy5yZWplY3QgPSBfZGVyZXFfKCcuL3JlamVjdCcpO1xuZXhwb3J0cy5hbGwgPSBfZGVyZXFfKCcuL2FsbCcpO1xuZXhwb3J0cy5yYWNlID0gX2RlcmVxXygnLi9yYWNlJyk7XG59LHtcIi4vYWxsXCI6MzQsXCIuL3Byb21pc2VcIjozNyxcIi4vcmFjZVwiOjM5LFwiLi9yZWplY3RcIjo0MCxcIi4vcmVzb2x2ZVwiOjQxfV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW53cmFwID0gX2RlcmVxXygnLi91bndyYXAnKTtcbnZhciBJTlRFUk5BTCA9IF9kZXJlcV8oJy4vSU5URVJOQUwnKTtcbnZhciByZXNvbHZlVGhlbmFibGUgPSBfZGVyZXFfKCcuL3Jlc29sdmVUaGVuYWJsZScpO1xudmFyIHN0YXRlcyA9IF9kZXJlcV8oJy4vc3RhdGVzJyk7XG52YXIgUXVldWVJdGVtID0gX2RlcmVxXygnLi9xdWV1ZUl0ZW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZXIpO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNsb3ZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gc3RhdGVzLlBFTkRJTkc7XG4gIHRoaXMucXVldWUgPSBbXTtcbiAgdGhpcy5vdXRjb21lID0gdm9pZCAwO1xuICBpZiAocmVzb2x2ZXIgIT09IElOVEVSTkFMKSB7XG4gICAgcmVzb2x2ZVRoZW5hYmxlLnNhZmVseSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBzdGF0ZXMuRlVMRklMTEVEIHx8XG4gICAgdHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdGF0ZSA9PT0gc3RhdGVzLlJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG5cbiAgXG4gIGlmICh0aGlzLnN0YXRlICE9PSBzdGF0ZXMuUEVORElORykge1xuICAgIHZhciByZXNvbHZlciA9IHRoaXMuc3RhdGUgPT09IHN0YXRlcy5GVUxGSUxMRUQgPyBvbkZ1bGZpbGxlZDogb25SZWplY3RlZDtcbiAgICB1bndyYXAocHJvbWlzZSwgcmVzb2x2ZXIsIHRoaXMub3V0Y29tZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxufSx7XCIuL0lOVEVSTkFMXCI6MzMsXCIuL3F1ZXVlSXRlbVwiOjM4LFwiLi9yZXNvbHZlVGhlbmFibGVcIjo0MixcIi4vc3RhdGVzXCI6NDMsXCIuL3Vud3JhcFwiOjQ1fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIGhhbmRsZXJzID0gX2RlcmVxXygnLi9oYW5kbGVycycpO1xudmFyIHVud3JhcCA9IF9kZXJlcV8oJy4vdW53cmFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWVJdGVtO1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG59LHtcIi4vaGFuZGxlcnNcIjozNSxcIi4vdW53cmFwXCI6NDV9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG52YXIgUHJvbWlzZSA9IF9kZXJlcV8oJy4vcHJvbWlzZScpO1xudmFyIHJlamVjdCA9IF9kZXJlcV8oJy4vcmVqZWN0Jyk7XG52YXIgcmVzb2x2ZSA9IF9kZXJlcV8oJy4vcmVzb2x2ZScpO1xudmFyIElOVEVSTkFMID0gX2RlcmVxXygnLi9JTlRFUk5BTCcpO1xudmFyIGhhbmRsZXJzID0gX2RlcmVxXygnLi9oYW5kbGVycycpO1xubW9kdWxlLmV4cG9ydHMgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gcmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxufSx7XCIuL0lOVEVSTkFMXCI6MzMsXCIuL2hhbmRsZXJzXCI6MzUsXCIuL3Byb21pc2VcIjozNyxcIi4vcmVqZWN0XCI6NDAsXCIuL3Jlc29sdmVcIjo0MX1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSBfZGVyZXFfKCcuL3Byb21pc2UnKTtcbnZhciBJTlRFUk5BTCA9IF9kZXJlcV8oJy4vSU5URVJOQUwnKTtcbnZhciBoYW5kbGVycyA9IF9kZXJlcV8oJy4vaGFuZGxlcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVqZWN0O1xuXG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG5cdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuXHRyZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG59XG59LHtcIi4vSU5URVJOQUxcIjozMyxcIi4vaGFuZGxlcnNcIjozNSxcIi4vcHJvbWlzZVwiOjM3fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IF9kZXJlcV8oJy4vcHJvbWlzZScpO1xudmFyIElOVEVSTkFMID0gX2RlcmVxXygnLi9JTlRFUk5BTCcpO1xudmFyIGhhbmRsZXJzID0gX2RlcmVxXygnLi9oYW5kbGVycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlO1xuXG52YXIgRkFMU0UgPSBoYW5kbGVycy5yZXNvbHZlKG5ldyBQcm9taXNlKElOVEVSTkFMKSwgZmFsc2UpO1xudmFyIE5VTEwgPSBoYW5kbGVycy5yZXNvbHZlKG5ldyBQcm9taXNlKElOVEVSTkFMKSwgbnVsbCk7XG52YXIgVU5ERUZJTkVEID0gaGFuZGxlcnMucmVzb2x2ZShuZXcgUHJvbWlzZShJTlRFUk5BTCksIHZvaWQgMCk7XG52YXIgWkVSTyA9IGhhbmRsZXJzLnJlc29sdmUobmV3IFByb21pc2UoSU5URVJOQUwpLCAwKTtcbnZhciBFTVBUWVNUUklORyA9IGhhbmRsZXJzLnJlc29sdmUobmV3IFByb21pc2UoSU5URVJOQUwpLCAnJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcnMucmVzb2x2ZShuZXcgUHJvbWlzZShJTlRFUk5BTCksIHZhbHVlKTtcbiAgfVxuICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuICBzd2l0Y2ggKHZhbHVlVHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEZBTFNFO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gVU5ERUZJTkVEO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gTlVMTDtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIFpFUk87XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBFTVBUWVNUUklORztcbiAgfVxufVxufSx7XCIuL0lOVEVSTkFMXCI6MzMsXCIuL2hhbmRsZXJzXCI6MzUsXCIuL3Byb21pc2VcIjozN31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBoYW5kbGVycyA9IF9kZXJlcV8oJy4vaGFuZGxlcnMnKTtcbnZhciB0cnlDYXRjaCA9IF9kZXJlcV8oJy4vdHJ5Q2F0Y2gnKTtcbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuICBcbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRyeVRvVW53cmFwKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICBvbkVycm9yKHJlc3VsdC52YWx1ZSk7XG4gIH1cbn1cbmV4cG9ydHMuc2FmZWx5ID0gc2FmZWx5UmVzb2x2ZVRoZW5hYmxlO1xufSx7XCIuL2hhbmRsZXJzXCI6MzUsXCIuL3RyeUNhdGNoXCI6NDR9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBMYXp5IG1hbidzIHN5bWJvbHMgZm9yIHN0YXRlc1xuXG5leHBvcnRzLlJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xuZXhwb3J0cy5GVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xuZXhwb3J0cy5QRU5ESU5HID0gWydQRU5ESU5HJ107XG59LHt9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJ5Q2F0Y2g7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxufSx7fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1tZWRpYXRlID0gX2RlcmVxXygnaW1tZWRpYXRlJyk7XG52YXIgaGFuZGxlcnMgPSBfZGVyZXFfKCcuL2hhbmRsZXJzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHVud3JhcDtcblxuZnVuY3Rpb24gdW53cmFwKHByb21pc2UsIGZ1bmMsIHZhbHVlKSB7XG4gIGltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZSk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gcHJvbWlzZSkge1xuICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG59LHtcIi4vaGFuZGxlcnNcIjozNSxcImltbWVkaWF0ZVwiOjQ2fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIHR5cGVzID0gW1xuICBfZGVyZXFfKCcuL25leHRUaWNrJyksXG4gIF9kZXJlcV8oJy4vbXV0YXRpb24uanMnKSxcbiAgX2RlcmVxXygnLi9tZXNzYWdlQ2hhbm5lbCcpLFxuICBfZGVyZXFfKCcuL3N0YXRlQ2hhbmdlJyksXG4gIF9kZXJlcV8oJy4vdGltZW91dCcpXG5dO1xudmFyIGRyYWluaW5nO1xudmFyIHF1ZXVlID0gW107XG4vL25hbWVkIG5leHRUaWNrIGZvciBsZXNzIGNvbmZ1c2luZyBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIG5leHRUaWNrKCkge1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBpLCBvbGRRdWV1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGxlbikge1xuICAgIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgb2xkUXVldWVbaV0oKTtcbiAgICB9XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG4gIGRyYWluaW5nID0gZmFsc2U7XG59XG52YXIgc2NoZWR1bGVEcmFpbjtcbnZhciBpID0gLTE7XG52YXIgbGVuID0gdHlwZXMubGVuZ3RoO1xud2hpbGUgKCsrIGkgPCBsZW4pIHtcbiAgaWYgKHR5cGVzW2ldICYmIHR5cGVzW2ldLnRlc3QgJiYgdHlwZXNbaV0udGVzdCgpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IHR5cGVzW2ldLmluc3RhbGwobmV4dFRpY2spO1xuICAgIGJyZWFrO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGltbWVkaWF0ZTtcbmZ1bmN0aW9uIGltbWVkaWF0ZSh0YXNrKSB7XG4gIGlmIChxdWV1ZS5wdXNoKHRhc2spID09PSAxICYmICFkcmFpbmluZykge1xuICAgIHNjaGVkdWxlRHJhaW4oKTtcbiAgfVxufVxufSx7XCIuL21lc3NhZ2VDaGFubmVsXCI6NDcsXCIuL211dGF0aW9uLmpzXCI6NDgsXCIuL25leHRUaWNrXCI6MjksXCIuL3N0YXRlQ2hhbmdlXCI6NDksXCIuL3RpbWVvdXRcIjo1MH1dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy50ZXN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgIC8vIHdlIGNhbiBvbmx5IGdldCBoZXJlIGluIElFMTBcbiAgICAvLyB3aGljaCBkb2Vzbid0IGhhbmRlbCBwb3N0TWVzc2FnZSB3ZWxsXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcbn07XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn07XG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuLy9iYXNlZCBvZmYgcnN2cCBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzXG4vL2xpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9tYXN0ZXIvbGliL3JzdnAvYXNhcC5qc1xuXG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxuZXhwb3J0cy50ZXN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTXV0YXRpb247XG59O1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb24oaGFuZGxlKTtcbiAgdmFyIGVsZW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICB9O1xufTtcbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbn07XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZSgpO1xuXG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH07XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQodCwgMCk7XG4gIH07XG59O1xufSx7fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEV4dGVuZHMgbWV0aG9kXG4vLyAodGFrZW4gZnJvbSBodHRwOi8vY29kZS5qcXVlcnkuY29tL2pxdWVyeS0xLjkuMC5qcylcbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHR5cGVzID0gW1xuICBcIkJvb2xlYW5cIiwgXCJOdW1iZXJcIiwgXCJTdHJpbmdcIiwgXCJGdW5jdGlvblwiLCBcIkFycmF5XCIsXG4gIFwiRGF0ZVwiLCBcIlJlZ0V4cFwiLCBcIk9iamVjdFwiLCBcIkVycm9yXCJcbl07XG5mb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciB0eXBlbmFtZSA9IHR5cGVzW2ldO1xuICBjbGFzczJ0eXBlW1wiW29iamVjdCBcIiArIHR5cGVuYW1lICsgXCJdXCJdID0gdHlwZW5hbWUudG9Mb3dlckNhc2UoKTtcbn1cblxudmFyIGNvcmVfdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xudmFyIGNvcmVfaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdHlwZShvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuICAgIGNsYXNzMnR5cGVbY29yZV90b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCIgOlxuICAgIHR5cGVvZiBvYmo7XG59XG5cbmZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgLy8gTXVzdCBiZSBhbiBPYmplY3QuXG4gIC8vIEJlY2F1c2Ugb2YgSUUsIHdlIGFsc28gaGF2ZSB0byBjaGVjayB0aGUgcHJlc2VuY2Ugb2ZcbiAgLy8gdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuICAvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbFxuICBpZiAoIW9iaiB8fCB0eXBlKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGlzV2luZG93KG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3RcbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICAhY29yZV9oYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcbiAgICAgICFjb3JlX2hhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoIGUgKSB7XG4gICAgLy8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG4gIC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvYmopIHt9XG5cbiAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGNvcmVfaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xufTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAvLyBvcmlnaW5hbGx5IGV4dGVuZCgpIHdhcyByZWN1cnNpdmUsIGJ1dCB0aGlzIGVuZGVkIHVwIGdpdmluZyB1c1xuICAvLyBcImNhbGwgc3RhY2sgZXhjZWVkZWRcIiwgc28gaXQncyBiZWVuIHVucm9sbGVkIHRvIHVzZSBhIGxpdGVyYWwgc3RhY2tcbiAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2lzc3Vlcy8yNTQzKVxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICB9XG4gIHZhciBjb250YWluZXIgPSB7fTtcbiAgc3RhY2sucHVzaCh7YXJnczogYXJncywgcmVzdWx0OiB7Y29udGFpbmVyOiBjb250YWluZXIsIGtleTogJ2tleSd9fSk7XG4gIHZhciBuZXh0O1xuICB3aGlsZSAoKG5leHQgPSBzdGFjay5wb3AoKSkpIHtcbiAgICBleHRlbmRJbm5lcihzdGFjaywgbmV4dC5hcmdzLCBuZXh0LnJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lci5rZXk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZElubmVyKHN0YWNrLCBhcmdzLCByZXN1bHQpIHtcbiAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuICAgIHRhcmdldCA9IGFyZ3NbMF0gfHwge30sXG4gICAgaSA9IDEsXG4gICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgZGVlcCA9IGZhbHNlLFxuICAgIG51bWVyaWNTdHJpbmdSZWdleCA9IC9cXGQrLyxcbiAgICBvcHRpb25zSXNBcnJheTtcblxuICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIikge1xuICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gYXJnc1sxXSB8fCB7fTtcbiAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgaSA9IDI7XG4gIH1cblxuICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHRhcmdldCA9IHt9O1xuICB9XG5cbiAgLy8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gIGlmIChsZW5ndGggPT09IGkpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgdGFyZ2V0ID0gdGhpcztcbiAgICAtLWk7XG4gIH1cblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgIGlmICgob3B0aW9ucyA9IGFyZ3NbaV0pICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnNJc0FycmF5ID0gaXNBcnJheShvcHRpb25zKTtcbiAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIC8vaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgICAgICAgIGlmIChvcHRpb25zSXNBcnJheSAmJiAhbnVtZXJpY1N0cmluZ1JlZ2V4LnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNyYyA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblxuICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjb3B5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChpc1BsYWluT2JqZWN0KGNvcHkpIHx8XG4gICAgICAgICAgICAgIChjb3B5SXNBcnJheSA9IGlzQXJyYXkoY29weSkpKSkge1xuICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KSB7XG4gICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgYXJnczogW2RlZXAsIGNsb25lLCBjb3B5XSxcbiAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAga2V5OiBuYW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIShpc0FycmF5KG9wdGlvbnMpICYmIGlzRnVuY3Rpb24oY29weSkpKSB7XG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gXCJSZXR1cm5cIiB0aGUgbW9kaWZpZWQgb2JqZWN0IGJ5IHNldHRpbmcgdGhlIGtleVxuICAvLyBvbiB0aGUgZ2l2ZW4gY29udGFpbmVyXG4gIHJlc3VsdC5jb250YWluZXJbcmVzdWx0LmtleV0gPSB0YXJnZXQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5cblxuXG59LHt9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cHNlcnQgPSBfZGVyZXFfKCcuL3Vwc2VydCcpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xudmFyIFByb21pc2UgPSB1dGlscy5Qcm9taXNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzb3VyY2VEQiA9IG9wdHMuZGI7XG4gIHZhciB2aWV3TmFtZSA9IG9wdHMudmlld05hbWU7XG4gIHZhciBtYXBGdW4gPSBvcHRzLm1hcDtcbiAgdmFyIHJlZHVjZUZ1biA9IG9wdHMucmVkdWNlO1xuICB2YXIgdGVtcG9yYXJ5ID0gb3B0cy50ZW1wb3Jhcnk7XG5cbiAgLy8gdGhlIFwidW5kZWZpbmVkXCIgcGFydCBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgdmFyIHZpZXdTaWduYXR1cmUgPSBtYXBGdW4udG9TdHJpbmcoKSArIChyZWR1Y2VGdW4gJiYgcmVkdWNlRnVuLnRvU3RyaW5nKCkpICtcbiAgICAndW5kZWZpbmVkJztcblxuICBpZiAoIXRlbXBvcmFyeSAmJiBzb3VyY2VEQi5fY2FjaGVkVmlld3MpIHtcbiAgICB2YXIgY2FjaGVkVmlldyA9IHNvdXJjZURCLl9jYWNoZWRWaWV3c1t2aWV3U2lnbmF0dXJlXTtcbiAgICBpZiAoY2FjaGVkVmlldykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWRWaWV3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc291cmNlREIuaW5mbygpLnRoZW4oZnVuY3Rpb24gKGluZm8pIHtcblxuICAgIHZhciBkZXBEYk5hbWUgPSBpbmZvLmRiX25hbWUgKyAnLW1ydmlldy0nICtcbiAgICAgICh0ZW1wb3JhcnkgPyAndGVtcCcgOiB1dGlscy5NRDUodmlld1NpZ25hdHVyZSkpO1xuXG4gICAgLy8gc2F2ZSB0aGUgdmlldyBuYW1lIGluIHRoZSBzb3VyY2UgUG91Y2hEQiBzbyBpdCBjYW4gYmUgY2xlYW5lZCB1cCBpZiBuZWNlc3NhcnlcbiAgICAvLyAoZS5nLiB3aGVuIHRoZSBfZGVzaWduIGRvYyBpcyBkZWxldGVkLCByZW1vdmUgYWxsIGFzc29jaWF0ZWQgdmlldyBkYXRhKVxuICAgIGZ1bmN0aW9uIGRpZmZGdW5jdGlvbihkb2MpIHtcbiAgICAgIGRvYy52aWV3cyA9IGRvYy52aWV3cyB8fCB7fTtcbiAgICAgIHZhciBmdWxsVmlld05hbWUgPSB2aWV3TmFtZTtcbiAgICAgIGlmIChmdWxsVmlld05hbWUuaW5kZXhPZignLycpID09PSAtMSkge1xuICAgICAgICBmdWxsVmlld05hbWUgPSB2aWV3TmFtZSArICcvJyArIHZpZXdOYW1lO1xuICAgICAgfVxuICAgICAgdmFyIGRlcERicyA9IGRvYy52aWV3c1tmdWxsVmlld05hbWVdID0gZG9jLnZpZXdzW2Z1bGxWaWV3TmFtZV0gfHwge307XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChkZXBEYnNbZGVwRGJOYW1lXSkge1xuICAgICAgICByZXR1cm47IC8vIG5vIHVwZGF0ZSBuZWNlc3NhcnlcbiAgICAgIH1cbiAgICAgIGRlcERic1tkZXBEYk5hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIHJldHVybiB1cHNlcnQoc291cmNlREIsICdfbG9jYWwvbXJ2aWV3cycsIGRpZmZGdW5jdGlvbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc291cmNlREIucmVnaXN0ZXJEZXBlbmRlbnREYXRhYmFzZShkZXBEYk5hbWUpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2YXIgZGIgPSByZXMuZGI7XG4gICAgICAgIGRiLmF1dG9fY29tcGFjdGlvbiA9IHRydWU7XG4gICAgICAgIHZhciB2aWV3ID0ge1xuICAgICAgICAgIG5hbWU6IGRlcERiTmFtZSxcbiAgICAgICAgICBkYjogZGIsIFxuICAgICAgICAgIHNvdXJjZURCOiBzb3VyY2VEQixcbiAgICAgICAgICBhZGFwdGVyOiBzb3VyY2VEQi5hZGFwdGVyLFxuICAgICAgICAgIG1hcEZ1bjogbWFwRnVuLFxuICAgICAgICAgIHJlZHVjZUZ1bjogcmVkdWNlRnVuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2aWV3LmRiLmdldCgnX2xvY2FsL2xhc3RTZXEnKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoZXJyLnN0YXR1cyAhPT0gNDA0KSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChsYXN0U2VxRG9jKSB7XG4gICAgICAgICAgdmlldy5zZXEgPSBsYXN0U2VxRG9jID8gbGFzdFNlcURvYy5zZXEgOiAwO1xuICAgICAgICAgIGlmICghdGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICBzb3VyY2VEQi5fY2FjaGVkVmlld3MgPSBzb3VyY2VEQi5fY2FjaGVkVmlld3MgfHwge307XG4gICAgICAgICAgICBzb3VyY2VEQi5fY2FjaGVkVmlld3Nbdmlld1NpZ25hdHVyZV0gPSB2aWV3O1xuICAgICAgICAgICAgdmlldy5kYi5vbignZGVzdHJveWVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWxldGUgc291cmNlREIuX2NhY2hlZFZpZXdzW3ZpZXdTaWduYXR1cmVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbn0se1wiLi91cHNlcnRcIjo1OCxcIi4vdXRpbHNcIjo1OX1dLDUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnVuYywgZW1pdCwgc3VtLCBsb2csIGlzQXJyYXksIHRvSlNPTikge1xuICAvKmpzaGludCBldmlsOnRydWUsdW51c2VkOmZhbHNlICovXG4gIHJldHVybiBldmFsKFwiJ3VzZSBzdHJpY3QnOyAoXCIgKyBmdW5jLnJlcGxhY2UoLztcXHMqJC8sIFwiXCIpICsgXCIpO1wiKTtcbn07XG5cbn0se31dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBwb3VjaENvbGxhdGUgPSBfZGVyZXFfKCdwb3VjaGRiLWNvbGxhdGUnKTtcbnZhciBUYXNrUXVldWUgPSBfZGVyZXFfKCcuL3Rhc2txdWV1ZScpO1xudmFyIGNvbGxhdGUgPSBwb3VjaENvbGxhdGUuY29sbGF0ZTtcbnZhciB0b0luZGV4YWJsZVN0cmluZyA9IHBvdWNoQ29sbGF0ZS50b0luZGV4YWJsZVN0cmluZztcbnZhciBub3JtYWxpemVLZXkgPSBwb3VjaENvbGxhdGUubm9ybWFsaXplS2V5O1xudmFyIGNyZWF0ZVZpZXcgPSBfZGVyZXFfKCcuL2NyZWF0ZS12aWV3Jyk7XG52YXIgZXZhbEZ1bmMgPSBfZGVyZXFfKCcuL2V2YWxmdW5jJyk7XG52YXIgbG9nOyBcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAoKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgbG9nID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG59IGVsc2Uge1xuICBsb2cgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbHMnKTtcbnZhciBQcm9taXNlID0gdXRpbHMuUHJvbWlzZTtcbnZhciBtYWluUXVldWUgPSBuZXcgVGFza1F1ZXVlKCk7XG52YXIgdGVtcFZpZXdRdWV1ZSA9IG5ldyBUYXNrUXVldWUoKTtcbnZhciBDSEFOR0VTX0JBVENIX1NJWkUgPSA1MDtcblxuZnVuY3Rpb24gcGFyc2VWaWV3TmFtZShuYW1lKSB7XG4gIC8vIGNhbiBiZSBlaXRoZXIgJ2Rkb2NuYW1lL3ZpZXduYW1lJyBvciBqdXN0ICd2aWV3bmFtZSdcbiAgLy8gKHdoZXJlIHRoZSBkZG9jIG5hbWUgaXMgdGhlIHNhbWUpXG4gIHJldHVybiBuYW1lLmluZGV4T2YoJy8nKSA9PT0gLTEgPyBbbmFtZSwgbmFtZV0gOiBuYW1lLnNwbGl0KCcvJyk7XG59XG5cbmZ1bmN0aW9uIHRyeUNvZGUoZGIsIGZ1biwgYXJncykge1xuICAvLyBlbWl0IGFuIGV2ZW50IGlmIHRoZXJlIHdhcyBhbiBlcnJvciB0aHJvd24gYnkgYSBtYXAvcmVkdWNlIGZ1bmN0aW9uLlxuICAvLyBwdXR0aW5nIHRyeS9jYXRjaGVzIGluIGEgc2luZ2xlIGZ1bmN0aW9uIGFsc28gYXZvaWRzIGRlb3B0aW1pemF0aW9ucy5cbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0IDogZnVuLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRiLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgcmV0dXJuIHtlcnJvciA6IGV9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNvcnRCeUtleVRoZW5WYWx1ZSh4LCB5KSB7XG4gIHZhciBrZXlDb21wYXJlID0gY29sbGF0ZSh4LmtleSwgeS5rZXkpO1xuICByZXR1cm4ga2V5Q29tcGFyZSAhPT0gMCA/IGtleUNvbXBhcmUgOiBjb2xsYXRlKHgudmFsdWUsIHkudmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzbGljZVJlc3VsdHMocmVzdWx0cywgbGltaXQsIHNraXApIHtcbiAgc2tpcCA9IHNraXAgfHwgMDtcbiAgaWYgKHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5zbGljZShza2lwLCBsaW1pdCArIHNraXApO1xuICB9IGVsc2UgaWYgKHNraXAgPiAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdHMuc2xpY2Uoc2tpcCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1aWx0SW5FcnJvcihuYW1lKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcignYnVpbHRpbiAnICsgbmFtZSArXG4gICAgJyBmdW5jdGlvbiByZXF1aXJlcyBtYXAgdmFsdWVzIHRvIGJlIG51bWJlcnMnICtcbiAgICAnIG9yIG51bWJlciBhcnJheXMnKTtcbiAgZXJyb3IubmFtZSA9ICdpbnZhbGlkX3ZhbHVlJztcbiAgZXJyb3Iuc3RhdHVzID0gNTAwO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIHN1bSh2YWx1ZXMpIHtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbnVtID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobnVtKSkge1xuICAgICAgICAvLyBsaXN0cyBvZiBudW1iZXJzIGFyZSBhbHNvIGFsbG93ZWQsIHN1bSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgcmVzdWx0ID0gdHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgPyBbcmVzdWx0XSA6IHJlc3VsdDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBudW0ubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgdmFyIGpOdW0gPSBudW1bal07XG4gICAgICAgICAgaWYgKHR5cGVvZiBqTnVtICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQnVpbHRJbkVycm9yKCdfc3VtJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0W2pdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goak51bSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtqXSArPSBqTnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbm90IGFycmF5L251bWJlclxuICAgICAgICB0aHJvdyBjcmVhdGVCdWlsdEluRXJyb3IoJ19zdW0nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXN1bHQgKz0gbnVtO1xuICAgIH0gZWxzZSB7IC8vIGFkZCBudW1iZXIgdG8gYXJyYXlcbiAgICAgIHJlc3VsdFswXSArPSBudW07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBidWlsdEluUmVkdWNlID0ge1xuICBfc3VtOiBmdW5jdGlvbiAoa2V5cywgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHN1bSh2YWx1ZXMpO1xuICB9LFxuXG4gIF9jb3VudDogZnVuY3Rpb24gKGtleXMsIHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoO1xuICB9LFxuXG4gIF9zdGF0czogZnVuY3Rpb24gKGtleXMsIHZhbHVlcykge1xuICAgIC8vIG5vIG5lZWQgdG8gaW1wbGVtZW50IHJlcmVkdWNlPXRydWUsIGJlY2F1c2UgUG91Y2hcbiAgICAvLyB3aWxsIG5ldmVyIGNhbGwgaXRcbiAgICBmdW5jdGlvbiBzdW1zcXIodmFsdWVzKSB7XG4gICAgICB2YXIgX3N1bXNxciA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBudW0gPSB2YWx1ZXNbaV07XG4gICAgICAgIF9zdW1zcXIgKz0gKG51bSAqIG51bSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3N1bXNxcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1bSAgICAgOiBzdW0odmFsdWVzKSxcbiAgICAgIG1pbiAgICAgOiBNYXRoLm1pbi5hcHBseShudWxsLCB2YWx1ZXMpLFxuICAgICAgbWF4ICAgICA6IE1hdGgubWF4LmFwcGx5KG51bGwsIHZhbHVlcyksXG4gICAgICBjb3VudCAgIDogdmFsdWVzLmxlbmd0aCxcbiAgICAgIHN1bXNxciA6IHN1bXNxcih2YWx1ZXMpXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYWRkSHR0cFBhcmFtKHBhcmFtTmFtZSwgb3B0cywgcGFyYW1zLCBhc0pzb24pIHtcbiAgLy8gYWRkIGFuIGh0dHAgcGFyYW0gZnJvbSBvcHRzIHRvIHBhcmFtcywgb3B0aW9uYWxseSBqc29uLWVuY29kZWRcbiAgdmFyIHZhbCA9IG9wdHNbcGFyYW1OYW1lXTtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGFzSnNvbikge1xuICAgICAgdmFsID0gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICAgIH1cbiAgICBwYXJhbXMucHVzaChwYXJhbU5hbWUgKyAnPScgKyB2YWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUXVlcnlQYXJzZUVycm9yKG9wdGlvbnMsIGZ1bikge1xuICB2YXIgc3RhcnRrZXlOYW1lID0gb3B0aW9ucy5kZXNjZW5kaW5nID8gJ2VuZGtleScgOiAnc3RhcnRrZXknO1xuICB2YXIgZW5ka2V5TmFtZSA9IG9wdGlvbnMuZGVzY2VuZGluZyA/ICdzdGFydGtleScgOiAnZW5ka2V5JztcblxuICBpZiAodHlwZW9mIG9wdGlvbnNbc3RhcnRrZXlOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygb3B0aW9uc1tlbmRrZXlOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBjb2xsYXRlKG9wdGlvbnNbc3RhcnRrZXlOYW1lXSwgb3B0aW9uc1tlbmRrZXlOYW1lXSkgPiAwKSB7XG4gICAgdGhyb3cgbmV3IFF1ZXJ5UGFyc2VFcnJvcignTm8gcm93cyBjYW4gbWF0Y2ggeW91ciBrZXkgcmFuZ2UsIHJldmVyc2UgeW91ciAnICtcbiAgICAgICAgJ3N0YXJ0X2tleSBhbmQgZW5kX2tleSBvciBzZXQge2Rlc2NlbmRpbmcgOiB0cnVlfScpO1xuICB9IGVsc2UgaWYgKGZ1bi5yZWR1Y2UgJiYgb3B0aW9ucy5yZWR1Y2UgIT09IGZhbHNlKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZV9kb2NzKSB7XG4gICAgICB0aHJvdyBuZXcgUXVlcnlQYXJzZUVycm9yKCd7aW5jbHVkZV9kb2NzOnRydWV9IGlzIGludmFsaWQgZm9yIHJlZHVjZScpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5rZXlzICYmIG9wdGlvbnMua2V5cy5sZW5ndGggPiAxICYmXG4gICAgICAgICFvcHRpb25zLmdyb3VwICYmICFvcHRpb25zLmdyb3VwX2xldmVsKSB7XG4gICAgICB0aHJvdyBuZXcgUXVlcnlQYXJzZUVycm9yKCdNdWx0aS1rZXkgZmV0Y2hlcyBmb3IgcmVkdWNlIHZpZXdzIG11c3QgdXNlIHtncm91cDogdHJ1ZX0nKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuZ3JvdXBfbGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ3JvdXBfbGV2ZWwgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgUXVlcnlQYXJzZUVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBpbnRlZ2VyOiBcIicgKyBvcHRpb25zLmdyb3VwX2xldmVsICsgJ1wiJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdyb3VwX2xldmVsIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFF1ZXJ5UGFyc2VFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcG9zaXRpdmUgaW50ZWdlcjogJyArXG4gICAgICAgICdcIicgKyBvcHRpb25zLmdyb3VwX2xldmVsICsgJ1wiJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGh0dHBRdWVyeShkYiwgZnVuLCBvcHRzKSB7XG4gIC8vIExpc3Qgb2YgcGFyYW1ldGVycyB0byBhZGQgdG8gdGhlIFBVVCByZXF1ZXN0XG4gIHZhciBwYXJhbXMgPSBbXTtcbiAgdmFyIGJvZHk7XG4gIHZhciBtZXRob2QgPSAnR0VUJztcblxuICAvLyBJZiBvcHRzLnJlZHVjZSBleGlzdHMgYW5kIGlzIGRlZmluZWQsIHRoZW4gYWRkIGl0IHRvIHRoZSBsaXN0XG4gIC8vIG9mIHBhcmFtZXRlcnMuXG4gIC8vIElmIHJlZHVjZT1mYWxzZSB0aGVuIHRoZSByZXN1bHRzIGFyZSB0aGF0IG9mIG9ubHkgdGhlIG1hcCBmdW5jdGlvblxuICAvLyBub3QgdGhlIGZpbmFsIHJlc3VsdCBvZiBtYXAgYW5kIHJlZHVjZS5cbiAgYWRkSHR0cFBhcmFtKCdyZWR1Y2UnLCBvcHRzLCBwYXJhbXMpO1xuICBhZGRIdHRwUGFyYW0oJ2luY2x1ZGVfZG9jcycsIG9wdHMsIHBhcmFtcyk7XG4gIGFkZEh0dHBQYXJhbSgnbGltaXQnLCBvcHRzLCBwYXJhbXMpO1xuICBhZGRIdHRwUGFyYW0oJ2Rlc2NlbmRpbmcnLCBvcHRzLCBwYXJhbXMpO1xuICBhZGRIdHRwUGFyYW0oJ2dyb3VwJywgb3B0cywgcGFyYW1zKTtcbiAgYWRkSHR0cFBhcmFtKCdncm91cF9sZXZlbCcsIG9wdHMsIHBhcmFtcyk7XG4gIGFkZEh0dHBQYXJhbSgnc2tpcCcsIG9wdHMsIHBhcmFtcyk7XG4gIGFkZEh0dHBQYXJhbSgnc3RhbGUnLCBvcHRzLCBwYXJhbXMpO1xuICBhZGRIdHRwUGFyYW0oJ2NvbmZsaWN0cycsIG9wdHMsIHBhcmFtcyk7XG4gIGFkZEh0dHBQYXJhbSgnc3RhcnRrZXknLCBvcHRzLCBwYXJhbXMsIHRydWUpO1xuICBhZGRIdHRwUGFyYW0oJ2VuZGtleScsIG9wdHMsIHBhcmFtcywgdHJ1ZSk7XG4gIGFkZEh0dHBQYXJhbSgnaW5jbHVzaXZlX2VuZCcsIG9wdHMsIHBhcmFtcyk7XG4gIGFkZEh0dHBQYXJhbSgna2V5Jywgb3B0cywgcGFyYW1zLCB0cnVlKTtcblxuICAvLyBGb3JtYXQgdGhlIGxpc3Qgb2YgcGFyYW1ldGVycyBpbnRvIGEgdmFsaWQgVVJJIHF1ZXJ5IHN0cmluZ1xuICBwYXJhbXMgPSBwYXJhbXMuam9pbignJicpO1xuICBwYXJhbXMgPSBwYXJhbXMgPT09ICcnID8gJycgOiAnPycgKyBwYXJhbXM7XG5cbiAgLy8gSWYga2V5cyBhcmUgc3VwcGxpZWQsIGlzc3VlIGEgUE9TVCByZXF1ZXN0IHRvIGNpcmN1bXZlbnQgR0VUIHF1ZXJ5IHN0cmluZyBsaW1pdHNcbiAgLy8gc2VlIGh0dHA6Ly93aWtpLmFwYWNoZS5vcmcvY291Y2hkYi9IVFRQX3ZpZXdfQVBJI1F1ZXJ5aW5nX09wdGlvbnNcbiAgaWYgKHR5cGVvZiBvcHRzLmtleXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIE1BWF9VUkxfTEVOR1RIID0gMjAwMDtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDE3MTg0LzY4MDc0MixcbiAgICAvLyB0aGUgZGUgZmFjdG8gVVJMIGxlbmd0aCBsaW1pdCBpcyAyMDAwIGNoYXJhY3RlcnNcblxuICAgIHZhciBrZXlzQXNTdHJpbmcgPVxuICAgICAgJ2tleXM9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvcHRzLmtleXMpKTtcbiAgICBpZiAoa2V5c0FzU3RyaW5nLmxlbmd0aCArIHBhcmFtcy5sZW5ndGggKyAxIDw9IE1BWF9VUkxfTEVOR1RIKSB7XG4gICAgICAvLyBJZiB0aGUga2V5cyBhcmUgc2hvcnQgZW5vdWdoLCBkbyBhIEdFVC4gd2UgZG8gdGhpcyB0byB3b3JrIGFyb3VuZFxuICAgICAgLy8gU2FmYXJpIG5vdCB1bmRlcnN0YW5kaW5nIDMwNHMgb24gUE9TVHMgKHNlZSBwb3VjaGRiL3BvdWNoZGIjMTIzOSlcbiAgICAgIHBhcmFtcyArPSAocGFyYW1zWzBdID09PSAnPycgPyAnJicgOiAnPycpICsga2V5c0FzU3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICBpZiAodHlwZW9mIGZ1biA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtrZXlzOiBvcHRzLmtleXN9KTtcbiAgICAgIH0gZWxzZSB7IC8vIGZ1biBpcyB7bWFwIDogbWFwZnVufSwgc28gYXBwZW5kIHRvIHRoaXNcbiAgICAgICAgZnVuLmtleXMgPSBvcHRzLmtleXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgYXJlIHJlZmVyZW5jaW5nIGEgcXVlcnkgZGVmaW5lZCBpbiB0aGUgZGVzaWduIGRvY1xuICBpZiAodHlwZW9mIGZ1biA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcGFydHMgPSBwYXJzZVZpZXdOYW1lKGZ1bik7XG4gICAgcmV0dXJuIGRiLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6ICdfZGVzaWduLycgKyBwYXJ0c1swXSArICcvX3ZpZXcvJyArIHBhcnRzWzFdICsgcGFyYW1zLFxuICAgICAgYm9keTogYm9keVxuICAgIH0pO1xuICB9XG5cbiAgLy8gV2UgYXJlIHVzaW5nIGEgdGVtcG9yYXJ5IHZpZXcsIHRlcnJpYmxlIGZvciBwZXJmb3JtYW5jZSBidXQgZ29vZCBmb3IgdGVzdGluZ1xuICBib2R5ID0gYm9keSB8fCB7fTtcbiAgT2JqZWN0LmtleXMoZnVuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmdW5ba2V5XSkpIHtcbiAgICAgIGJvZHlba2V5XSA9IGZ1bltrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5W2tleV0gPSBmdW5ba2V5XS50b1N0cmluZygpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYi5yZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICdfdGVtcF92aWV3JyArIHBhcmFtcyxcbiAgICBib2R5OiBib2R5XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0c1RvKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocmVhc29uLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHJlYXNvbjtcbiAgICB9XG4gIH07XG59XG5cbi8vIHJldHVybnMgYSBwcm9taXNlIGZvciBhIGxpc3Qgb2YgZG9jcyB0byB1cGRhdGUsIGJhc2VkIG9uIHRoZSBpbnB1dCBkb2NJZC5cbi8vIHdlIHVwZGF0ZSB0aGUgbWV0YURvYyBmaXJzdCAoaS5lLiB0aGUgZG9jIHRoYXQgcG9pbnRzIGZyb20gdGhlIHNvdXJjZURCXG4vLyBkb2N1bWVudCBJZCB0byB0aGUgaWRzIG9mIHRoZSBkb2N1bWVudHMgaW4gdGhlIG1ydmlldyBkYXRhYmFzZSksIHRoZW5cbi8vIHRoZSBrZXkvdmFsdWUgZG9jcy4gIHRoYXQgd2F5LCBpZiBsaWdodG5pbmcgc3RyaWtlcyB0aGUgdXNlcidzIGNvbXB1dGVyXG4vLyBpbiB0aGUgbWlkZGxlIG9mIGFuIHVwZGF0ZSwgd2UgZG9uJ3Qgd3JpdGUgYW55IGRvY3MgdGhhdCB3ZSB3b3VsZG4ndFxuLy8gYmUgYWJsZSB0byBmaW5kIGxhdGVyIHVzaW5nIHRoZSBtZXRhRG9jLlxuZnVuY3Rpb24gZ2V0RG9jc1RvUGVyc2lzdChkb2NJZCwgdmlldywgZG9jSWRzVG9FbWl0cykge1xuICB2YXIgbWV0YURvY0lkID0gJ19sb2NhbC9kb2NfJyArIGRvY0lkO1xuICByZXR1cm4gdmlldy5kYi5nZXQobWV0YURvY0lkKVtcbiAgICBcImNhdGNoXCJdKGRlZmF1bHRzVG8oe19pZDogbWV0YURvY0lkLCBrZXlzOiBbXX0pKVxuICAgIC50aGVuKGZ1bmN0aW9uIChtZXRhRG9jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtZXRhRG9jLmtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHZpZXcuZGIuYWxsRG9jcyh7XG4gICAgICAgICAgICBrZXlzOiBtZXRhRG9jLmtleXMsXG4gICAgICAgICAgICBpbmNsdWRlX2RvY3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3Jvd3M6IFtdfTsgLy8gbm8ga2V5cywgbm8gbmVlZCBmb3IgYSBsb29rdXBcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2YXIga3ZEb2NzID0gcmVzLnJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93LmRvYztcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaW5kZXhhYmxlS2V5c1RvS2V5VmFsdWVzID0gZG9jSWRzVG9FbWl0c1tkb2NJZF07XG4gICAgICAgIHZhciBvbGRLZXlzTWFwID0ge307XG4gICAgICAgIGt2RG9jcy5mb3JFYWNoKGZ1bmN0aW9uIChrdkRvYykge1xuICAgICAgICAgIG9sZEtleXNNYXBba3ZEb2MuX2lkXSA9IHRydWU7XG4gICAgICAgICAga3ZEb2MuX2RlbGV0ZWQgPSAhaW5kZXhhYmxlS2V5c1RvS2V5VmFsdWVzW2t2RG9jLl9pZF07XG4gICAgICAgICAgaWYgKCFrdkRvYy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gaW5kZXhhYmxlS2V5c1RvS2V5VmFsdWVzW2t2RG9jLl9pZF07XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBrZXlWYWx1ZSkge1xuICAgICAgICAgICAgICBrdkRvYy52YWx1ZSA9IGtleVZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG5ld0tleXMgPSBPYmplY3Qua2V5cyhpbmRleGFibGVLZXlzVG9LZXlWYWx1ZXMpO1xuICAgICAgICBuZXdLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmICghb2xkS2V5c01hcFtrZXldKSB7XG4gICAgICAgICAgICAvLyBuZXcgZG9jXG4gICAgICAgICAgICB2YXIga3ZEb2MgPSB7XG4gICAgICAgICAgICAgIF9pZDoga2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gaW5kZXhhYmxlS2V5c1RvS2V5VmFsdWVzW2tleV07XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBrZXlWYWx1ZSkge1xuICAgICAgICAgICAgICBrdkRvYy52YWx1ZSA9IGtleVZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga3ZEb2NzLnB1c2goa3ZEb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGFEb2Mua2V5cyA9IHV0aWxzLnVuaXEobmV3S2V5cy5jb25jYXQobWV0YURvYy5rZXlzKSk7XG4gICAgICAgIGt2RG9jcy5zcGxpY2UoMCwgMCwgbWV0YURvYyk7XG5cbiAgICAgICAgcmV0dXJuIGt2RG9jcztcbiAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vLyB1cGRhdGVzIGFsbCBlbWl0dGVkIGtleS92YWx1ZSBkb2NzIGFuZCBtZXRhRG9jcyBpbiB0aGUgbXJ2aWV3IGRhdGFiYXNlXG4vLyBmb3IgdGhlIGdpdmVuIGJhdGNoIG9mIGRvY3VtZW50cyBmcm9tIHRoZSBzb3VyY2UgZGF0YWJhc2VcbmZ1bmN0aW9uIHNhdmVLZXlWYWx1ZXModmlldywgZG9jSWRzVG9FbWl0cywgc2VxKSB7XG4gIHZhciBzZXFEb2NJZCA9ICdfbG9jYWwvbGFzdFNlcSc7XG4gIHJldHVybiB2aWV3LmRiLmdldChzZXFEb2NJZClbXG4gIFwiY2F0Y2hcIl0oZGVmYXVsdHNUbyh7X2lkOiBzZXFEb2NJZCwgc2VxOiAwfSkpXG4gIC50aGVuKGZ1bmN0aW9uIChsYXN0U2VxRG9jKSB7XG4gICAgdmFyIGRvY0lkcyA9IE9iamVjdC5rZXlzKGRvY0lkc1RvRW1pdHMpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChkb2NJZHMubWFwKGZ1bmN0aW9uIChkb2NJZCkge1xuICAgICAgICByZXR1cm4gZ2V0RG9jc1RvUGVyc2lzdChkb2NJZCwgdmlldywgZG9jSWRzVG9FbWl0cyk7XG4gICAgICB9KSkudGhlbihmdW5jdGlvbiAobGlzdE9mRG9jc1RvUGVyc2lzdCkge1xuICAgICAgICB2YXIgZG9jc1RvUGVyc2lzdCA9IFtdO1xuICAgICAgICBsaXN0T2ZEb2NzVG9QZXJzaXN0LmZvckVhY2goZnVuY3Rpb24gKGRvY0xpc3QpIHtcbiAgICAgICAgICBkb2NzVG9QZXJzaXN0ID0gZG9jc1RvUGVyc2lzdC5jb25jYXQoZG9jTGlzdCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc2VxIGRvYyBsYXN0LCBzbyB0aGF0IGlmIGEgbWV0ZW9yIHN0cmlrZXMgdGhlIHVzZXInc1xuICAgICAgICAvLyBjb21wdXRlciBpbiB0aGUgbWlkZGxlIG9mIGFuIHVwZGF0ZSwgd2UgY2FuIGFwcGx5IHRoZSBpZGVtcG90ZW50XG4gICAgICAgIC8vIGJhdGNoIHVwZGF0ZSBvcGVyYXRpb24gYWdhaW5cbiAgICAgICAgbGFzdFNlcURvYy5zZXEgPSBzZXE7XG4gICAgICAgIGRvY3NUb1BlcnNpc3QucHVzaChsYXN0U2VxRG9jKTtcblxuICAgICAgICByZXR1cm4gdmlldy5kYi5idWxrRG9jcyh7ZG9jcyA6IGRvY3NUb1BlcnNpc3R9KTtcbiAgICAgIH0pO1xuICB9KTtcbn1cblxudmFyIHVwZGF0ZVZpZXcgPSB1dGlscy5zZXF1ZW50aWFsaXplKG1haW5RdWV1ZSwgZnVuY3Rpb24gKHZpZXcpIHtcbiAgLy8gYmluZCB0aGUgZW1pdCBmdW5jdGlvbiBvbmNlXG4gIHZhciBtYXBSZXN1bHRzO1xuICB2YXIgZG9jO1xuXG4gIGZ1bmN0aW9uIGVtaXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBvdXRwdXQgPSB7IGlkOiBkb2MuX2lkLCBrZXk6IG5vcm1hbGl6ZUtleShrZXkpIH07XG4gICAgLy8gRG9uJ3QgZXhwbGljaXRseSBzdG9yZSB0aGUgdmFsdWUgdW5sZXNzIGl0J3MgZGVmaW5lZCBhbmQgbm9uLW51bGwuXG4gICAgLy8gVGhpcyBzYXZlcyBvbiBzdG9yYWdlIHNwYWNlLCBiZWNhdXNlIG9mdGVuIHBlb3BsZSBkb24ndCB1c2UgaXQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIG91dHB1dC52YWx1ZSA9IG5vcm1hbGl6ZUtleSh2YWx1ZSk7XG4gICAgfVxuICAgIG1hcFJlc3VsdHMucHVzaChvdXRwdXQpO1xuICB9XG5cbiAgdmFyIG1hcEZ1bjtcbiAgLy8gZm9yIHRlbXBfdmlld3Mgb25lIGNhbiB1c2UgZW1pdChkb2MsIGVtaXQpLCBzZWUgIzM4XG4gIGlmICh0eXBlb2Ygdmlldy5tYXBGdW4gPT09IFwiZnVuY3Rpb25cIiAmJiB2aWV3Lm1hcEZ1bi5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgb3JpZ01hcCA9IHZpZXcubWFwRnVuO1xuICAgIG1hcEZ1biA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIHJldHVybiBvcmlnTWFwKGRvYywgZW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtYXBGdW4gPSBldmFsRnVuYyh2aWV3Lm1hcEZ1bi50b1N0cmluZygpLCBlbWl0LCBzdW0sIGxvZywgQXJyYXkuaXNBcnJheSwgSlNPTi5wYXJzZSk7XG4gIH1cblxuICB2YXIgY3VycmVudFNlcSA9IHZpZXcuc2VxIHx8IDA7XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0NoYW5nZShkb2NJZHNUb0VtaXRzLCBzZXEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNhdmVLZXlWYWx1ZXModmlldywgZG9jSWRzVG9FbWl0cywgc2VxKTtcbiAgICB9O1xuICB9XG4gIHZhciBxdWV1ZSA9IG5ldyBUYXNrUXVldWUoKTtcbiAgLy8gVE9ETyhuZW9qc2tpKTogaHR0cHM6Ly9naXRodWIuY29tL2RhbGVoYXJ2ZXkvcG91Y2hkYi9pc3N1ZXMvMTUyMVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgIHF1ZXVlLmZpbmlzaCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWV3LnNlcSA9IGN1cnJlbnRTZXE7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NOZXh0QmF0Y2goKSB7XG4gICAgICB2aWV3LnNvdXJjZURCLmNoYW5nZXMoe1xuICAgICAgICBjb25mbGljdHM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVfZG9jczogdHJ1ZSxcbiAgICAgICAgc2luY2UgOiBjdXJyZW50U2VxLFxuICAgICAgICBsaW1pdCA6IENIQU5HRVNfQkFUQ0hfU0laRVxuICAgICAgfSkub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gcmVzcG9uc2UucmVzdWx0cztcbiAgICAgICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb2NJZHNUb0VtaXRzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hhbmdlID0gcmVzdWx0c1tpXTtcbiAgICAgICAgICBpZiAoY2hhbmdlLmRvYy5faWRbMF0gIT09ICdfJykge1xuICAgICAgICAgICAgbWFwUmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZG9jID0gY2hhbmdlLmRvYztcblxuICAgICAgICAgICAgaWYgKCFkb2MuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgdHJ5Q29kZSh2aWV3LnNvdXJjZURCLCBtYXBGdW4sIFtkb2NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcFJlc3VsdHMuc29ydChzb3J0QnlLZXlUaGVuVmFsdWUpO1xuXG4gICAgICAgICAgICB2YXIgaW5kZXhhYmxlS2V5c1RvS2V5VmFsdWVzID0ge307XG4gICAgICAgICAgICB2YXIgbGFzdEtleTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IG1hcFJlc3VsdHMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICB2YXIgb2JqID0gbWFwUmVzdWx0c1tqXTtcbiAgICAgICAgICAgICAgdmFyIGNvbXBsZXhLZXkgPSBbb2JqLmtleSwgb2JqLmlkXTtcbiAgICAgICAgICAgICAgaWYgKG9iai5rZXkgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV4S2V5LnB1c2goaik7IC8vIGR1cCBrZXkraWQsIHNvIG1ha2UgaXQgdW5pcXVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGluZGV4YWJsZUtleSA9IHRvSW5kZXhhYmxlU3RyaW5nKGNvbXBsZXhLZXkpO1xuICAgICAgICAgICAgICBpbmRleGFibGVLZXlzVG9LZXlWYWx1ZXNbaW5kZXhhYmxlS2V5XSA9IG9iajtcbiAgICAgICAgICAgICAgbGFzdEtleSA9IG9iai5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2NJZHNUb0VtaXRzW2NoYW5nZS5kb2MuX2lkXSA9IGluZGV4YWJsZUtleXNUb0tleVZhbHVlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFNlcSA9IGNoYW5nZS5zZXE7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUuYWRkKHByb2Nlc3NDaGFuZ2UoZG9jSWRzVG9FbWl0cywgY3VycmVudFNlcSkpO1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPCBDSEFOR0VTX0JBVENIX1NJWkUpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzc05leHRCYXRjaCgpO1xuICAgICAgfSkub24oJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NOZXh0QmF0Y2goKTtcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gcmVkdWNlVmlldyh2aWV3LCByZXN1bHRzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmdyb3VwX2xldmVsID09PSAwKSB7XG4gICAgZGVsZXRlIG9wdGlvbnMuZ3JvdXBfbGV2ZWw7XG4gIH1cblxuICB2YXIgc2hvdWxkR3JvdXAgPSBvcHRpb25zLmdyb3VwIHx8IG9wdGlvbnMuZ3JvdXBfbGV2ZWw7XG5cbiAgdmFyIHJlZHVjZUZ1bjtcbiAgaWYgKGJ1aWx0SW5SZWR1Y2Vbdmlldy5yZWR1Y2VGdW5dKSB7XG4gICAgcmVkdWNlRnVuID0gYnVpbHRJblJlZHVjZVt2aWV3LnJlZHVjZUZ1bl07XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlRnVuID0gZXZhbEZ1bmMoXG4gICAgICB2aWV3LnJlZHVjZUZ1bi50b1N0cmluZygpLCBudWxsLCBzdW0sIGxvZywgQXJyYXkuaXNBcnJheSwgSlNPTi5wYXJzZSk7XG4gIH1cblxuICB2YXIgZ3JvdXBzID0gW107XG4gIHZhciBsdmwgPSBvcHRpb25zLmdyb3VwX2xldmVsO1xuICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbGFzdCA9IGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGtleSA9IHNob3VsZEdyb3VwID8gZS5rZXkgOiBudWxsO1xuXG4gICAgLy8gb25seSBzZXQgZ3JvdXBfbGV2ZWwgZm9yIGFycmF5IGtleXNcbiAgICBpZiAoc2hvdWxkR3JvdXAgJiYgQXJyYXkuaXNBcnJheShrZXkpICYmIHR5cGVvZiBsdmwgPT09ICdudW1iZXInKSB7XG4gICAgICBrZXkgPSBrZXkubGVuZ3RoID4gbHZsID8ga2V5LnNsaWNlKDAsIGx2bCkgOiBrZXk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgY29sbGF0ZShsYXN0LmtleVswXVswXSwga2V5KSA9PT0gMCkge1xuICAgICAgbGFzdC5rZXkucHVzaChba2V5LCBlLmlkXSk7XG4gICAgICBsYXN0LnZhbHVlLnB1c2goZS52YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdyb3Vwcy5wdXNoKHtrZXk6IFtcbiAgICAgIFtrZXksIGUuaWRdXG4gICAgXSwgdmFsdWU6IFtlLnZhbHVlXX0pO1xuICB9KTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gZ3JvdXBzW2ldO1xuICAgIHZhciByZWR1Y2VUcnkgPSB0cnlDb2RlKHZpZXcuc291cmNlREIsIHJlZHVjZUZ1biwgW2Uua2V5LCBlLnZhbHVlLCBmYWxzZV0pO1xuICAgIC8vIENvdWNoREIgdHlwaWNhbGx5IGp1c3Qgc2V0cyB0aGUgdmFsdWUgdG8gbnVsbCBpZiByZWR1Y2UgZXJyb3JzIG91dFxuICAgIGUudmFsdWUgPSByZWR1Y2VUcnkuZXJyb3IgPyBudWxsIDogcmVkdWNlVHJ5Lm91dHB1dDtcbiAgICBlLmtleSA9IGUua2V5WzBdWzBdO1xuICB9XG4gIC8vIG5vIHRvdGFsX3Jvd3Mvb2Zmc2V0IHdoZW4gcmVkdWNpbmdcbiAgcmV0dXJuIHtyb3dzOiBzbGljZVJlc3VsdHMoZ3JvdXBzLCBvcHRpb25zLmxpbWl0LCBvcHRpb25zLnNraXApfTtcbn1cblxudmFyIHF1ZXJ5VmlldyA9IHV0aWxzLnNlcXVlbnRpYWxpemUobWFpblF1ZXVlLCBmdW5jdGlvbiAodmlldywgb3B0cykge1xuICB2YXIgdG90YWxSb3dzO1xuICB2YXIgc2hvdWxkUmVkdWNlID0gdmlldy5yZWR1Y2VGdW4gJiYgb3B0cy5yZWR1Y2UgIT09IGZhbHNlO1xuICB2YXIgc2tpcCA9IG9wdHMuc2tpcCB8fCAwO1xuICBpZiAodHlwZW9mIG9wdHMua2V5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgIW9wdHMua2V5cy5sZW5ndGgpIHtcbiAgICAvLyBlcXVpdmFsZW50IHF1ZXJ5XG4gICAgb3B0cy5saW1pdCA9IDA7XG4gICAgZGVsZXRlIG9wdHMua2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoRnJvbVZpZXcodmlld09wdHMpIHtcbiAgICB2aWV3T3B0cy5pbmNsdWRlX2RvY3MgPSB0cnVlO1xuICAgIHJldHVybiB2aWV3LmRiLmFsbERvY3Modmlld09wdHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdG90YWxSb3dzID0gcmVzLnRvdGFsX3Jvd3M7XG4gICAgICByZXR1cm4gcmVzLnJvd3MubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcblxuICAgICAgICAvLyBpbXBsaWNpdCBtaWdyYXRpb24gLSBpbiBvbGRlciB2ZXJzaW9ucyBvZiBQb3VjaERCLFxuICAgICAgICAvLyB3ZSBleHBsaWNpdGx5IHN0b3JlZCB0aGUgZG9jIGFzIHtpZDogLi4uLCBrZXk6IC4uLiwgdmFsdWU6IC4uLn1cbiAgICAgICAgLy8gdGhpcyBpcyB0ZXN0ZWQgaW4gYSBtaWdyYXRpb24gdGVzdFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiByZXN1bHQuZG9jICYmIHR5cGVvZiByZXN1bHQuZG9jLnZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgcmVzdWx0LmRvYy52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVzdWx0LmRvYy52YWx1ZSkuc29ydCgpO1xuICAgICAgICAgIC8vIHRoaXMgZGV0ZWN0aW9uIG1ldGhvZCBpcyBub3QgcGVyZmVjdCwgYnV0IGl0J3MgdW5saWtlbHkgdGhlIHVzZXJcbiAgICAgICAgICAvLyBlbWl0dGVkIGEgdmFsdWUgd2hpY2ggd2FzIGFuIG9iamVjdCB3aXRoIHRoZXNlIDMgZXhhY3Qga2V5c1xuICAgICAgICAgIHZhciBleHBlY3RlZEtleXMgPSBbJ2lkJywgJ2tleScsICd2YWx1ZSddO1xuICAgICAgICAgIGlmICghKGtleXMgPCBleHBlY3RlZEtleXMgfHwga2V5cyA+IGV4cGVjdGVkS2V5cykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZG9jLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzZWRLZXlBbmREb2NJZCA9IHBvdWNoQ29sbGF0ZS5wYXJzZUluZGV4YWJsZVN0cmluZyhyZXN1bHQuZG9jLl9pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5OiBwYXJzZWRLZXlBbmREb2NJZFswXSxcbiAgICAgICAgICBpZDogcGFyc2VkS2V5QW5kRG9jSWRbMV0sXG4gICAgICAgICAgdmFsdWU6ICgndmFsdWUnIGluIHJlc3VsdC5kb2MgPyByZXN1bHQuZG9jLnZhbHVlIDogbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25NYXBSZXN1bHRzUmVhZHkocmVzdWx0cykge1xuICAgIHZhciByZXM7XG4gICAgaWYgKHNob3VsZFJlZHVjZSkge1xuICAgICAgcmVzID0gcmVkdWNlVmlldyh2aWV3LCByZXN1bHRzLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ge1xuICAgICAgICB0b3RhbF9yb3dzOiB0b3RhbFJvd3MsXG4gICAgICAgIG9mZnNldDogc2tpcCxcbiAgICAgICAgcm93czogcmVzdWx0c1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdHMuaW5jbHVkZV9kb2NzKSB7XG4gICAgICB2YXIgZ2V0RG9jc1Byb21pc2VzID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgdmFsID0gcm93LnZhbHVlO1xuICAgICAgICB2YXIgZG9jSWQgPSAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbC5faWQpIHx8IHJvdy5pZDtcbiAgICAgICAgcmV0dXJuIHZpZXcuc291cmNlREIuZ2V0KGRvY0lkLCB7Y29uZmxpY3RzOiBvcHRzLmNvbmZsaWN0c30pLnRoZW4oZnVuY3Rpb24gKGpvaW5lZERvYykge1xuICAgICAgICAgIHJvdy5kb2MgPSBqb2luZWREb2M7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBkb2N1bWVudCBlcnJvciA9IGRvbid0IGpvaW5cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChnZXREb2NzUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmICh0eXBlb2Ygb3B0cy5rZXlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBrZXlzID0gb3B0cy5rZXlzO1xuICAgIHZhciBmZXRjaFByb21pc2VzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHZpZXdPcHRzID0ge1xuICAgICAgICBzdGFydGtleSA6IHRvSW5kZXhhYmxlU3RyaW5nKFtrZXldKSxcbiAgICAgICAgZW5ka2V5ICAgOiB0b0luZGV4YWJsZVN0cmluZyhba2V5LCB7fV0pXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZldGNoRnJvbVZpZXcodmlld09wdHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChmZXRjaFByb21pc2VzKS50aGVuKGZsYXR0ZW4pLnRoZW4ob25NYXBSZXN1bHRzUmVhZHkpO1xuICB9IGVsc2UgeyAvLyBub3JtYWwgcXVlcnksIG5vICdrZXlzJ1xuICAgIHZhciB2aWV3T3B0cyA9IHtcbiAgICAgIGRlc2NlbmRpbmcgOiBvcHRzLmRlc2NlbmRpbmdcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygb3B0cy5zdGFydGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZpZXdPcHRzLnN0YXJ0a2V5ID0gb3B0cy5kZXNjZW5kaW5nID9cbiAgICAgICAgdG9JbmRleGFibGVTdHJpbmcoW29wdHMuc3RhcnRrZXksIHt9XSkgOlxuICAgICAgICB0b0luZGV4YWJsZVN0cmluZyhbb3B0cy5zdGFydGtleV0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuZW5ka2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGluY2x1c2l2ZUVuZCA9IG9wdHMuaW5jbHVzaXZlX2VuZCAhPT0gZmFsc2U7XG4gICAgICBpZiAob3B0cy5kZXNjZW5kaW5nKSB7XG4gICAgICAgIGluY2x1c2l2ZUVuZCA9ICFpbmNsdXNpdmVFbmQ7XG4gICAgICB9XG5cbiAgICAgIHZpZXdPcHRzLmVuZGtleSA9IHRvSW5kZXhhYmxlU3RyaW5nKGluY2x1c2l2ZUVuZCA/IFtvcHRzLmVuZGtleSwge31dIDogW29wdHMuZW5ka2V5XSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5rZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIga2V5U3RhcnQgPSB0b0luZGV4YWJsZVN0cmluZyhbb3B0cy5rZXldKTtcbiAgICAgIHZhciBrZXlFbmQgPSB0b0luZGV4YWJsZVN0cmluZyhbb3B0cy5rZXksIHt9XSk7XG4gICAgICBpZiAodmlld09wdHMuZGVzY2VuZGluZykge1xuICAgICAgICB2aWV3T3B0cy5lbmRrZXkgPSBrZXlTdGFydDtcbiAgICAgICAgdmlld09wdHMuc3RhcnRrZXkgPSBrZXlFbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3T3B0cy5zdGFydGtleSA9IGtleVN0YXJ0O1xuICAgICAgICB2aWV3T3B0cy5lbmRrZXkgPSBrZXlFbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2hvdWxkUmVkdWNlKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMubGltaXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZpZXdPcHRzLmxpbWl0ID0gb3B0cy5saW1pdDtcbiAgICAgIH1cbiAgICAgIHZpZXdPcHRzLnNraXAgPSBza2lwO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hGcm9tVmlldyh2aWV3T3B0cykudGhlbihvbk1hcFJlc3VsdHNSZWFkeSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBodHRwVmlld0NsZWFudXAoZGIpIHtcbiAgcmV0dXJuIGRiLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJ192aWV3X2NsZWFudXAnXG4gIH0pO1xufVxuXG52YXIgbG9jYWxWaWV3Q2xlYW51cCA9IHV0aWxzLnNlcXVlbnRpYWxpemUobWFpblF1ZXVlLCBmdW5jdGlvbiAoZGIpIHtcbiAgcmV0dXJuIGRiLmdldCgnX2xvY2FsL21ydmlld3MnKS50aGVuKGZ1bmN0aW9uIChtZXRhRG9jKSB7XG4gICAgdmFyIGRvY3NUb1ZpZXdzID0ge307XG4gICAgT2JqZWN0LmtleXMobWV0YURvYy52aWV3cykuZm9yRWFjaChmdW5jdGlvbiAoZnVsbFZpZXdOYW1lKSB7XG4gICAgICB2YXIgcGFydHMgPSBwYXJzZVZpZXdOYW1lKGZ1bGxWaWV3TmFtZSk7XG4gICAgICB2YXIgZGVzaWduRG9jTmFtZSA9ICdfZGVzaWduLycgKyBwYXJ0c1swXTtcbiAgICAgIHZhciB2aWV3TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgZG9jc1RvVmlld3NbZGVzaWduRG9jTmFtZV0gPSBkb2NzVG9WaWV3c1tkZXNpZ25Eb2NOYW1lXSB8fCB7fTtcbiAgICAgIGRvY3NUb1ZpZXdzW2Rlc2lnbkRvY05hbWVdW3ZpZXdOYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBrZXlzIDogT2JqZWN0LmtleXMoZG9jc1RvVmlld3MpLFxuICAgICAgaW5jbHVkZV9kb2NzIDogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIGRiLmFsbERvY3Mob3B0cykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgdmlld3NUb1N0YXR1cyA9IHt9O1xuICAgICAgcmVzLnJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBkZG9jTmFtZSA9IHJvdy5rZXkuc3Vic3RyaW5nKDgpO1xuICAgICAgICBPYmplY3Qua2V5cyhkb2NzVG9WaWV3c1tyb3cua2V5XSkuZm9yRWFjaChmdW5jdGlvbiAodmlld05hbWUpIHtcbiAgICAgICAgICB2YXIgZnVsbFZpZXdOYW1lID0gZGRvY05hbWUgKyAnLycgKyB2aWV3TmFtZTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIW1ldGFEb2Mudmlld3NbZnVsbFZpZXdOYW1lXSkge1xuICAgICAgICAgICAgLy8gbmV3IGZvcm1hdCwgd2l0aG91dCBzbGFzaGVzLCB0byBzdXBwb3J0IFBvdWNoREIgMi4yLjBcbiAgICAgICAgICAgIC8vIG1pZ3JhdGlvbiB0ZXN0IGluIHBvdWNoZGIncyBicm93c2VyLm1pZ3JhdGlvbi5qcyB2ZXJpZmllcyB0aGlzXG4gICAgICAgICAgICBmdWxsVmlld05hbWUgPSB2aWV3TmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZpZXdEQk5hbWVzID0gT2JqZWN0LmtleXMobWV0YURvYy52aWV3c1tmdWxsVmlld05hbWVdKTtcbiAgICAgICAgICAvLyBkZXNpZ24gZG9jIGRlbGV0ZWQsIG9yIHZpZXcgZnVuY3Rpb24gbm9uZXhpc3RlbnRcbiAgICAgICAgICB2YXIgc3RhdHVzSXNHb29kID0gcm93LmRvYyAmJiByb3cuZG9jLnZpZXdzICYmIHJvdy5kb2Mudmlld3Nbdmlld05hbWVdO1xuICAgICAgICAgIHZpZXdEQk5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZpZXdEQk5hbWUpIHtcbiAgICAgICAgICAgIHZpZXdzVG9TdGF0dXNbdmlld0RCTmFtZV0gPSB2aWV3c1RvU3RhdHVzW3ZpZXdEQk5hbWVdIHx8IHN0YXR1c0lzR29vZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBkYnNUb0RlbGV0ZSA9IE9iamVjdC5rZXlzKHZpZXdzVG9TdGF0dXMpLmZpbHRlcihmdW5jdGlvbiAodmlld0RCTmFtZSkge1xuICAgICAgICByZXR1cm4gIXZpZXdzVG9TdGF0dXNbdmlld0RCTmFtZV07XG4gICAgICB9KTtcbiAgICAgIHZhciBkZXN0cm95UHJvbWlzZXMgPSBkYnNUb0RlbGV0ZS5tYXAoZnVuY3Rpb24gKHZpZXdEQk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRiLmNvbnN0cnVjdG9yLmRlc3Ryb3kodmlld0RCTmFtZSwge2FkYXB0ZXIgOiBkYi5hZGFwdGVyfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChkZXN0cm95UHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge29rOiB0cnVlfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBkZWZhdWx0c1RvKHtvazogdHJ1ZX0pKTtcbn0pO1xuXG5leHBvcnRzLnZpZXdDbGVhbnVwID0gdXRpbHMuY2FsbGJhY2tpZnkoZnVuY3Rpb24gKCkge1xuICB2YXIgZGIgPSB0aGlzO1xuICBpZiAoZGIudHlwZSgpID09PSAnaHR0cCcpIHtcbiAgICByZXR1cm4gaHR0cFZpZXdDbGVhbnVwKGRiKTtcbiAgfVxuICByZXR1cm4gbG9jYWxWaWV3Q2xlYW51cChkYik7XG59KTtcblxuZnVuY3Rpb24gcXVlcnlQcm9taXNlZChkYiwgZnVuLCBvcHRzKSB7XG4gIGlmIChkYi50eXBlKCkgPT09ICdodHRwJykge1xuICAgIHJldHVybiBodHRwUXVlcnkoZGIsIGZ1biwgb3B0cyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGZ1biAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyB0ZW1wX3ZpZXdcbiAgICBjaGVja1F1ZXJ5UGFyc2VFcnJvcihvcHRzLCBmdW4pO1xuXG4gICAgdmFyIGNyZWF0ZVZpZXdPcHRzID0ge1xuICAgICAgZGIgOiBkYixcbiAgICAgIHZpZXdOYW1lIDogJ3RlbXBfdmlldy90ZW1wX3ZpZXcnLFxuICAgICAgbWFwIDogZnVuLm1hcCxcbiAgICAgIHJlZHVjZSA6IGZ1bi5yZWR1Y2UsXG4gICAgICB0ZW1wb3JhcnkgOiB0cnVlXG4gICAgfTtcbiAgICB0ZW1wVmlld1F1ZXVlLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhjcmVhdGVWaWV3T3B0cykudGhlbihmdW5jdGlvbiAodmlldykge1xuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgIHJldHVybiB2aWV3LmRiLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuZmluKHVwZGF0ZVZpZXcodmlldykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5Vmlldyh2aWV3LCBvcHRzKTtcbiAgICAgICAgfSksIGNsZWFudXApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRlbXBWaWV3UXVldWUuZmluaXNoKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcGVyc2lzdGVudCB2aWV3XG4gICAgdmFyIGZ1bGxWaWV3TmFtZSA9IGZ1bjtcbiAgICB2YXIgcGFydHMgPSBwYXJzZVZpZXdOYW1lKGZ1bGxWaWV3TmFtZSk7XG4gICAgdmFyIGRlc2lnbkRvY05hbWUgPSBwYXJ0c1swXTtcbiAgICB2YXIgdmlld05hbWUgPSBwYXJ0c1sxXTtcbiAgICByZXR1cm4gZGIuZ2V0KCdfZGVzaWduLycgKyBkZXNpZ25Eb2NOYW1lKS50aGVuKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIHZhciBmdW4gPSBkb2Mudmlld3MgJiYgZG9jLnZpZXdzW3ZpZXdOYW1lXTtcblxuICAgICAgaWYgKCFmdW4gfHwgdHlwZW9mIGZ1bi5tYXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCdkZG9jICcgKyBkZXNpZ25Eb2NOYW1lICsgJyBoYXMgbm8gdmlldyBuYW1lZCAnICtcbiAgICAgICAgICB2aWV3TmFtZSk7XG4gICAgICB9XG4gICAgICBjaGVja1F1ZXJ5UGFyc2VFcnJvcihvcHRzLCBmdW4pO1xuXG4gICAgICB2YXIgY3JlYXRlVmlld09wdHMgPSB7XG4gICAgICAgIGRiIDogZGIsXG4gICAgICAgIHZpZXdOYW1lIDogZnVsbFZpZXdOYW1lLFxuICAgICAgICBtYXAgOiBmdW4ubWFwLFxuICAgICAgICByZWR1Y2UgOiBmdW4ucmVkdWNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNyZWF0ZVZpZXcoY3JlYXRlVmlld09wdHMpLnRoZW4oZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgaWYgKG9wdHMuc3RhbGUgPT09ICdvaycgfHwgb3B0cy5zdGFsZSA9PT0gJ3VwZGF0ZV9hZnRlcicpIHtcbiAgICAgICAgICBpZiAob3B0cy5zdGFsZSA9PT0gJ3VwZGF0ZV9hZnRlcicpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB1cGRhdGVWaWV3KHZpZXcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBxdWVyeVZpZXcodmlldywgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHN0YWxlIG5vdCBva1xuICAgICAgICAgIHJldHVybiB1cGRhdGVWaWV3KHZpZXcpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Vmlldyh2aWV3LCBvcHRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy5xdWVyeSA9IGZ1bmN0aW9uIChmdW4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgb3B0cyA9IHV0aWxzLmV4dGVuZCh0cnVlLCB7fSwgb3B0cyk7XG5cbiAgaWYgKHR5cGVvZiBmdW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBmdW4gPSB7bWFwIDogZnVufTtcbiAgfVxuXG4gIHZhciBkYiA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHF1ZXJ5UHJvbWlzZWQoZGIsIGZ1biwgb3B0cyk7XG4gIH0pO1xuICB1dGlscy5wcm9taXNlZENhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5mdW5jdGlvbiBRdWVyeVBhcnNlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLnN0YXR1cyA9IDQwMDtcbiAgdGhpcy5uYW1lID0gJ3F1ZXJ5X3BhcnNlX2Vycm9yJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5lcnJvciA9IHRydWU7XG4gIHRyeSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUXVlcnlQYXJzZUVycm9yKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxudXRpbHMuaW5oZXJpdHMoUXVlcnlQYXJzZUVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIE5vdEZvdW5kRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLnN0YXR1cyA9IDQwNDtcbiAgdGhpcy5uYW1lID0gJ25vdF9mb3VuZCc7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuZXJyb3IgPSB0cnVlO1xuICB0cnkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdEZvdW5kRXJyb3IpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG51dGlscy5pbmhlcml0cyhOb3RGb3VuZEVycm9yLCBFcnJvcik7XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL1VzZXJzL2RhbGVoYXJ2ZXkvc3JjL3BvdWNoZGIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKVxufSx7XCIuL2NyZWF0ZS12aWV3XCI6NTIsXCIuL2V2YWxmdW5jXCI6NTMsXCIuL3Rhc2txdWV1ZVwiOjU3LFwiLi91dGlsc1wiOjU5LFwiL1VzZXJzL2RhbGVoYXJ2ZXkvc3JjL3BvdWNoZGIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCI6MzEsXCJwb3VjaGRiLWNvbGxhdGVcIjo1NX1dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIE1JTl9NQUdOSVRVREUgPSAtMzI0OyAvLyB2ZXJpZmllZCBieSAtTnVtYmVyLk1JTl9WQUxVRVxudmFyIE1BR05JVFVERV9ESUdJVFMgPSAzOyAvLyBkaXR0b1xudmFyIFNFUCA9ICcnOyAvLyBzZXQgdG8gJ18nIGZvciBlYXNpZXIgZGVidWdnaW5nIFxuXG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWxzJyk7XG5cbmV4cG9ydHMuY29sbGF0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGEgPSBleHBvcnRzLm5vcm1hbGl6ZUtleShhKTtcbiAgYiA9IGV4cG9ydHMubm9ybWFsaXplS2V5KGIpO1xuXG4gIHZhciBhaSA9IGNvbGxhdGlvbkluZGV4KGEpO1xuICB2YXIgYmkgPSBjb2xsYXRpb25JbmRleChiKTtcbiAgaWYgKChhaSAtIGJpKSAhPT0gMCkge1xuICAgIHJldHVybiBhaSAtIGJpO1xuICB9XG4gIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiAoYSA8IGIgPyAtMSA6IDEpO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gc3RyaW5nQ29sbGF0ZShhLCBiKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGFycmF5Q29sbGF0ZShhLCBiKSA6IG9iamVjdENvbGxhdGUoYSwgYik7XG59O1xuXG4vLyBjb3VjaCBjb25zaWRlcnMgbnVsbC9OYU4vSW5maW5pdHkvLUluZmluaXR5ID09PSB1bmRlZmluZWQsXG4vLyBmb3IgdGhlIHB1cnBvc2VzIG9mIG1hcHJlZHVjZSBpbmRleGVzLiBhbHNvLCBkYXRlcyBnZXQgc3RyaW5naWZpZWQuXG5leHBvcnRzLm5vcm1hbGl6ZUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgc3dpdGNoICh0eXBlb2Yga2V5KSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAoa2V5ID09PSBJbmZpbml0eSB8fCBrZXkgPT09IC1JbmZpbml0eSB8fCBpc05hTihrZXkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdmFyIG9yaWdLZXkgPSBrZXk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuICAgICAgICBrZXkgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGtleVtpXSA9IGV4cG9ydHMubm9ybWFsaXplS2V5KG9yaWdLZXlbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGtleS50b0pTT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSBudWxsKSB7IC8vIGdlbmVyaWMgb2JqZWN0XG4gICAgICAgIGtleSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrIGluIG9yaWdLZXkpIHtcbiAgICAgICAgICBpZiAob3JpZ0tleS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9yaWdLZXlba107XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAga2V5W2tdID0gZXhwb3J0cy5ub3JtYWxpemVLZXkodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICByZXR1cm4ga2V5O1xufTtcblxuZnVuY3Rpb24gaW5kZXhpZnkoa2V5KSB7XG4gIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBrZXkpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4ga2V5ID8gMSA6IDA7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gbnVtVG9JbmRleGFibGVTdHJpbmcoa2V5KTtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIC8vIFdlJ3ZlIHRvIGJlIHN1cmUgdGhhdCBrZXkgZG9lcyBub3QgY29udGFpbiBcXHUwMDAwXG4gICAgICAgIC8vIERvIG9yZGVyLXByZXNlcnZpbmcgcmVwbGFjZW1lbnRzOlxuICAgICAgICAvLyAwIC0+IDEsIDFcbiAgICAgICAgLy8gMSAtPiAxLCAyXG4gICAgICAgIC8vIDIgLT4gMiwgMlxuICAgICAgICByZXR1cm4ga2V5XG4gICAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDIvZywgJ1xcdTAwMDJcXHUwMDAyJylcbiAgICAgICAgICAucmVwbGFjZSgvXFx1MDAwMS9nLCAnXFx1MDAwMVxcdTAwMDInKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICdcXHUwMDAxXFx1MDAwMScpO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGtleSk7XG4gICAgICAgIHZhciBhcnIgPSBpc0FycmF5ID8ga2V5IDogT2JqZWN0LmtleXMoa2V5KTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZXhwb3J0cy50b0luZGV4YWJsZVN0cmluZyhhcnJbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIgb2JqS2V5ID0gYXJyW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGV4cG9ydHMudG9JbmRleGFibGVTdHJpbmcob2JqS2V5KSArXG4gICAgICAgICAgICAgICAgZXhwb3J0cy50b0luZGV4YWJsZVN0cmluZyhrZXlbb2JqS2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLy8gY29udmVydCB0aGUgZ2l2ZW4ga2V5IHRvIGEgc3RyaW5nIHRoYXQgd291bGQgYmUgYXBwcm9wcmlhdGVcbi8vIGZvciBsZXhpY2FsIHNvcnRpbmcsIGUuZy4gd2l0aGluIGEgZGF0YWJhc2UsIHdoZXJlIHRoZVxuLy8gc29ydGluZyBpcyB0aGUgc2FtZSBnaXZlbiBieSB0aGUgY29sbGF0ZSgpIGZ1bmN0aW9uLlxuZXhwb3J0cy50b0luZGV4YWJsZVN0cmluZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHplcm8gPSAnXFx1MDAwMCc7XG4gIGtleSA9IGV4cG9ydHMubm9ybWFsaXplS2V5KGtleSk7XG4gIHJldHVybiBjb2xsYXRpb25JbmRleChrZXkpICsgU0VQICsgaW5kZXhpZnkoa2V5KSArIHplcm87XG59O1xuXG5mdW5jdGlvbiBwYXJzZU51bWJlcihzdHIsIGkpIHtcbiAgdmFyIG9yaWdpbmFsSWR4ID0gaTtcbiAgdmFyIG51bTtcbiAgdmFyIHplcm8gPSBzdHJbaV0gPT09ICcxJztcbiAgaWYgKHplcm8pIHtcbiAgICBudW0gPSAwO1xuICAgIGkrKztcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmVnID0gc3RyW2ldID09PSAnMCc7XG4gICAgaSsrO1xuICAgIHZhciBudW1Bc1N0cmluZyA9ICcnO1xuICAgIHZhciBtYWdBc1N0cmluZyA9IHN0ci5zdWJzdHJpbmcoaSwgaSArIE1BR05JVFVERV9ESUdJVFMpO1xuICAgIHZhciBtYWduaXR1ZGUgPSBwYXJzZUludChtYWdBc1N0cmluZywgMTApICsgTUlOX01BR05JVFVERTtcbiAgICBpZiAobmVnKSB7XG4gICAgICBtYWduaXR1ZGUgPSAtbWFnbml0dWRlO1xuICAgIH1cbiAgICBpICs9IE1BR05JVFVERV9ESUdJVFM7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICAgIGlmIChjaCA9PT0gJ1xcdTAwMDAnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtQXNTdHJpbmcgKz0gY2g7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIG51bUFzU3RyaW5nID0gbnVtQXNTdHJpbmcuc3BsaXQoJy4nKTtcbiAgICBpZiAobnVtQXNTdHJpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgICBudW0gPSBwYXJzZUludChudW1Bc1N0cmluZywgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW0gPSBwYXJzZUZsb2F0KG51bUFzU3RyaW5nWzBdICsgJy4nICsgbnVtQXNTdHJpbmdbMV0pO1xuICAgIH1cbiAgICBpZiAobmVnKSB7XG4gICAgICBudW0gPSBudW0gLSAxMDtcbiAgICB9XG4gICAgaWYgKG1hZ25pdHVkZSAhPT0gMCkge1xuICAgICAgLy8gcGFyc2VGbG9hdCBpcyBtb3JlIHJlbGlhYmxlIHRoYW4gcG93IGR1ZSB0byByb3VuZGluZyBlcnJvcnNcbiAgICAgIC8vIGUuZy4gTnVtYmVyLk1BWF9WQUxVRSB3b3VsZCByZXR1cm4gSW5maW5pdHkgaWYgd2UgZGlkXG4gICAgICAvLyBudW0gKiBNYXRoLnBvdygxMCwgbWFnbml0dWRlKTtcbiAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtICsgJ2UnICsgbWFnbml0dWRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtudW06IG51bSwgbGVuZ3RoIDogaSAtIG9yaWdpbmFsSWR4fTtcbn1cblxuLy8gbW92ZSB1cCB0aGUgc3RhY2sgd2hpbGUgcGFyc2luZ1xuLy8gdGhpcyBmdW5jdGlvbiBtb3ZlZCBvdXRzaWRlIG9mIHBhcnNlSW5kZXhhYmxlU3RyaW5nIGZvciBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gcG9wKHN0YWNrLCBtZXRhU3RhY2spIHtcbiAgdmFyIG9iaiA9IHN0YWNrLnBvcCgpO1xuXG4gIGlmIChtZXRhU3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGxhc3RNZXRhRWxlbWVudCA9IG1ldGFTdGFja1ttZXRhU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKG9iaiA9PT0gbGFzdE1ldGFFbGVtZW50LmVsZW1lbnQpIHtcbiAgICAgIC8vIHBvcHBpbmcgYSBtZXRhLWVsZW1lbnQsIGUuZy4gYW4gb2JqZWN0IHdob3NlIHZhbHVlIGlzIGFub3RoZXIgb2JqZWN0XG4gICAgICBtZXRhU3RhY2sucG9wKCk7XG4gICAgICBsYXN0TWV0YUVsZW1lbnQgPSBtZXRhU3RhY2tbbWV0YVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IGxhc3RNZXRhRWxlbWVudC5lbGVtZW50O1xuICAgIHZhciBsYXN0RWxlbWVudEluZGV4ID0gbGFzdE1ldGFFbGVtZW50LmluZGV4O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50LnB1c2gob2JqKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RFbGVtZW50SW5kZXggPT09IHN0YWNrLmxlbmd0aCAtIDIpIHsgLy8gb2JqIHdpdGgga2V5K3ZhbHVlXG4gICAgICB2YXIga2V5ID0gc3RhY2sucG9wKCk7XG4gICAgICBlbGVtZW50W2tleV0gPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2gob2JqKTsgLy8gb2JqIHdpdGgga2V5IG9ubHlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5wYXJzZUluZGV4YWJsZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBtZXRhU3RhY2sgPSBbXTsgLy8gc3RhY2sgZm9yIGFycmF5cyBhbmQgb2JqZWN0c1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgY29sbGF0aW9uSW5kZXggPSBzdHJbaSsrXTtcbiAgICBpZiAoY29sbGF0aW9uSW5kZXggPT09ICdcXHUwMDAwJykge1xuICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3Aoc3RhY2ssIG1ldGFTdGFjayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKGNvbGxhdGlvbkluZGV4KSB7XG4gICAgICBjYXNlICcxJzpcbiAgICAgICAgc3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcyJzpcbiAgICAgICAgc3RhY2sucHVzaChzdHJbaV0gPT09ICcxJyk7XG4gICAgICAgIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICczJzpcbiAgICAgICAgdmFyIHBhcnNlZE51bSA9IHBhcnNlTnVtYmVyKHN0ciwgaSk7XG4gICAgICAgIHN0YWNrLnB1c2gocGFyc2VkTnVtLm51bSk7XG4gICAgICAgIGkgKz0gcGFyc2VkTnVtLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc0JzpcbiAgICAgICAgdmFyIHBhcnNlZFN0ciA9ICcnO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXHUwMDAwJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlZFN0ciArPSBjaDtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgcmV2ZXJzZSBvZiB0aGUgb3JkZXItcHJlc2VydmluZyByZXBsYWNlbWVudFxuICAgICAgICAvLyBhbGdvcml0aG0gKHNlZSBhYm92ZSlcbiAgICAgICAgcGFyc2VkU3RyID0gcGFyc2VkU3RyLnJlcGxhY2UoL1xcdTAwMDFcXHUwMDAxL2csICdcXHUwMDAwJylcbiAgICAgICAgICAucmVwbGFjZSgvXFx1MDAwMVxcdTAwMDIvZywgJ1xcdTAwMDEnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHUwMDAyXFx1MDAwMi9nLCAnXFx1MDAwMicpO1xuICAgICAgICBzdGFjay5wdXNoKHBhcnNlZFN0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnNSc6XG4gICAgICAgIHZhciBhcnJheUVsZW1lbnQgPSB7IGVsZW1lbnQ6IFtdLCBpbmRleDogc3RhY2subGVuZ3RoIH07XG4gICAgICAgIHN0YWNrLnB1c2goYXJyYXlFbGVtZW50LmVsZW1lbnQpO1xuICAgICAgICBtZXRhU3RhY2sucHVzaChhcnJheUVsZW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzYnOlxuICAgICAgICB2YXIgb2JqRWxlbWVudCA9IHsgZWxlbWVudDoge30sIGluZGV4OiBzdGFjay5sZW5ndGggfTtcbiAgICAgICAgc3RhY2sucHVzaChvYmpFbGVtZW50LmVsZW1lbnQpO1xuICAgICAgICBtZXRhU3RhY2sucHVzaChvYmpFbGVtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2JhZCBjb2xsYXRpb25JbmRleCBvciB1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgaW5wdXQ6ICcgKyBjb2xsYXRpb25JbmRleCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBhcnJheUNvbGxhdGUoYSwgYikge1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzb3J0ID0gZXhwb3J0cy5jb2xsYXRlKGFbaV0sIGJbaV0pO1xuICAgIGlmIChzb3J0ICE9PSAwKSB7XG4gICAgICByZXR1cm4gc29ydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpID8gMCA6XG4gICAgKGEubGVuZ3RoID4gYi5sZW5ndGgpID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gc3RyaW5nQ29sbGF0ZShhLCBiKSB7XG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhbGVoYXJ2ZXkvcG91Y2hkYi9pc3N1ZXMvNDBcbiAgLy8gVGhpcyBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgQ291Y2hEQiBpbXBsZW1lbnRhdGlvbiwgYnV0IGl0cyB0aGVcbiAgLy8gYmVzdCB3ZSBjYW4gZG8gZm9yIG5vd1xuICByZXR1cm4gKGEgPT09IGIpID8gMCA6ICgoYSA+IGIpID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIG9iamVjdENvbGxhdGUoYSwgYikge1xuICB2YXIgYWsgPSBPYmplY3Qua2V5cyhhKSwgYmsgPSBPYmplY3Qua2V5cyhiKTtcbiAgdmFyIGxlbiA9IE1hdGgubWluKGFrLmxlbmd0aCwgYmsubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIEZpcnN0IHNvcnQgdGhlIGtleXNcbiAgICB2YXIgc29ydCA9IGV4cG9ydHMuY29sbGF0ZShha1tpXSwgYmtbaV0pO1xuICAgIGlmIChzb3J0ICE9PSAwKSB7XG4gICAgICByZXR1cm4gc29ydDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIGtleXMgYXJlIGVxdWFsIHNvcnQgdGhlIHZhbHVlc1xuICAgIHNvcnQgPSBleHBvcnRzLmNvbGxhdGUoYVtha1tpXV0sIGJbYmtbaV1dKTtcbiAgICBpZiAoc29ydCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHNvcnQ7XG4gICAgfVxuXG4gIH1cbiAgcmV0dXJuIChhay5sZW5ndGggPT09IGJrLmxlbmd0aCkgPyAwIDpcbiAgICAoYWsubGVuZ3RoID4gYmsubGVuZ3RoKSA/IDEgOiAtMTtcbn1cbi8vIFRoZSBjb2xsYXRpb24gaXMgZGVmaW5lZCBieSBlcmxhbmdzIG9yZGVyZWQgdGVybXNcbi8vIHRoZSBhdG9tcyBudWxsLCB0cnVlLCBmYWxzZSBjb21lIGZpcnN0LCB0aGVuIG51bWJlcnMsIHN0cmluZ3MsXG4vLyBhcnJheXMsIHRoZW4gb2JqZWN0c1xuLy8gbnVsbC91bmRlZmluZWQvTmFOL0luZmluaXR5Ly1JbmZpbml0eSBhcmUgYWxsIGNvbnNpZGVyZWQgbnVsbFxuZnVuY3Rpb24gY29sbGF0aW9uSW5kZXgoeCkge1xuICB2YXIgaWQgPSBbJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZycsICdvYmplY3QnXTtcbiAgdmFyIGlkeCA9IGlkLmluZGV4T2YodHlwZW9mIHgpO1xuICAvL2ZhbHNlIGlmIC0xIG90aGVyd2lzZSB0cnVlLCBidXQgZmFzdCEhISExXG4gIGlmICh+aWR4KSB7XG4gICAgaWYgKHggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICAgIHJldHVybiBpZHggPCAzID8gKGlkeCArIDIpIDogKGlkeCArIDMpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIDU7XG4gIH1cbn1cblxuLy8gY29udmVyc2lvbjpcbi8vIHggeXl5IHp6Li4uenpcbi8vIHggPSAwIGZvciBuZWdhdGl2ZSwgMSBmb3IgMCwgMiBmb3IgcG9zaXRpdmVcbi8vIHkgPSBleHBvbmVudCAoZm9yIG5lZ2F0aXZlIG51bWJlcnMgbmVnYXRlZCkgbW92ZWQgc28gdGhhdCBpdCdzID49IDBcbi8vIHogPSBtYW50aXNzZVxuZnVuY3Rpb24gbnVtVG9JbmRleGFibGVTdHJpbmcobnVtKSB7XG5cbiAgaWYgKG51bSA9PT0gMCkge1xuICAgIHJldHVybiAnMSc7XG4gIH1cblxuICAvLyBjb252ZXJ0IG51bWJlciB0byBleHBvbmVudGlhbCBmb3JtYXQgZm9yIGVhc2llciBhbmRcbiAgLy8gbW9yZSBzdWNjaW5jdCBzdHJpbmcgc29ydGluZ1xuICB2YXIgZXhwRm9ybWF0ID0gbnVtLnRvRXhwb25lbnRpYWwoKS5zcGxpdCgvZVxcKz8vKTtcbiAgdmFyIG1hZ25pdHVkZSA9IHBhcnNlSW50KGV4cEZvcm1hdFsxXSwgMTApO1xuXG4gIHZhciBuZWcgPSBudW0gPCAwO1xuXG4gIHZhciByZXN1bHQgPSBuZWcgPyAnMCcgOiAnMic7XG5cbiAgLy8gZmlyc3Qgc29ydCBieSBtYWduaXR1ZGVcbiAgLy8gaXQncyBlYXNpZXIgaWYgYWxsIG1hZ25pdHVkZXMgYXJlIHBvc2l0aXZlXG4gIHZhciBtYWdGb3JDb21wYXJpc29uID0gKChuZWcgPyAtbWFnbml0dWRlIDogbWFnbml0dWRlKSAtIE1JTl9NQUdOSVRVREUpO1xuICB2YXIgbWFnU3RyaW5nID0gdXRpbHMucGFkTGVmdCgobWFnRm9yQ29tcGFyaXNvbikudG9TdHJpbmcoKSwgJzAnLCBNQUdOSVRVREVfRElHSVRTKTtcblxuICByZXN1bHQgKz0gU0VQICsgbWFnU3RyaW5nO1xuXG4gIC8vIHRoZW4gc29ydCBieSB0aGUgZmFjdG9yXG4gIHZhciBmYWN0b3IgPSBNYXRoLmFicyhwYXJzZUZsb2F0KGV4cEZvcm1hdFswXSkpOyAvLyBbMS4uMTApXG4gIGlmIChuZWcpIHsgLy8gZm9yIG5lZ2F0aXZlIHJldmVyc2Ugb3JkZXJpbmdcbiAgICBmYWN0b3IgPSAxMCAtIGZhY3RvcjtcbiAgfVxuXG4gIHZhciBmYWN0b3JTdHIgPSBmYWN0b3IudG9GaXhlZCgyMCk7XG5cbiAgLy8gc3RyaXAgemVyb3MgZnJvbSB0aGUgZW5kXG4gIGZhY3RvclN0ciA9IGZhY3RvclN0ci5yZXBsYWNlKC9cXC4/MCskLywgJycpO1xuXG4gIHJlc3VsdCArPSBTRVAgKyBmYWN0b3JTdHI7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxufSx7XCIuL3V0aWxzXCI6NTZ9XSw1NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHBhZChzdHIsIHBhZFdpdGgsIHVwVG9MZW5ndGgpIHtcbiAgdmFyIHBhZGRpbmcgPSAnJztcbiAgdmFyIHRhcmdldExlbmd0aCA9IHVwVG9MZW5ndGggLSBzdHIubGVuZ3RoO1xuICB3aGlsZSAocGFkZGluZy5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICBwYWRkaW5nICs9IHBhZFdpdGg7XG4gIH1cbiAgcmV0dXJuIHBhZGRpbmc7XG59XG5cbmV4cG9ydHMucGFkTGVmdCA9IGZ1bmN0aW9uIChzdHIsIHBhZFdpdGgsIHVwVG9MZW5ndGgpIHtcbiAgdmFyIHBhZGRpbmcgPSBwYWQoc3RyLCBwYWRXaXRoLCB1cFRvTGVuZ3RoKTtcbiAgcmV0dXJuIHBhZGRpbmcgKyBzdHI7XG59O1xuXG5leHBvcnRzLnBhZFJpZ2h0ID0gZnVuY3Rpb24gKHN0ciwgcGFkV2l0aCwgdXBUb0xlbmd0aCkge1xuICB2YXIgcGFkZGluZyA9IHBhZChzdHIsIHBhZFdpdGgsIHVwVG9MZW5ndGgpO1xuICByZXR1cm4gc3RyICsgcGFkZGluZztcbn07XG5cbmV4cG9ydHMuc3RyaW5nTGV4Q29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgdmFyIGFMZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGJMZW4gPSBiLmxlbmd0aDtcblxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGFMZW47IGkrKykge1xuICAgIGlmIChpID09PSBiTGVuKSB7XG4gICAgICAvLyBiIGlzIHNob3J0ZXIgc3Vic3RyaW5nIG9mIGFcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgYUNoYXIgPSBhLmNoYXJBdChpKTtcbiAgICB2YXIgYkNoYXIgPSBiLmNoYXJBdChpKTtcbiAgICBpZiAoYUNoYXIgIT09IGJDaGFyKSB7XG4gICAgICByZXR1cm4gYUNoYXIgPCBiQ2hhciA/IC0xIDogMTtcbiAgICB9XG4gIH1cblxuICBpZiAoYUxlbiA8IGJMZW4pIHtcbiAgICAvLyBhIGlzIHNob3J0ZXIgc3Vic3RyaW5nIG9mIGJcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gMDtcbn07XG5cbi8qXG4gKiByZXR1cm5zIHRoZSBkZWNpbWFsIGZvcm0gZm9yIHRoZSBnaXZlbiBpbnRlZ2VyLCBpLmUuIHdyaXRlc1xuICogb3V0IGFsbCB0aGUgZGlnaXRzIChpbiBiYXNlLTEwKSBpbnN0ZWFkIG9mIHVzaW5nIHNjaWVudGlmaWMgbm90YXRpb25cbiAqL1xuZXhwb3J0cy5pbnRUb0RlY2ltYWxGb3JtID0gZnVuY3Rpb24gKGludCkge1xuXG4gIHZhciBpc05lZyA9IGludCA8IDA7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBkbyB7XG4gICAgdmFyIHJlbWFpbmRlciA9IGlzTmVnID8gLU1hdGguY2VpbChpbnQgJSAxMCkgOiBNYXRoLmZsb29yKGludCAlIDEwKTtcblxuICAgIHJlc3VsdCA9IHJlbWFpbmRlciArIHJlc3VsdDtcbiAgICBpbnQgPSBpc05lZyA/IE1hdGguY2VpbChpbnQgLyAxMCkgOiBNYXRoLmZsb29yKGludCAvIDEwKTtcbiAgfSB3aGlsZSAoaW50KTtcblxuXG4gIGlmIChpc05lZyAmJiByZXN1bHQgIT09ICcwJykge1xuICAgIHJlc3VsdCA9ICctJyArIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xufSx7fV0sNTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuLypcbiAqIFNpbXBsZSB0YXNrIHF1ZXVlIHRvIHNlcXVlbnRpYWxpemUgYWN0aW9ucy4gQXNzdW1lcyBjYWxsYmFja3Mgd2lsbCBldmVudHVhbGx5IGZpcmUgKG9uY2UpLlxuICovXG5cbnZhciBQcm9taXNlID0gX2RlcmVxXygnLi91dGlscycpLlByb21pc2U7XG5cbmZ1bmN0aW9uIFRhc2tRdWV1ZSgpIHtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwpIHtmdWxmaWxsKCk7IH0pO1xufVxuVGFza1F1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocHJvbWlzZUZhY3RvcnkpIHtcbiAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgIC8vIGp1c3QgcmVjb3ZlclxuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvbWlzZUZhY3RvcnkoKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzLnByb21pc2U7XG59O1xuVGFza1F1ZXVlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb21pc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2tRdWV1ZTtcblxufSx7XCIuL3V0aWxzXCI6NTl9XSw1ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG52YXIgUHJvbWlzZSA9IF9kZXJlcV8oJy4vdXRpbHMnKS5Qcm9taXNlO1xuXG4vLyB0aGlzIGlzIGVzc2VudGlhbGx5IHRoZSBcInVwZGF0ZSBzdWdhclwiIGZ1bmN0aW9uIGZyb20gZGFsZWhhcnZleS9wb3VjaGRiIzEzODhcbi8vIHRoZSBkaWZmRnVuIHRlbGxzIHVzIHdoYXQgZGVsdGEgdG8gYXBwbHkgdG8gdGhlIGRvYy4gIGl0IGVpdGhlciByZXR1cm5zXG4vLyB0aGUgZG9jLCBvciBmYWxzZSBpZiBpdCBkb2Vzbid0IG5lZWQgdG8gZG8gYW4gdXBkYXRlIGFmdGVyIGFsbFxuZnVuY3Rpb24gdXBzZXJ0KGRiLCBkb2NJZCwgZGlmZkZ1bikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xuICAgIGlmIChkb2NJZCAmJiB0eXBlb2YgZG9jSWQgPT09ICdvYmplY3QnKSB7XG4gICAgICBkb2NJZCA9IGRvY0lkLl9pZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2NJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdkb2MgaWQgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuXG4gICAgZGIuZ2V0KGRvY0lkLCBmdW5jdGlvbiAoZXJyLCBkb2MpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5zdGF0dXMgIT09IDQwNCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVsZmlsbCh0cnlBbmRQdXQoZGIsIGRpZmZGdW4oe19pZCA6IGRvY0lkfSksIGRpZmZGdW4pKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEb2MgPSBkaWZmRnVuKGRvYyk7XG4gICAgICBpZiAoIW5ld0RvYykge1xuICAgICAgICByZXR1cm4gZnVsZmlsbChkb2MpO1xuICAgICAgfVxuICAgICAgZnVsZmlsbCh0cnlBbmRQdXQoZGIsIG5ld0RvYywgZGlmZkZ1bikpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJ5QW5kUHV0KGRiLCBkb2MsIGRpZmZGdW4pIHtcbiAgcmV0dXJuIGRiLnB1dChkb2MpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIuc3RhdHVzICE9PSA0MDkpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHVwc2VydChkYiwgZG9jLCBkaWZmRnVuKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXBzZXJ0O1xuXG59LHtcIi4vdXRpbHNcIjo1OX1dLDU5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlID09PSAnZnVuY3Rpb24nKSB7XG4gIGV4cG9ydHMuUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xufSBlbHNlIHtcbiAgZXhwb3J0cy5Qcm9taXNlID0gX2RlcmVxXygnbGllJyk7XG59XG4vLyB1bmlxdWlmeSBhIGxpc3QsIHNpbWlsYXIgdG8gdW5kZXJzY29yZSdzIF8udW5pcVxuZXhwb3J0cy51bmlxID0gZnVuY3Rpb24gKGFycikge1xuICB2YXIgbWFwID0ge307XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgbWFwW2VsZW1lbnRdID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcblxuZXhwb3J0cy5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG5leHBvcnRzLmV4dGVuZCA9IF9kZXJlcV8oJ3BvdWNoZGItZXh0ZW5kJyk7XG52YXIgYXJnc2FycmF5ID0gX2RlcmVxXygnYXJnc2FycmF5Jyk7XG5cbmV4cG9ydHMucHJvbWlzZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2socmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgcmV0dXJuIGFyZ3NhcnJheShmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBjYiA9IGFyZ3MucG9wKCk7XG4gICAgdmFyIHByb21pc2UgPSBmdW4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXhwb3J0cy5wcm9taXNlZENhbGxiYWNrKHByb21pc2UsIGNiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH0pO1xufTtcblxuLy8gUHJvbWlzZSBmaW5hbGx5IHV0aWwgc2ltaWxhciB0byBRLmZpbmFsbHlcbmV4cG9ydHMuZmluID0gZnVuY3Rpb24gKHByb21pc2UsIGNiKSB7XG4gIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIHZhciBwcm9taXNlMiA9IGNiKCk7XG4gICAgaWYgKHR5cGVvZiBwcm9taXNlMi50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTIudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciBwcm9taXNlMiA9IGNiKCk7XG4gICAgaWYgKHR5cGVvZiBwcm9taXNlMi50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTIudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyByZWFzb247XG4gIH0pO1xufTtcblxuZXhwb3J0cy5zZXF1ZW50aWFsaXplID0gZnVuY3Rpb24gKHF1ZXVlLCBwcm9taXNlRmFjdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gcXVldWUuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlRmFjdG9yeS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbnZhciBjcnlwdG8gPSBfZGVyZXFfKCdjcnlwdG8nKTtcbnZhciBNZDUgPSBfZGVyZXFfKCdzcGFyay1tZDUnKTtcblxuZXhwb3J0cy5NRDUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghcHJvY2Vzcy5icm93c2VyKSB7XG4gICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoc3RyaW5nKS5kaWdlc3QoJ2hleCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNZDUuaGFzaChzdHJpbmcpO1xuICB9XG59O1xufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvVXNlcnMvZGFsZWhhcnZleS9zcmMvcG91Y2hkYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIvVXNlcnMvZGFsZWhhcnZleS9zcmMvcG91Y2hkYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjozMSxcImFyZ3NhcnJheVwiOjI4LFwiY3J5cHRvXCI6MjksXCJpbmhlcml0c1wiOjMyLFwibGllXCI6MzYsXCJwb3VjaGRiLWV4dGVuZFwiOjUxLFwic3BhcmstbWQ1XCI6NjB9XSw2MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKmpzaGludCBiaXR3aXNlOmZhbHNlKi9cbi8qZ2xvYmFsIHVuZXNjYXBlKi9cblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRFxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzICh3aXRoIHN1cHBvcnQgZm9yIHdlYiB3b3JrZXJzKVxuICAgICAgICB2YXIgZ2xvYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdsb2IgPSB3aW5kb3c7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2IgPSBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xvYi5TcGFya01ENSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qXG4gICAgICogRmFzdGVzdCBtZDUgaW1wbGVtZW50YXRpb24gYXJvdW5kIChKS00gbWQ1KVxuICAgICAqIENyZWRpdHM6IEpvc2VwaCBNeWVyc1xuICAgICAqXG4gICAgICogQHNlZSBodHRwOi8vd3d3Lm15ZXJzZGFpbHkub3JnL2pvc2VwaC9qYXZhc2NyaXB0L21kNS10ZXh0Lmh0bWxcbiAgICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL21kNS1zaG9vdG91dC83XG4gICAgICovXG5cbiAgICAvKiB0aGlzIGZ1bmN0aW9uIGlzIG11Y2ggZmFzdGVyLFxuICAgICAgc28gaWYgcG9zc2libGUgd2UgdXNlIGl0LiBTb21lIElFc1xuICAgICAgYXJlIHRoZSBvbmx5IG9uZXMgSSBrbm93IG9mIHRoYXRcbiAgICAgIG5lZWQgdGhlIGlkaW90aWMgc2Vjb25kIGZ1bmN0aW9uLFxuICAgICAgZ2VuZXJhdGVkIGJ5IGFuIGlmIGNsYXVzZS4gICovXG4gICAgdmFyIGFkZDMyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhICsgYikgJiAweEZGRkZGRkZGO1xuICAgIH0sXG5cbiAgICBjbW4gPSBmdW5jdGlvbiAocSwgYSwgYiwgeCwgcywgdCkge1xuICAgICAgICBhID0gYWRkMzIoYWRkMzIoYSwgcSksIGFkZDMyKHgsIHQpKTtcbiAgICAgICAgcmV0dXJuIGFkZDMyKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gICAgfSxcblxuICAgIGZmID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGNtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgfSxcblxuICAgIGdnID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGNtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgfSxcblxuICAgIGhoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xuICAgIH0sXG5cbiAgICBpaSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBjbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICAgIH0sXG5cbiAgICBtZDVjeWNsZSA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHZhciBhID0geFswXSxcbiAgICAgICAgICAgIGIgPSB4WzFdLFxuICAgICAgICAgICAgYyA9IHhbMl0sXG4gICAgICAgICAgICBkID0geFszXTtcblxuICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwga1swXSwgNywgLTY4MDg3NjkzNik7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBrWzFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBrWzJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGtbM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGtbNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGtbNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBrWzddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGtbOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywga1s5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGtbMTBdLCAxNywgLTQyMDYzKTtcbiAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGtbMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwga1sxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywga1sxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwga1sxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBrWzE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuXG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGtbNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGtbMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGtbNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywga1sxMF0sIDksIDM4MDE2MDgzKTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBrWzRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzldLCA1LCA1Njg0NDY0MzgpO1xuICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywga1sxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGtbOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGtbMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBrWzJdLCA5LCAtNTE0MDM3ODQpO1xuICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwga1s3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwga1sxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGtbNV0sIDQsIC0zNzg1NTgpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1s4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGtbMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBrWzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBrWzFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBrWzRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBrWzddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBrWzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGtbMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1swXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwga1szXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwga1s2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGtbOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1sxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGtbMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGtbMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwga1swXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBrWzddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBrWzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGtbNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwga1sxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywga1szXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGtbMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwga1sxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGtbOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywga1sxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwga1s2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGtbMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBrWzRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGtbMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwga1syXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBrWzldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICAgICAgeFswXSA9IGFkZDMyKGEsIHhbMF0pO1xuICAgICAgICB4WzFdID0gYWRkMzIoYiwgeFsxXSk7XG4gICAgICAgIHhbMl0gPSBhZGQzMihjLCB4WzJdKTtcbiAgICAgICAgeFszXSA9IGFkZDMyKGQsIHhbM10pO1xuICAgIH0sXG5cbiAgICAvKiB0aGVyZSBuZWVkcyB0byBiZSBzdXBwb3J0IGZvciBVbmljb2RlIGhlcmUsXG4gICAgICAgKiB1bmxlc3Mgd2UgcHJldGVuZCB0aGF0IHdlIGNhbiByZWRlZmluZSB0aGUgTUQtNVxuICAgICAgICogYWxnb3JpdGhtIGZvciBtdWx0aS1ieXRlIGNoYXJhY3RlcnMgKHBlcmhhcHNcbiAgICAgICAqIGJ5IGFkZGluZyBldmVyeSBmb3VyIDE2LWJpdCBjaGFyYWN0ZXJzIGFuZFxuICAgICAgICogc2hvcnRlbmluZyB0aGUgc3VtIHRvIDMyIGJpdHMpLiBPdGhlcndpc2VcbiAgICAgICAqIEkgc3VnZ2VzdCBwZXJmb3JtaW5nIE1ELTUgYXMgaWYgZXZlcnkgY2hhcmFjdGVyXG4gICAgICAgKiB3YXMgdHdvIGJ5dGVzLS1lLmcuLCAwMDQwIDAwMjUgPSBAJS0tYnV0IHRoZW5cbiAgICAgICAqIGhvdyB3aWxsIGFuIG9yZGluYXJ5IE1ELTUgc3VtIGJlIG1hdGNoZWQ/XG4gICAgICAgKiBUaGVyZSBpcyBubyB3YXkgdG8gc3RhbmRhcmRpemUgdGV4dCB0byBzb21ldGhpbmdcbiAgICAgICAqIGxpa2UgVVRGLTggYmVmb3JlIHRyYW5zZm9ybWF0aW9uOyBzcGVlZCBjb3N0IGlzXG4gICAgICAgKiB1dHRlcmx5IHByb2hpYml0aXZlLiBUaGUgSmF2YVNjcmlwdCBzdGFuZGFyZFxuICAgICAgICogaXRzZWxmIG5lZWRzIHRvIGxvb2sgYXQgdGhpczogaXQgc2hvdWxkIHN0YXJ0XG4gICAgICAgKiBwcm92aWRpbmcgYWNjZXNzIHRvIHN0cmluZ3MgYXMgcHJlZm9ybWVkIFVURi04XG4gICAgICAgKiA4LWJpdCB1bnNpZ25lZCB2YWx1ZSBhcnJheXMuXG4gICAgICAgKi9cbiAgICBtZDVibGsgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgbWQ1YmxrcyA9IFtdLFxuICAgICAgICAgICAgaTsgLyogQW5keSBLaW5nIHNhaWQgZG8gaXQgdGhpcyB3YXkuICovXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDQpIHtcbiAgICAgICAgICAgIG1kNWJsa3NbaSA+PiAyXSA9IHMuY2hhckNvZGVBdChpKSArIChzLmNoYXJDb2RlQXQoaSArIDEpIDw8IDgpICsgKHMuY2hhckNvZGVBdChpICsgMikgPDwgMTYpICsgKHMuY2hhckNvZGVBdChpICsgMykgPDwgMjQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZDVibGtzO1xuICAgIH0sXG5cbiAgICBtZDVibGtfYXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgbWQ1YmxrcyA9IFtdLFxuICAgICAgICAgICAgaTsgLyogQW5keSBLaW5nIHNhaWQgZG8gaXQgdGhpcyB3YXkuICovXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDQpIHtcbiAgICAgICAgICAgIG1kNWJsa3NbaSA+PiAyXSA9IGFbaV0gKyAoYVtpICsgMV0gPDwgOCkgKyAoYVtpICsgMl0gPDwgMTYpICsgKGFbaSArIDNdIDw8IDI0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWQ1YmxrcztcbiAgICB9LFxuXG4gICAgbWQ1MSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBuID0gcy5sZW5ndGgsXG4gICAgICAgICAgICBzdGF0ZSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICB0YWlsLFxuICAgICAgICAgICAgdG1wLFxuICAgICAgICAgICAgbG8sXG4gICAgICAgICAgICBoaTtcblxuICAgICAgICBmb3IgKGkgPSA2NDsgaSA8PSBuOyBpICs9IDY0KSB7XG4gICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgbWQ1YmxrKHMuc3Vic3RyaW5nKGkgLSA2NCwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gcy5zdWJzdHJpbmcoaSAtIDY0KTtcbiAgICAgICAgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgIHRhaWwgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGFpbFtpID4+IDJdIHw9IHMuY2hhckNvZGVBdChpKSA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgfVxuICAgICAgICB0YWlsW2kgPj4gMl0gfD0gMHg4MCA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgaWYgKGkgPiA1NSkge1xuICAgICAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIHRhaWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0YWlsW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJld2FyZSB0aGF0IHRoZSBmaW5hbCBsZW5ndGggbWlnaHQgbm90IGZpdCBpbiAzMiBiaXRzIHNvIHdlIHRha2UgY2FyZSBvZiB0aGF0XG4gICAgICAgIHRtcCA9IG4gKiA4O1xuICAgICAgICB0bXAgPSB0bXAudG9TdHJpbmcoMTYpLm1hdGNoKC8oLio/KSguezAsOH0pJC8pO1xuICAgICAgICBsbyA9IHBhcnNlSW50KHRtcFsyXSwgMTYpO1xuICAgICAgICBoaSA9IHBhcnNlSW50KHRtcFsxXSwgMTYpIHx8IDA7XG5cbiAgICAgICAgdGFpbFsxNF0gPSBsbztcbiAgICAgICAgdGFpbFsxNV0gPSBoaTtcblxuICAgICAgICBtZDVjeWNsZShzdGF0ZSwgdGFpbCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgbWQ1MV9hcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBuID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBzdGF0ZSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICB0YWlsLFxuICAgICAgICAgICAgdG1wLFxuICAgICAgICAgICAgbG8sXG4gICAgICAgICAgICBoaTtcblxuICAgICAgICBmb3IgKGkgPSA2NDsgaSA8PSBuOyBpICs9IDY0KSB7XG4gICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgbWQ1YmxrX2FycmF5KGEuc3ViYXJyYXkoaSAtIDY0LCBpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IHN1cmUgaWYgaXQgaXMgYSBidWcsIGhvd2V2ZXIgSUUxMCB3aWxsIGFsd2F5cyBwcm9kdWNlIGEgc3ViIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgcGFyZW50IGFycmF5IGlmIHRoZSBzdWIgYXJyYXkgc3BlY2lmaWVkIHN0YXJ0c1xuICAgICAgICAvLyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgcGFyZW50IGFycmF5IC0gd2VpcmQuXG4gICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzcxNDUyL3R5cGVkLWFycmF5LXN1YmFycmF5LWlzc3VlXG4gICAgICAgIGEgPSAoaSAtIDY0KSA8IG4gPyBhLnN1YmFycmF5KGkgLSA2NCkgOiBuZXcgVWludDhBcnJheSgwKTtcblxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgdGFpbCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gYVtpXSA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWxbaSA+PiAyXSB8PSAweDgwIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICBpZiAoaSA+IDU1KSB7XG4gICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgdGFpbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHRhaWxbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmV3YXJlIHRoYXQgdGhlIGZpbmFsIGxlbmd0aCBtaWdodCBub3QgZml0IGluIDMyIGJpdHMgc28gd2UgdGFrZSBjYXJlIG9mIHRoYXRcbiAgICAgICAgdG1wID0gbiAqIDg7XG4gICAgICAgIHRtcCA9IHRtcC50b1N0cmluZygxNikubWF0Y2goLyguKj8pKC57MCw4fSkkLyk7XG4gICAgICAgIGxvID0gcGFyc2VJbnQodG1wWzJdLCAxNik7XG4gICAgICAgIGhpID0gcGFyc2VJbnQodG1wWzFdLCAxNikgfHwgMDtcblxuICAgICAgICB0YWlsWzE0XSA9IGxvO1xuICAgICAgICB0YWlsWzE1XSA9IGhpO1xuXG4gICAgICAgIG1kNWN5Y2xlKHN0YXRlLCB0YWlsKTtcblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcblxuICAgIGhleF9jaHIgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnXSxcblxuICAgIHJoZXggPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgcyA9ICcnLFxuICAgICAgICAgICAgajtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xuICAgICAgICAgICAgcyArPSBoZXhfY2hyWyhuID4+IChqICogOCArIDQpKSAmIDB4MEZdICsgaGV4X2NoclsobiA+PiAoaiAqIDgpKSAmIDB4MEZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH0sXG5cbiAgICBoZXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHhbaV0gPSByaGV4KHhbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBtZDUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gaGV4KG1kNTEocykpO1xuICAgIH0sXG5cblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogU3BhcmtNRDUgT09QIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgY2xhc3MgdG8gcGVyZm9ybSBhbiBpbmNyZW1lbnRhbCBtZDUsIG90aGVyd2lzZSB1c2UgdGhlXG4gICAgICogc3RhdGljIG1ldGhvZHMgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBTcGFya01ENSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2FsbCByZXNldCB0byBpbml0IHRoZSBpbnN0YW5jZVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuXG4gICAgLy8gSW4gc29tZSBjYXNlcyB0aGUgZmFzdCBhZGQzMiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZC4uXG4gICAgaWYgKG1kNSgnaGVsbG8nKSAhPT0gJzVkNDE0MDJhYmM0YjJhNzZiOTcxOWQ5MTEwMTdjNTkyJykge1xuICAgICAgICBhZGQzMiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpLFxuICAgICAgICAgICAgICAgIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICAgICAgICAgICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgc3RyaW5nLlxuICAgICAqIEEgY29udmVyc2lvbiB3aWxsIGJlIGFwcGxpZWQgaWYgYW4gdXRmOCBzdHJpbmcgaXMgZGV0ZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gYmUgYXBwZW5kZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1fSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gY29udmVydHMgdGhlIHN0cmluZyB0byB1dGY4IGJ5dGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoL1tcXHUwMDgwLVxcdUZGRkZdLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZW4gYXBwZW5kIGFzIGJpbmFyeVxuICAgICAgICB0aGlzLmFwcGVuZEJpbmFyeShzdHIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgYmluYXJ5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50cyBUaGUgYmluYXJ5IHN0cmluZyB0byBiZSBhcHBlbmRlZFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUuYXBwZW5kQmluYXJ5ID0gZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX2J1ZmYgKz0gY29udGVudHM7XG4gICAgICAgIHRoaXMuX2xlbmd0aCArPSBjb250ZW50cy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX2J1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKGkgPSA2NDsgaSA8PSBsZW5ndGg7IGkgKz0gNjQpIHtcbiAgICAgICAgICAgIG1kNWN5Y2xlKHRoaXMuX3N0YXRlLCBtZDVibGsodGhpcy5fYnVmZi5zdWJzdHJpbmcoaSAtIDY0LCBpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYnVmZiA9IHRoaXMuX2J1ZmYuc3Vic3RyKGkgLSA2NCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIHRoZSBpbmNyZW1lbnRhbCBjb21wdXRhdGlvbiwgcmVzZXRpbmcgdGhlIGludGVybmFsIHN0YXRlIGFuZFxuICAgICAqIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICAgICAqIFVzZSB0aGUgcmF3IHBhcmFtZXRlciB0byBvYnRhaW4gdGhlIHJhdyByZXN1bHQgaW5zdGVhZCBvZiB0aGUgaGV4IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3IFRydWUgdG8gZ2V0IHRoZSByYXcgcmVzdWx0LCBmYWxzZSB0byBnZXQgdGhlIGhleCByZXN1bHRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX0gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgIHZhciBidWZmID0gdGhpcy5fYnVmZixcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHRhaWwgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICByZXQ7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gYnVmZi5jaGFyQ29kZUF0KGkpIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmluaXNoKHRhaWwsIGxlbmd0aCk7XG4gICAgICAgIHJldCA9ICEhcmF3ID8gdGhpcy5fc3RhdGUgOiBoZXgodGhpcy5fc3RhdGUpO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggdGhlIGZpbmFsIGNhbGN1bGF0aW9uIGJhc2VkIG9uIHRoZSB0YWlsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gIHRhaWwgICBUaGUgdGFpbCAod2lsbCBiZSBtb2RpZmllZClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHJlbWFpbmluZyBidWZmZXJcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICh0YWlsLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGkgPSBsZW5ndGgsXG4gICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICBsbyxcbiAgICAgICAgICAgIGhpO1xuXG4gICAgICAgIHRhaWxbaSA+PiAyXSB8PSAweDgwIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICBpZiAoaSA+IDU1KSB7XG4gICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9zdGF0ZSwgdGFpbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHRhaWxbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gdGhlIGZpbmFsIGNvbXB1dGF0aW9uIGJhc2VkIG9uIHRoZSB0YWlsIGFuZCBsZW5ndGhcbiAgICAgICAgLy8gQmV3YXJlIHRoYXQgdGhlIGZpbmFsIGxlbmd0aCBtYXkgbm90IGZpdCBpbiAzMiBiaXRzIHNvIHdlIHRha2UgY2FyZSBvZiB0aGF0XG4gICAgICAgIHRtcCA9IHRoaXMuX2xlbmd0aCAqIDg7XG4gICAgICAgIHRtcCA9IHRtcC50b1N0cmluZygxNikubWF0Y2goLyguKj8pKC57MCw4fSkkLyk7XG4gICAgICAgIGxvID0gcGFyc2VJbnQodG1wWzJdLCAxNik7XG4gICAgICAgIGhpID0gcGFyc2VJbnQodG1wWzFdLCAxNikgfHwgMDtcblxuICAgICAgICB0YWlsWzE0XSA9IGxvO1xuICAgICAgICB0YWlsWzE1XSA9IGhpO1xuICAgICAgICBtZDVjeWNsZSh0aGlzLl9zdGF0ZSwgdGFpbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmYgPSBcIlwiO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgbWVtb3J5IHVzZWQgYnkgdGhlIGluY3JlbWVudGFsIGJ1ZmZlciBhbmQgb3RoZXIgYWRpdGlvbmFsXG4gICAgICogcmVzb3VyY2VzLiBJZiB5b3UgcGxhbiB0byB1c2UgdGhlIGluc3RhbmNlIGFnYWluLCB1c2UgcmVzZXQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXRlO1xuICAgICAgICBkZWxldGUgdGhpcy5fYnVmZjtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xlbmd0aDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgbWQ1IGhhc2ggb24gYSBzdHJpbmcuXG4gICAgICogQSBjb252ZXJzaW9uIHdpbGwgYmUgYXBwbGllZCBpZiB1dGY4IHN0cmluZyBpcyBkZXRlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgc3RyIFRoZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJhdyBUcnVlIHRvIGdldCB0aGUgcmF3IHJlc3VsdCwgZmFsc2UgdG8gZ2V0IHRoZSBoZXggcmVzdWx0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9IFRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBTcGFya01ENS5oYXNoID0gZnVuY3Rpb24gKHN0ciwgcmF3KSB7XG4gICAgICAgIC8vIGNvbnZlcnRzIHRoZSBzdHJpbmcgdG8gdXRmOCBieXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKC9bXFx1MDA4MC1cXHVGRkZGXS8udGVzdChzdHIpKSB7XG4gICAgICAgICAgICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzaCA9IG1kNTEoc3RyKTtcblxuICAgICAgICByZXR1cm4gISFyYXcgPyBoYXNoIDogaGV4KGhhc2gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgbWQ1IGhhc2ggb24gYSBiaW5hcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb250ZW50IFRoZSBiaW5hcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByYXcgICAgIFRydWUgdG8gZ2V0IHRoZSByYXcgcmVzdWx0LCBmYWxzZSB0byBnZXQgdGhlIGhleCByZXN1bHRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX0gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1Lmhhc2hCaW5hcnkgPSBmdW5jdGlvbiAoY29udGVudCwgcmF3KSB7XG4gICAgICAgIHZhciBoYXNoID0gbWQ1MShjb250ZW50KTtcblxuICAgICAgICByZXR1cm4gISFyYXcgPyBoYXNoIDogaGV4KGhhc2gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcGFya01ENSBPT1AgaW1wbGVtZW50YXRpb24gZm9yIGFycmF5IGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBjbGFzcyB0byBwZXJmb3JtIGFuIGluY3JlbWVudGFsIG1kNSBPTkxZIGZvciBhcnJheSBidWZmZXJzLlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjYWxsIHJlc2V0IHRvIGluaXQgdGhlIGluc3RhbmNlXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhbiBhcnJheSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnIgVGhlIGFycmF5IHRvIGJlIGFwcGVuZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTcGFya01ENS5BcnJheUJ1ZmZlcn0gVGhlIGluc3RhbmNlIGl0c2VsZlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIC8vIFRPRE86IHdlIGNvdWxkIGF2b2lkIHRoZSBjb25jYXRlbmF0aW9uIGhlcmUgYnV0IHRoZSBhbGdvcml0aG0gd291bGQgYmUgbW9yZSBjb21wbGV4XG4gICAgICAgIC8vICAgICAgIGlmIHlvdSBmaW5kIHlvdXJzZWxmIG5lZWRpbmcgZXh0cmEgcGVyZm9ybWFuY2UsIHBsZWFzZSBtYWtlIGEgUFIuXG4gICAgICAgIHZhciBidWZmID0gdGhpcy5fY29uY2F0QXJyYXlCdWZmZXIodGhpcy5fYnVmZiwgYXJyKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICB0aGlzLl9sZW5ndGggKz0gYXJyLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gNjQ7IGkgPD0gbGVuZ3RoOyBpICs9IDY0KSB7XG4gICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9zdGF0ZSwgbWQ1YmxrX2FycmF5KGJ1ZmYuc3ViYXJyYXkoaSAtIDY0LCBpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWRzIElFMTAgd2VpcmRuZXNzIChkb2N1bWVudGVkIGFib3ZlKVxuICAgICAgICB0aGlzLl9idWZmID0gKGkgLSA2NCkgPCBsZW5ndGggPyBidWZmLnN1YmFycmF5KGkgLSA2NCkgOiBuZXcgVWludDhBcnJheSgwKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluaXNoZXMgdGhlIGluY3JlbWVudGFsIGNvbXB1dGF0aW9uLCByZXNldGluZyB0aGUgaW50ZXJuYWwgc3RhdGUgYW5kXG4gICAgICogcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gICAgICogVXNlIHRoZSByYXcgcGFyYW1ldGVyIHRvIG9idGFpbiB0aGUgcmF3IHJlc3VsdCBpbnN0ZWFkIG9mIHRoZSBoZXggb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByYXcgVHJ1ZSB0byBnZXQgdGhlIHJhdyByZXN1bHQsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHJlc3VsdFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfEFycmF5fSBUaGUgcmVzdWx0XG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgdmFyIGJ1ZmYgPSB0aGlzLl9idWZmLFxuICAgICAgICAgICAgbGVuZ3RoID0gYnVmZi5sZW5ndGgsXG4gICAgICAgICAgICB0YWlsID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHJldDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRhaWxbaSA+PiAyXSB8PSBidWZmW2ldIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmluaXNoKHRhaWwsIGxlbmd0aCk7XG4gICAgICAgIHJldCA9ICEhcmF3ID8gdGhpcy5fc3RhdGUgOiBoZXgodGhpcy5fc3RhdGUpO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBTcGFya01ENS5BcnJheUJ1ZmZlci5wcm90b3R5cGUuX2ZpbmlzaCA9IFNwYXJrTUQ1LnByb3RvdHlwZS5fZmluaXNoO1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgY29tcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTcGFya01ENS5BcnJheUJ1ZmZlcn0gVGhlIGluc3RhbmNlIGl0c2VsZlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYnVmZiA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgbWVtb3J5IHVzZWQgYnkgdGhlIGluY3JlbWVudGFsIGJ1ZmZlciBhbmQgb3RoZXIgYWRpdGlvbmFsXG4gICAgICogcmVzb3VyY2VzLiBJZiB5b3UgcGxhbiB0byB1c2UgdGhlIGluc3RhbmNlIGFnYWluLCB1c2UgcmVzZXQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBTcGFya01ENS5BcnJheUJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IFNwYXJrTUQ1LnByb3RvdHlwZS5kZXN0cm95O1xuXG4gICAgLyoqXG4gICAgICogQ29uY2F0cyB0d28gYXJyYXkgYnVmZmVycywgcmV0dXJuaW5nIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5QnVmZmVyfSBmaXJzdCAgVGhlIGZpcnN0IGFycmF5IGJ1ZmZlclxuICAgICAqIEBwYXJhbSAge0FycmF5QnVmZmVyfSBzZWNvbmQgVGhlIHNlY29uZCBhcnJheSBidWZmZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBUaGUgbmV3IGFycmF5IGJ1ZmZlclxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLnByb3RvdHlwZS5fY29uY2F0QXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgZmlyc3RMZW5ndGggPSBmaXJzdC5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShmaXJzdExlbmd0aCArIHNlY29uZC5ieXRlTGVuZ3RoKTtcblxuICAgICAgICByZXN1bHQuc2V0KGZpcnN0KTtcbiAgICAgICAgcmVzdWx0LnNldChuZXcgVWludDhBcnJheShzZWNvbmQpLCBmaXJzdExlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIG1kNSBoYXNoIG9uIGFuIGFycmF5IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFyciBUaGUgYXJyYXkgYnVmZmVyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgcmF3IFRydWUgdG8gZ2V0IHRoZSByYXcgcmVzdWx0LCBmYWxzZSB0byBnZXQgdGhlIGhleCByZXN1bHRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX0gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLmhhc2ggPSBmdW5jdGlvbiAoYXJyLCByYXcpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBtZDUxX2FycmF5KG5ldyBVaW50OEFycmF5KGFycikpO1xuXG4gICAgICAgIHJldHVybiAhIXJhdyA/IGhhc2ggOiBoZXgoaGFzaCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTcGFya01ENTtcbn0pKTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN0cmluZ2lmeS9wYXJzZSBmdW5jdGlvbnMgdGhhdCBkb24ndCBvcGVyYXRlXG4gKiByZWN1cnNpdmVseSwgc28gdGhleSBhdm9pZCBjYWxsIHN0YWNrIGV4Y2VlZGVkXG4gKiBlcnJvcnMuXG4gKi9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KGlucHV0KSB7XG4gIHZhciBxdWV1ZSA9IFtdO1xuICBxdWV1ZS5wdXNoKHtvYmo6IGlucHV0fSk7XG5cbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbmV4dCwgb2JqLCBwcmVmaXgsIHZhbCwgaSwgYXJyYXlQcmVmaXgsIGtleXMsIGssIGtleSwgdmFsdWUsIG9ialByZWZpeDtcbiAgd2hpbGUgKChuZXh0ID0gcXVldWUucG9wKCkpKSB7XG4gICAgb2JqID0gbmV4dC5vYmo7XG4gICAgcHJlZml4ID0gbmV4dC5wcmVmaXggfHwgJyc7XG4gICAgdmFsID0gbmV4dC52YWwgfHwgJyc7XG4gICAgcmVzICs9IHByZWZpeDtcbiAgICBpZiAodmFsKSB7XG4gICAgICByZXMgKz0gdmFsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJlcyArPSB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICByZXMgKz0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBxdWV1ZS5wdXNoKHt2YWw6ICddJ30pO1xuICAgICAgZm9yIChpID0gb2JqLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5UHJlZml4ID0gaSA9PT0gMCA/ICcnIDogJywnO1xuICAgICAgICBxdWV1ZS5wdXNoKHtvYmo6IG9ialtpXSwgcHJlZml4OiBhcnJheVByZWZpeH0pO1xuICAgICAgfVxuICAgICAgcXVldWUucHVzaCh7dmFsOiAnWyd9KTtcbiAgICB9IGVsc2UgeyAvLyBvYmplY3RcbiAgICAgIGtleXMgPSBbXTtcbiAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVldWUucHVzaCh7dmFsOiAnfSd9KTtcbiAgICAgIGZvciAoaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgb2JqUHJlZml4ID0gKGkgPiAwID8gJywnIDogJycpO1xuICAgICAgICBvYmpQcmVmaXggKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JztcbiAgICAgICAgcXVldWUucHVzaCh7b2JqOiB2YWx1ZSwgcHJlZml4OiBvYmpQcmVmaXh9KTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnB1c2goe3ZhbDogJ3snfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgdGhlIHBhcnNlIGZ1bmN0aW9uLlxuLy8gVGhpcyBwb3AgZnVuY3Rpb24gaXMgYmFzaWNhbGx5IGNvcGllZCBmcm9tXG4vLyBwb3VjaENvbGxhdGUucGFyc2VJbmRleGFibGVTdHJpbmdcbmZ1bmN0aW9uIHBvcChvYmosIHN0YWNrLCBtZXRhU3RhY2spIHtcbiAgdmFyIGxhc3RNZXRhRWxlbWVudCA9IG1ldGFTdGFja1ttZXRhU3RhY2subGVuZ3RoIC0gMV07XG4gIGlmIChvYmogPT09IGxhc3RNZXRhRWxlbWVudC5lbGVtZW50KSB7XG4gICAgLy8gcG9wcGluZyBhIG1ldGEtZWxlbWVudCwgZS5nLiBhbiBvYmplY3Qgd2hvc2UgdmFsdWUgaXMgYW5vdGhlciBvYmplY3RcbiAgICBtZXRhU3RhY2sucG9wKCk7XG4gICAgbGFzdE1ldGFFbGVtZW50ID0gbWV0YVN0YWNrW21ldGFTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICB2YXIgZWxlbWVudCA9IGxhc3RNZXRhRWxlbWVudC5lbGVtZW50O1xuICB2YXIgbGFzdEVsZW1lbnRJbmRleCA9IGxhc3RNZXRhRWxlbWVudC5pbmRleDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBlbGVtZW50LnB1c2gob2JqKTtcbiAgfSBlbHNlIGlmIChsYXN0RWxlbWVudEluZGV4ID09PSBzdGFjay5sZW5ndGggLSAyKSB7IC8vIG9iaiB3aXRoIGtleSt2YWx1ZVxuICAgIHZhciBrZXkgPSBzdGFjay5wb3AoKTtcbiAgICBlbGVtZW50W2tleV0gPSBvYmo7XG4gIH0gZWxzZSB7XG4gICAgc3RhY2sucHVzaChvYmopOyAvLyBvYmogd2l0aCBrZXkgb25seVxuICB9XG59XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgbWV0YVN0YWNrID0gW107IC8vIHN0YWNrIGZvciBhcnJheXMgYW5kIG9iamVjdHNcbiAgdmFyIGkgPSAwO1xuICB2YXIgY29sbGF0aW9uSW5kZXgscGFyc2VkTnVtLG51bUNoYXI7XG4gIHZhciBwYXJzZWRTdHJpbmcsbGFzdENoLG51bUNvbnNlY3V0aXZlU2xhc2hlcyxjaDtcbiAgdmFyIGFycmF5RWxlbWVudCwgb2JqRWxlbWVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb2xsYXRpb25JbmRleCA9IHN0cltpKytdO1xuICAgIGlmIChjb2xsYXRpb25JbmRleCA9PT0gJ30nIHx8XG4gICAgICAgIGNvbGxhdGlvbkluZGV4ID09PSAnXScgfHxcbiAgICAgICAgdHlwZW9mIGNvbGxhdGlvbkluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3Aoc3RhY2sucG9wKCksIHN0YWNrLCBtZXRhU3RhY2spO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChjb2xsYXRpb25JbmRleCkge1xuICAgICAgY2FzZSAnICc6XG4gICAgICBjYXNlICdcXHQnOlxuICAgICAgY2FzZSAnXFxuJzpcbiAgICAgIGNhc2UgJzonOlxuICAgICAgY2FzZSAnLCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbic6XG4gICAgICAgIGkgKz0gMzsgLy8gJ3VsbCdcbiAgICAgICAgcG9wKG51bGwsIHN0YWNrLCBtZXRhU3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3QnOlxuICAgICAgICBpICs9IDM7IC8vICdydWUnXG4gICAgICAgIHBvcCh0cnVlLCBzdGFjaywgbWV0YVN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmJzpcbiAgICAgICAgaSArPSA0OyAvLyAnYWxzZSdcbiAgICAgICAgcG9wKGZhbHNlLCBzdGFjaywgbWV0YVN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcwJzpcbiAgICAgIGNhc2UgJzEnOlxuICAgICAgY2FzZSAnMic6XG4gICAgICBjYXNlICczJzpcbiAgICAgIGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6XG4gICAgICBjYXNlICc2JzpcbiAgICAgIGNhc2UgJzcnOlxuICAgICAgY2FzZSAnOCc6XG4gICAgICBjYXNlICc5JzpcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICBwYXJzZWROdW0gPSAnJztcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIG51bUNoYXIgPSBzdHJbaSsrXTtcbiAgICAgICAgICBpZiAoL1tcXGRcXC5cXC1lXFwrXS8udGVzdChudW1DaGFyKSkge1xuICAgICAgICAgICAgcGFyc2VkTnVtICs9IG51bUNoYXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3AocGFyc2VGbG9hdChwYXJzZWROdW0pLCBzdGFjaywgbWV0YVN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIHBhcnNlZFN0cmluZyA9ICcnO1xuICAgICAgICBsYXN0Q2ggPSB2b2lkIDA7XG4gICAgICAgIG51bUNvbnNlY3V0aXZlU2xhc2hlcyA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY2ggPSBzdHJbaSsrXTtcbiAgICAgICAgICBpZiAoY2ggIT09ICdcIicgfHwgKGxhc3RDaCA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgIG51bUNvbnNlY3V0aXZlU2xhc2hlcyAlIDIgPT09IDEpKSB7XG4gICAgICAgICAgICBwYXJzZWRTdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBsYXN0Q2ggPSBjaDtcbiAgICAgICAgICAgIGlmIChsYXN0Q2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBudW1Db25zZWN1dGl2ZVNsYXNoZXMrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG51bUNvbnNlY3V0aXZlU2xhc2hlcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3AoSlNPTi5wYXJzZSgnXCInICsgcGFyc2VkU3RyaW5nICsgJ1wiJyksIHN0YWNrLCBtZXRhU3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICBhcnJheUVsZW1lbnQgPSB7IGVsZW1lbnQ6IFtdLCBpbmRleDogc3RhY2subGVuZ3RoIH07XG4gICAgICAgIHN0YWNrLnB1c2goYXJyYXlFbGVtZW50LmVsZW1lbnQpO1xuICAgICAgICBtZXRhU3RhY2sucHVzaChhcnJheUVsZW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3snOlxuICAgICAgICBvYmpFbGVtZW50ID0geyBlbGVtZW50OiB7fSwgaW5kZXg6IHN0YWNrLmxlbmd0aCB9O1xuICAgICAgICBzdGFjay5wdXNoKG9iakVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAgIG1ldGFTdGFjay5wdXNoKG9iakVsZW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAndW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGlucHV0OiAnICsgY29sbGF0aW9uSW5kZXgpO1xuICAgIH1cbiAgfVxufTtcblxufSx7fV19LHt9LFsyMF0pXG4oMjApXG59KTsiLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCIvKipcbiAqIEV4cG9ydCBgdWlkYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdWlkO1xuXG4vKipcbiAqIENyZWF0ZSBhIGB1aWRgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxlblxuICogQHJldHVybiB7U3RyaW5nfSB1aWRcbiAqL1xuXG5mdW5jdGlvbiB1aWQobGVuKSB7XG4gIGxlbiA9IGxlbiB8fCA3O1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNSkuc3Vic3RyKDIsIGxlbik7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC9lbWl0dGVyJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnbWF0dGhld211ZWxsZXIvdWlkJyk7XG52YXIgVG9kbztcblxuLyoqXG4gKiBJbml0aWFsaXplIGBUb2RvYCB3aXRoIGBhdHRyc2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xuICovXG5Ub2RvID0gZnVuY3Rpb24gVG9kbyhhdHRycykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUb2RvKSkgcmV0dXJuIG5ldyBUb2RvKGF0dHJzKTtcbiAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgIHRoaXMuX2lkID0gYXR0cnMuX2lkIHx8IHVpZCgpO1xuICAgIHRoaXMuY29tcGxldGUgPSBhdHRycy5jb21wbGV0ZSB8fCBmYWxzZTtcbiAgICB0aGlzLnRpdGxlID0gYXR0cnMudGl0bGUgfHwgJyc7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5cbi8qKlxuICogTWl4aW5zXG4gKi9cbkVtaXR0ZXIoVG9kby5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhdHRyaWJ1dGVzIG9mIGEgdG9kb1xuICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKi9cblRvZG8ucHJvdG90eXBlLmF0dHJzID0gZnVuY3Rpb24gYXR0cnMoKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgaWYgKHRoaXMuX2lkKSBwcm9wcy5faWQgPSB0aGlzLl9pZDtcbiAgICBpZiAodGhpcy5fcmV2ICE9PSAtMSkgcHJvcHMuX3JldiA9IHRoaXMuX3JldjtcbiAgICBwcm9wcy5jb21wbGV0ZSA9IHRoaXMuY29tcGxldGU7XG4gICAgcHJvcHMudGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIHJldHVybiBwcm9wcztcbn07XG5cblRvZG8ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChhdHRycykge1xuICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICB0aGlzW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZSAnICsga2V5LCB0aGlzW2tleV0pO1xuICAgIH07XG59O1xuXG5Ub2RvLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoYXR0cikge1xuICAgIHJldHVybiB0aGlzW2F0dHJdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb2RvOyIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdjb21wb25lbnQvYXNzZXJ0Jyk7XG52YXIgVG9kbyA9IHJlcXVpcmUoJy9saWIvbGlzdC9saWIvdG9kbycpO1xuXG5kZXNjcmliZSgnVG9kbycsIGZ1bmN0aW9uICgpIHtcbiAgICBpdCgncmV0dXJucyBhIG5ldyB0b2RvJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9kbyA9IFRvZG8oKTtcbiAgICAgICAgYXNzZXJ0KHRvZG8gIT09IFRvZG8oKSk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ1RvZG8jYXR0cnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3JldHVybnMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRvZG8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbyh7dGl0bGU6ICdGb28nfSk7XG4gICAgICAgIGFzc2VydCh0b2RvLmF0dHJzKCkudGl0bGUgPT09ICdGb28nKTtcbiAgICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnVG9kbyNzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3NldHMgYSBwcm9wZXJ0eSBvbiB0aGUgdG9kbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvZG8gPSBUb2RvKCk7XG4gICAgICAgIGFzc2VydCh0b2RvLmNvbXBsZXRlID09PSBmYWxzZSk7XG4gICAgICAgIHRvZG8uc2V0KHtjb21wbGV0ZTogdHJ1ZX0pO1xuICAgICAgICBhc3NlcnQodG9kby5jb21wbGV0ZSA9PT0gdHJ1ZSk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ1RvZG8jZ2V0JywgZnVuY3Rpb24gKCkge1xuICAgIGl0KCdnZXRzIGEgcHJvcGVydHkgb24gdGhlIHRvZG8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbygpO1xuICAgICAgICBhc3NlcnQodG9kby5nZXQoJ2NvbXBsZXRlJykgPT09IGZhbHNlKTtcbiAgICAgICAgdG9kby5zZXQoe2NvbXBsZXRlOiB0cnVlfSk7XG4gICAgICAgIGFzc2VydCh0b2RvLmdldCgnY29tcGxldGUnKSA9PT0gdHJ1ZSk7XG4gICAgfSk7XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY29tcG9uZW50L2Fzc2VydCcpO1xudmFyIG1vbnRoID0gcmVxdWlyZSgnYW50aG9ueXNob3J0L2RhdGUtbW9udGgnKTtcbnZhciBzdWZmaXhlZCA9IHJlcXVpcmUoJ2FudGhvbnlzaG9ydC9kYXRlLXN1ZmZpeCcpO1xudmFyIGNsYXNzZXMgPSByZXF1aXJlKCdjb21wb25lbnQvY2xhc3NlcycpO1xudmFyIExpc3RWaWV3ID0gcmVxdWlyZSgnLi4vbGliL2xpc3QtdmlldycpO1xudmFyIExpc3QgPSByZXF1aXJlKCcuLi9saWIvbGlzdCcpO1xuXG5kZXNjcmliZSgnTGlzdFZpZXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3JldHVybnMgYSBuZXcgdmlldycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBMaXN0KCk7XG4gICAgICAgIHZhciB2aWV3ID0gTGlzdFZpZXcobGlzdCk7XG4gICAgICAgIGFzc2VydCh2aWV3ICE9PSBMaXN0VmlldyhsaXN0KSk7XG4gICAgfSk7XG4gICAgaXQoJ2NyZWF0ZXMgdGl0bGUgZWxlbWVudCBvbiBpbml0aWFsaXphdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBMaXN0KCk7XG4gICAgICAgIHZhciB2aWV3ID0gTGlzdFZpZXcobGlzdCk7XG4gICAgICAgIHZhciBlbE1vbnRoID0gbW9udGgobGlzdC50aW1lc3RhbXApLmZ1bGwoKTtcbiAgICAgICAgdmFyIGVsU3VmZml4ZWQgPSBzdWZmaXhlZChsaXN0LnRpbWVzdGFtcCk7XG4gICAgICAgIHZhciB0aXRsZVRleHQgPSB2aWV3LmVsLnF1ZXJ5U2VsZWN0b3IoJy5MaXN0LXRpdGxlJykuaW5uZXJIVE1MO1xuICAgICAgICBhc3NlcnQodGl0bGVUZXh0ID09PSBlbE1vbnRoICsgJyAnICsgZWxTdWZmaXhlZCk7XG4gICAgfSk7XG4gICAgaXQoJ2NyZWF0ZXMgdG9kbyBlbGVtZW50cyBvbiBpbml0aWFsaXphdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBMaXN0KCk7XG4gICAgICAgIGxpc3QuY3JlYXRlVG9kbyh7dGl0bGU6ICdGb28nfSk7XG4gICAgICAgIGxpc3QuY3JlYXRlVG9kbyh7dGl0bGU6ICdCYXInfSk7XG4gICAgICAgIGxpc3QuY3JlYXRlVG9kbyh7dGl0bGU6ICdCYXonfSk7XG4gICAgICAgIHZhciB2aWV3ID0gTGlzdFZpZXcobGlzdCk7XG4gICAgICAgIGFzc2VydCh2aWV3LnRvZG9WaWV3cy5sZW5ndGggPT09IDMpO1xuICAgICAgICBhc3NlcnQodmlldy5saXN0RWwuY2hpbGRyZW4ubGVuZ3RoID09PSAzKTtcbiAgICB9KTtcbiAgICBpdCgnY3JlYXRlcyB0b2RvIGVsZW1lbnRzIHdoZW4gbW9kZWwgZW1pdHMgYGNyZWF0ZSB0b2RvYCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBMaXN0KCk7XG4gICAgICAgIHZhciB2aWV3ID0gTGlzdFZpZXcobGlzdCk7XG4gICAgICAgIGxpc3QuY3JlYXRlVG9kbyh7dGl0bGU6ICdGb28nfSk7XG4gICAgICAgIGFzc2VydCh2aWV3LnRvZG9WaWV3cy5sZW5ndGggPT09IDEpO1xuICAgICAgICBhc3NlcnQodmlldy5saXN0RWwuY2hpbGRyZW4ubGVuZ3RoID09PSAxKTtcbiAgICAgICAgYXNzZXJ0KHZpZXcubGlzdEVsLnF1ZXJ5U2VsZWN0b3IoJy5Ub2RvLXRpdGxlJykuaW5uZXJIVE1MID09PSAnRm9vJyk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0xpc3RWaWV3I2ZpbHRlcicsIGZ1bmN0aW9uKCkge1xuICAgIGl0KCdhZGRzIHUtaGlkZGVuIGNsYXNzIHRvIGZpbHRlcmVkIHRvZG8gZWxlbWVudHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaXN0ID0gTGlzdCgpO1xuICAgICAgICB2YXIgdmlldyA9IExpc3RWaWV3KGxpc3QpO1xuICAgICAgICBsaXN0LmNyZWF0ZVRvZG8oe3RpdGxlOiAnRm9vJywgY29tcGxldGU6IGZhbHNlfSk7XG4gICAgICAgIGxpc3QuY3JlYXRlVG9kbyh7dGl0bGU6ICdCYXInLCBjb21wbGV0ZTogdHJ1ZX0pO1xuICAgICAgICB2aWV3LmZpbHRlcignY29tcGxldGUnLCB0cnVlKTtcbiAgICAgICAgYXNzZXJ0KHZpZXcubGlzdEVsLmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygndS1oaWRkZW4nKSk7XG4gICAgICAgIGFzc2VydCghKHZpZXcubGlzdEVsLmNoaWxkcmVuWzFdLmNsYXNzTGlzdC5jb250YWlucygndS1oaWRkZW4nKSkpO1xuICAgIH0pO1xufSk7IiwidmFyIG1vbnRocyA9IFtcbiAgJ0phbnVhcnknLFxuICAnRmVicnVhcnknLFxuICAnTWFyY2gnLFxuICAnQXByaWwnLFxuICAnTWF5JyxcbiAgJ0p1bmUnLFxuICAnSnVseScsXG4gICdBdWd1c3QnLFxuICAnU2VwdGVtYmVyJyxcbiAgJ09jdG9iZXInLFxuICAnTm92ZW1iZXInLFxuICAnRGVjZW1iZXInXG5dO1xuXG52YXIgc2hvcnQgPSBbXG4gICdKYW4nLFxuICAnRmViJyxcbiAgJ01hcicsXG4gICdBcHInLFxuICAnTWF5JyxcbiAgJ0p1bicsXG4gICdKdWwnLFxuICAnQXVnJyxcbiAgJ1NlcCcsXG4gICdPY3QnLFxuICAnTm92JyxcbiAgJ0RlYydcbl07XG5cbnZhciBkb3VibGUgPSBbXG4gICcwMScsXG4gICcwMicsXG4gICcwMycsXG4gICcwNCcsXG4gICcwNScsXG4gICcwNicsXG4gICcwNycsXG4gICcwOCcsXG4gICcwOScsXG4gICcxMCcsXG4gICcxMScsXG4gICcxMidcbl07XG5cbnZhciBzaW5nbGUgPSBbXG4gICcxJyxcbiAgJzInLFxuICAnMycsXG4gICc0JyxcbiAgJzUnLFxuICAnNicsXG4gICc3JyxcbiAgJzgnLFxuICAnOScsXG4gICcxMCcsXG4gICcxMScsXG4gICcxMidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0ZSkge1xuICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gIHJldHVybiB7XG4gICAgZnVsbDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBtb250aHNbbW9udGhdO1xuICAgIH0sXG4gICAgc2hvcnQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gc2hvcnRbbW9udGhdO1xuICAgIH0sXG4gICAgZG91YmxlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGRvdWJsZVttb250aF07XG4gICAgfSxcbiAgICBzaW5nbGU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gc2luZ2xlW21vbnRoXTtcbiAgICB9XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0ZSkge1xuICB2YXIgbnVtID0gZGF0ZS5nZXREYXRlKCk7XG4gIGlmICggbnVtICUgMTAwID49IDEwICYmIG51bSAlIDEwMCA8PSAxOSApIHtcbiAgICByZXR1cm4gbnVtICsgJ3RoJztcbiAgfVxuICBzd2l0Y2ggKCBudW0gJSAxMCApIHtcbiAgICBjYXNlIDE6IHJldHVybiBudW0gKyAnc3QnO1xuICAgIGNhc2UgMjogcmV0dXJuIG51bSArICduZCc7XG4gICAgY2FzZSAzOiByZXR1cm4gbnVtICsgJ3JkJztcbiAgfVxuICByZXR1cm4gbnVtICsgJ3RoJztcbn07IiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcblxuLyoqXG4gKiBXaGl0ZXNwYWNlIHJlZ2V4cC5cbiAqL1xuXG52YXIgcmUgPSAvXFxzKy87XG5cbi8qKlxuICogdG9TdHJpbmcgcmVmZXJlbmNlLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV3JhcCBgZWxgIGluIGEgYENsYXNzTGlzdGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVsKXtcbiAgcmV0dXJuIG5ldyBDbGFzc0xpc3QoZWwpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IENsYXNzTGlzdCBmb3IgYGVsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWwpIHtcbiAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLmxpc3QgPSBlbC5jbGFzc0xpc3Q7XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIGBuYW1lYCBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSl7XG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LmFkZChuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcbiAgaWYgKCF+aSkgYXJyLnB1c2gobmFtZSk7XG4gIHRoaXMuZWwuY2xhc3NOYW1lID0gYXJyLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyBgbmFtZWAgd2hlbiBwcmVzZW50LCBvclxuICogcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmVcbiAqIGFueSB3aGljaCBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKXtcbiAgaWYgKCdbb2JqZWN0IFJlZ0V4cF0nID09IHRvU3RyaW5nLmNhbGwobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZyhuYW1lKTtcbiAgfVxuXG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LnJlbW92ZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcbiAgaWYgKH5pKSBhcnIuc3BsaWNlKGksIDEpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGNsYXNzZXMgbWF0Y2hpbmcgYHJlYC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbihyZSl7XG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlLnRlc3QoYXJyW2ldKSkge1xuICAgICAgdGhpcy5yZW1vdmUoYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBjbGFzcyBgbmFtZWAsIGNhbiBmb3JjZSBzdGF0ZSB2aWEgYGZvcmNlYC5cbiAqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNsYXNzTGlzdCwgYnV0IGRvIG5vdCBzdXBwb3J0IGBmb3JjZWAgeWV0LFxuICogdGhlIG1pc3Rha2Ugd2lsbCBiZSBkZXRlY3RlZCBhbmQgY29ycmVjdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24obmFtZSwgZm9yY2Upe1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSAhPT0gdGhpcy5saXN0LnRvZ2dsZShuYW1lLCBmb3JjZSkpIHtcbiAgICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTsgLy8gdG9nZ2xlIGFnYWluIHRvIGNvcnJlY3RcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIGNsYXNzZXMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpe1xuICB2YXIgc3RyID0gdGhpcy5lbC5jbGFzc05hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICB2YXIgYXJyID0gc3RyLnNwbGl0KHJlKTtcbiAgaWYgKCcnID09PSBhcnJbMF0pIGFyci5zaGlmdCgpO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBjbGFzcyBgbmFtZWAgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmhhcyA9XG5DbGFzc0xpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiB0aGlzLmxpc3RcbiAgICA/IHRoaXMubGlzdC5jb250YWlucyhuYW1lKVxuICAgIDogISEgfmluZGV4KHRoaXMuYXJyYXkoKSwgbmFtZSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChhcnIuaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50L2VtaXR0ZXInKTtcbnZhciBtb250aCA9IHJlcXVpcmUoJ2FudGhvbnlzaG9ydC9kYXRlLW1vbnRoJyk7XG52YXIgc3VmZml4ZWQgPSByZXF1aXJlKCdhbnRob255c2hvcnQvZGF0ZS1zdWZmaXgnKTtcbnZhciBtb3ZlID0gcmVxdWlyZSgndmlzaW9ubWVkaWEvbW92ZS5qcycpO1xudmFyIGRvbWlmeSA9IHJlcXVpcmUoJ2NvbXBvbmVudC9kb21pZnknKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUuaHRtbCcpO1xudmFyIFRvZG9WaWV3ID0gcmVxdWlyZSgnLi9saWIvdG9kby12aWV3Jyk7XG52YXIgTGlzdFZpZXc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBgTGlzdFZpZXdgIHdpdGggYG1vZGVsYFxuICogQHBhcmFtIHtMaXN0fSBtb2RlbFxuICovXG5MaXN0VmlldyA9IGZ1bmN0aW9uIExpc3RWaWV3KG1vZGVsKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpc3RWaWV3KSkgcmV0dXJuIG5ldyBMaXN0Vmlldyhtb2RlbCk7XG4gICAgbW9kZWwgPSBtb2RlbCB8fCB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuZWwgPSBkb21pZnkodGVtcGxhdGUpO1xuICAgIHRoaXMubGlzdEVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuTGlzdC10b2RvcycpO1xuICAgIHRoaXMudG9kb1ZpZXdzID0gW107XG4gICAgdGhpcy5jcmVhdGVUaXRsZSgpO1xuXG4gICAgdGhpcy5tb2RlbC50b2Rvcy5mb3JFYWNoKGZ1bmN0aW9uICh0b2RvKSB7XG4gICAgICAgIHNlbGYuY3JlYXRlVG9kbyh0b2RvKTtcbiAgICB9KTtcblxuICAgIHRoaXMubW9kZWwub24oJ2NyZWF0ZSB0b2RvJywgZnVuY3Rpb24gKHRvZG8pIHtcbiAgICAgICAgc2VsZi5jcmVhdGVUb2RvKHRvZG8pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBNaXhpbnNcbiAqL1xuRW1pdHRlcihMaXN0Vmlldy5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZSB0aXRsZSBlbGVtZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTGlzdFZpZXcucHJvdG90eXBlLmNyZWF0ZVRpdGxlID0gZnVuY3Rpb24gY3JlYXRlVGl0bGUoKSB7XG4gICAgdmFyIHRpdGxlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5MaXN0LXRpdGxlJyk7XG4gICAgdmFyIHRpdGxlTW9udGggPSBtb250aCh0aGlzLm1vZGVsLnRpbWVzdGFtcCkuZnVsbCgpO1xuICAgIHZhciB0aXRsZVN1ZmZpeGVkID0gIHN1ZmZpeGVkKHRoaXMubW9kZWwudGltZXN0YW1wKTtcbiAgICB0aXRsZUVsLmlubmVySFRNTCA9IHRpdGxlTW9udGggKyAnICcgKyB0aXRsZVN1ZmZpeGVkO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdG9kbyBlbGVtZW50IHdpdGggYHRvZG9gIG1vZGVsXG4gKiBhbmQgYW5pbWF0ZSBpdFxuICogQHBhcmFtICB7VG9kb30gdG9kb1xuICogQGFwaSBwcml2YXRlXG4gKi9cbkxpc3RWaWV3LnByb3RvdHlwZS5jcmVhdGVUb2RvID0gZnVuY3Rpb24gY3JlYXRlVG9kbyh0b2RvKSB7XG4gICAgdmFyIHZpZXcgPSBUb2RvVmlldyh0b2RvKTtcbiAgICB0aGlzLnRvZG9WaWV3cy5wdXNoKHZpZXcpO1xuICAgIHRoaXMubGlzdEVsLmFwcGVuZENoaWxkKHZpZXcuZWwpO1xuICAgIHZpZXcuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB2aWV3LmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIG1vdmUodmlldy5lbCkueSgxMDAwKS5lbmQoKTtcbiAgICBtb3ZlKHZpZXcuZWwpLnkoMCkuZW5kKCk7XG59O1xuXG4vKipcbiAqIEhpZGUvc2hvdyB0aGUgdG9kbyBlbGVtZW50cyBieSBgdG9kb2AgbW9kZWwgcHJvcGVydGllc1xuICogQHBhcmFtICB7U3RyaW5nfSBrZXkgbW9kZWwgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtICB7TWl4ZWR9IHZhbCBtb2RlbCBwcm9wZXJ0eSB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuTGlzdFZpZXcucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihrZXksIHZhbCkge1xuICAgIHRoaXMudG9kb1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcubW9kZWxba2V5XSA9PT0gdmFsKSByZXR1cm4gdmlldy5zaG93KCk7XG4gICAgICAgIHZpZXcuaGlkZSgpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0VmlldzsiLCIvKipcbiAqIE1vZHVsZSBEZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXItdHJhbnNpdGlvbicpO1xudmFyIGhhczNkID0gcmVxdWlyZSgnaGFzLXRyYW5zbGF0ZTNkJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXInKTtcbnZhciBlYXNlID0gcmVxdWlyZSgnY3NzLWVhc2UnKTtcbnZhciBxdWVyeSA9IHJlcXVpcmUoJ3F1ZXJ5Jyk7XG5cbi8qKlxuICogQ1NTIFRyYW5zbGF0ZVxuICovXG5cbnZhciB0cmFuc2xhdGUgPSBoYXMzZFxuICA/IFsndHJhbnNsYXRlM2QoJywgJywgMCknXVxuICA6IFsndHJhbnNsYXRlKCcsICcpJ107XG5cbi8qKlxuICogRXhwb3J0IGBNb3ZlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW92ZTtcblxuLyoqXG4gKiBHZXQgY29tcHV0ZWQgc3R5bGUuXG4gKi9cblxudmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGVcbiAgfHwgd2luZG93LmN1cnJlbnRTdHlsZTtcblxuLyoqXG4gKiBMaWJyYXJ5IHZlcnNpb24uXG4gKi9cblxuTW92ZS52ZXJzaW9uID0gJzAuMy4yJztcblxuLyoqXG4gKiBFeHBvcnQgYGVhc2VgXG4gKi9cblxuTW92ZS5lYXNlID0gZWFzZTtcblxuLyoqXG4gKiBEZWZhdWx0cy5cbiAqXG4gKiAgIGBkdXJhdGlvbmAgLSBkZWZhdWx0IGR1cmF0aW9uIG9mIDUwMG1zXG4gKlxuICovXG5cbk1vdmUuZGVmYXVsdHMgPSB7XG4gIGR1cmF0aW9uOiA1MDBcbn07XG5cbi8qKlxuICogRGVmYXVsdCBlbGVtZW50IHNlbGVjdGlvbiB1dGlsaXplZCBieSBgbW92ZShzZWxlY3RvcilgLlxuICpcbiAqIE92ZXJyaWRlIHRvIGltcGxlbWVudCB5b3VyIG93biBzZWxlY3Rpb24sIGZvciBleGFtcGxlXG4gKiB3aXRoIGpRdWVyeSBvbmUgbWlnaHQgd3JpdGU6XG4gKlxuICogICAgIG1vdmUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgICAgIHJldHVybiBqUXVlcnkoc2VsZWN0b3IpLmdldCgwKTtcbiAqICAgICB9O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHNlbGVjdG9yKSByZXR1cm4gc2VsZWN0b3I7XG4gIHJldHVybiBxdWVyeShzZWxlY3Rvcik7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1vdmVgIHdpdGggdGhlIGdpdmVuIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNb3ZlKGVsKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb3ZlKSkgcmV0dXJuIG5ldyBNb3ZlKGVsKTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBlbCkgZWwgPSBxdWVyeShlbCk7XG4gIGlmICghZWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ01vdmUgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGVsZW1lbnQgb3Igc2VsZWN0b3InKTtcbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLl9wcm9wcyA9IHt9O1xuICB0aGlzLl9yb3RhdGUgPSAwO1xuICB0aGlzLl90cmFuc2l0aW9uUHJvcHMgPSBbXTtcbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLmR1cmF0aW9uKE1vdmUuZGVmYXVsdHMuZHVyYXRpb24pXG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cbiAqL1xuXG5FbWl0dGVyKE1vdmUucHJvdG90eXBlKTtcblxuLyoqXG4gKiBCdWZmZXIgYHRyYW5zZm9ybWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybVxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0pe1xuICB0aGlzLl90cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNrZXcgYHhgIGFuZCBgeWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2tldyA9IGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXcoJ1xuICAgICsgeCArICdkZWcsICdcbiAgICArICh5IHx8IDApXG4gICAgKyAnZGVnKScpO1xufTtcblxuLyoqXG4gKiBTa2V3IHggYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2tld1ggPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdza2V3WCgnICsgbiArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNrZXcgeSBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5za2V3WSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXdZKCcgKyBuICsgJ2RlZyknKTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIGB4YCBhbmQgYHlgIGF4aXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUudHJhbnNsYXRlID1cbk1vdmUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0cmFuc2xhdGUuam9pbignJ1xuICAgICsgeCArJ3B4LCAnXG4gICAgKyAoeSB8fCAwKVxuICAgICsgJ3B4JykpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgb24gdGhlIHggYXhpcyB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGVYID1cbk1vdmUucHJvdG90eXBlLnggPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGVYKCcgKyBuICsgJ3B4KScpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgb24gdGhlIHkgYXhpcyB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGVZID1cbk1vdmUucHJvdG90eXBlLnkgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGVZKCcgKyBuICsgJ3B4KScpO1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgeCBhbmQgeSBheGlzIGJ5IGB4YCwgb3JcbiAqIGluZGl2aWR1YWxseSBzY2FsZSBgeGAgYW5kIGB5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlKCdcbiAgICArIHggKyAnLCAnXG4gICAgKyAoeSB8fCB4KVxuICAgICsgJyknKTtcbn07XG5cbi8qKlxuICogU2NhbGUgeCBheGlzIGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlWCgnICsgbiArICcpJylcbn07XG5cbi8qKlxuICogQXBwbHkgYSBtYXRyaXggdHJhbnNmb3JtYXRpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUubWF0cml4ID0gZnVuY3Rpb24obTExLCBtMTIsIG0yMSwgbTIyLCBtMzEsIG0zMil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnbWF0cml4KCcgKyBbbTExLG0xMixtMjEsbTIyLG0zMSxtMzJdLmpvaW4oJywnKSArICcpJyk7XG59O1xuXG4vKipcbiAqIFNjYWxlIHkgYXhpcyBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdzY2FsZVkoJyArIG4gKyAnKScpXG59O1xuXG4vKipcbiAqIFJvdGF0ZSBgbmAgZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3JvdGF0ZSgnICsgbiArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNldCB0cmFuc2l0aW9uIGVhc2luZyBmdW5jdGlvbiB0byB0byBgZm5gIHN0cmluZy5cbiAqXG4gKiBXaGVuOlxuICpcbiAqICAgLSBudWxsIFwiZWFzZVwiIGlzIHVzZWRcbiAqICAgLSBcImluXCIgXCJlYXNlLWluXCIgaXMgdXNlZFxuICogICAtIFwib3V0XCIgXCJlYXNlLW91dFwiIGlzIHVzZWRcbiAqICAgLSBcImluLW91dFwiIFwiZWFzZS1pbi1vdXRcIiBpcyB1c2VkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKGZuKXtcbiAgZm4gPSBlYXNlW2ZuXSB8fCBmbiB8fCAnZWFzZSc7XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIGZuKTtcbn07XG5cbi8qKlxuICogU2V0IGFuaW1hdGlvbiBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbihuYW1lLCBwcm9wcyl7XG4gIGZvciAodmFyIGkgaW4gcHJvcHMpe1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgICB0aGlzLnNldFZlbmRvclByb3BlcnR5KCdhbmltYXRpb24tJyArIGksIHByb3BzW2ldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgnYW5pbWF0aW9uLW5hbWUnLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBTZXQgZHVyYXRpb24gdG8gYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24obil7XG4gIG4gPSB0aGlzLl9kdXJhdGlvbiA9ICdzdHJpbmcnID09IHR5cGVvZiBuXG4gICAgPyBwYXJzZUZsb2F0KG4pICogMTAwMFxuICAgIDogbjtcbiAgcmV0dXJuIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCBuICsgJ21zJyk7XG59O1xuXG4vKipcbiAqIERlbGF5IHRoZSBhbmltYXRpb24gYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24obil7XG4gIG4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgblxuICAgID8gcGFyc2VGbG9hdChuKSAqIDEwMDBcbiAgICA6IG47XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2l0aW9uLWRlbGF5JywgbiArICdtcycpO1xufTtcblxuLyoqXG4gKiBTZXQgYHByb3BgIHRvIGB2YWxgLCBkZWZlcnJlZCB1bnRpbCBgLmVuZCgpYCBpcyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCB2YWwpe1xuICB0aGlzLl9wcm9wc1twcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBhIHZlbmRvciBwcmVmaXhlZCBgcHJvcGAgd2l0aCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zZXRWZW5kb3JQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy13ZWJraXQtJyArIHByb3AsIHZhbCk7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy1tb3otJyArIHByb3AsIHZhbCk7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy1tcy0nICsgcHJvcCwgdmFsKTtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLW8tJyArIHByb3AsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYHByb3BgIHRvIGB2YWx1ZWAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgdGhpcy50cmFuc2l0aW9uKHByb3ApO1xuICB0aGlzLl9wcm9wc1twcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluY3JlbWVudCBgcHJvcGAgYnkgYHZhbGAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgaWYgKCFzdHlsZSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN1cnIgPSBwYXJzZUludChzZWxmLmN1cnJlbnQocHJvcCksIDEwKTtcbiAgICBzZWxmLnNldChwcm9wLCBjdXJyICsgdmFsICsgJ3B4Jyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZWNyZW1lbnQgYHByb3BgIGJ5IGB2YWxgLCBkZWZlcnJlZCB1bnRpbCBgLmVuZCgpYCBpcyBpbnZva2VkXG4gKiBhbmQgYWRkcyB0aGUgcHJvcGVydHkgdG8gdGhlIGxpc3Qgb2YgdHJhbnNpdGlvbiBwcm9wcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIGlmICghc3R5bGUpIHJldHVybjtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5vbignc3RhcnQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBjdXJyID0gcGFyc2VJbnQoc2VsZi5jdXJyZW50KHByb3ApLCAxMCk7XG4gICAgc2VsZi5zZXQocHJvcCwgY3VyciAtIHZhbCArICdweCcpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IGNvbXB1dGVkIG9yIFwiY3VycmVudFwiIHZhbHVlIG9mIGBwcm9wYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24ocHJvcCl7XG4gIHJldHVybiBzdHlsZSh0aGlzLmVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xufTtcblxuLyoqXG4gKiBBZGQgYHByb3BgIHRvIHRoZSBsaXN0IG9mIGludGVybmFsIHRyYW5zaXRpb24gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24ocHJvcCl7XG4gIGlmICghdGhpcy5fdHJhbnNpdGlvblByb3BzLmluZGV4T2YocHJvcCkpIHJldHVybiB0aGlzO1xuICB0aGlzLl90cmFuc2l0aW9uUHJvcHMucHVzaChwcm9wKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbW1pdCBzdHlsZSBwcm9wZXJ0aWVzLCBha2EgYXBwbHkgdGhlbSB0byBgZWwuc3R5bGVgLlxuICpcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQHNlZSBNb3ZlI2VuZCgpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5hcHBseVByb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3Byb3BzKSB7XG4gICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB0aGlzLl9wcm9wc1twcm9wXSwgJycpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZS1zZWxlY3QgZWxlbWVudCB2aWEgYHNlbGVjdG9yYCwgcmVwbGFjaW5nXG4gKiB0aGUgY3VycmVudCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLm1vdmUgPVxuTW92ZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICB0aGlzLmVsID0gTW92ZS5zZWxlY3Qoc2VsZWN0b3IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmZXIgdGhlIGdpdmVuIGBmbmAgdW50aWwgdGhlIGFuaW1hdGlvblxuICogaXMgY29tcGxldGUuIGBmbmAgbWF5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAgLSBhIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICAtIGFuIGluc3RhbmNlb2YgYE1vdmVgIHRvIGNhbGwgYC5lbmQoKWBcbiAqICAgLSBub3RoaW5nLCB0byByZXR1cm4gYSBjbG9uZSBvZiB0aGlzIGBNb3ZlYCBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE1vdmV9IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKGZuKXtcbiAgLy8gaW52b2tlIC5lbmQoKVxuICBpZiAoZm4gaW5zdGFuY2VvZiBNb3ZlKSB7XG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgIGZuLmVuZCgpO1xuICAgIH0pO1xuICAvLyBjYWxsYmFja1xuICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGZuKSB7XG4gICAgdGhpcy5vbignZW5kJywgZm4pO1xuICAvLyBjaGFpblxuICB9IGVsc2Uge1xuICAgIHZhciBjbG9uZSA9IG5ldyBNb3ZlKHRoaXMuZWwpO1xuICAgIGNsb25lLl90cmFuc2Zvcm1zID0gdGhpcy5fdHJhbnNmb3Jtcy5zbGljZSgwKTtcbiAgICB0aGlzLnRoZW4oY2xvbmUpO1xuICAgIGNsb25lLnBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBvcCB0aGUgbW92ZSBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge01vdmV9IHBhcmVudCBNb3ZlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG5cbi8qKlxuICogUmVzZXQgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TW92ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVsLnN0eWxlLndlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9XG4gIHRoaXMuZWwuc3R5bGUubW96VHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgdGhpcy5lbC5zdHlsZS5tc1RyYW5zaXRpb25EdXJhdGlvbiA9XG4gIHRoaXMuZWwuc3R5bGUub1RyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnQgYW5pbWF0aW9uLCBvcHRpb25hbGx5IGNhbGxpbmcgYGZuYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZW1pdCBcInN0YXJ0XCIgZXZlbnRcbiAgdGhpcy5lbWl0KCdzdGFydCcpO1xuXG4gIC8vIHRyYW5zZm9ybXNcbiAgaWYgKHRoaXMuX3RyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5fdHJhbnNmb3Jtcy5qb2luKCcgJykpO1xuICB9XG5cbiAgLy8gdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tcHJvcGVydGllcycsIHRoaXMuX3RyYW5zaXRpb25Qcm9wcy5qb2luKCcsICcpKTtcbiAgdGhpcy5hcHBseVByb3BlcnRpZXMoKTtcblxuICAvLyBjYWxsYmFjayBnaXZlblxuICBpZiAoZm4pIHRoaXMudGhlbihmbik7XG5cbiAgLy8gZW1pdCBcImVuZFwiIHdoZW4gY29tcGxldGVcbiAgYWZ0ZXIub25jZSh0aGlzLmVsLCBmdW5jdGlvbigpe1xuICAgIHNlbGYucmVzZXQoKTtcbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG4iLCJcbi8qKlxuICogZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcy10cmFuc2l0aW9ucycpXG4gICwgZW1pdHRlciA9IHJlcXVpcmUoJ2Nzcy1lbWl0dGVyJylcbiAgLCBvbmNlID0gcmVxdWlyZSgnb25jZScpO1xuXG4vKipcbiAqIFRyYW5zaXRpb24gc3VwcG9ydC5cbiAqL1xuXG52YXIgc3VwcG9ydGVkID0gaGFzKCk7XG5cbi8qKlxuICogRXhwb3J0IGBhZnRlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmdGVyO1xuXG4vKipcbiAqIEludm9rZSB0aGUgZ2l2ZW4gYGZuYCBhZnRlciB0cmFuc2l0aW9uc1xuICpcbiAqIEl0IHdpbGwgYmUgaW52b2tlZCBvbmx5IGlmIHRoZSBicm93c2VyXG4gKiBzdXBwb3J0cyB0cmFuc2l0aW9ucyBfX2FuZF9fXG4gKiB0aGUgZWxlbWVudCBoYXMgdHJhbnNpdGlvbnNcbiAqIHNldCBpbiBgLnN0eWxlYCBvciBjc3MuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBmblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBhZnRlcihlbCwgZm4pe1xuICBpZiAoIXN1cHBvcnRlZCB8fCAhaGFzKGVsKSkgcmV0dXJuIGZuKCk7XG4gIGVtaXR0ZXIoZWwpLmJpbmQoZm4pO1xuICByZXR1cm4gZm47XG59O1xuXG4vKipcbiAqIFNhbWUgYXMgYGFmdGVyKClgIG9ubHkgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgb25jZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmFmdGVyLm9uY2UgPSBmdW5jdGlvbihlbCwgZm4pe1xuICB2YXIgY2FsbGJhY2sgPSBvbmNlKGZuKTtcbiAgYWZ0ZXIoZWwsIGZuID0gZnVuY3Rpb24oKXtcbiAgICBlbWl0dGVyKGVsKS51bmJpbmQoZm4pO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcbiIsIlxuLyoqXG4gKiBDaGVjayBpZiBgZWxgIG9yIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNpdGlvbnMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwpe1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBib29sO1xuICAgIGNhc2UgMTogcmV0dXJuIGJvb2xcbiAgICAgID8gdHJhbnNpdGlvbnMoZWwpXG4gICAgICA6IGJvb2w7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGBlbGAgaGFzIHRyYW5zaXRpb25zLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2l0aW9ucyhlbCwgc3R5bCl7XG4gIGlmIChlbC50cmFuc2l0aW9uKSByZXR1cm4gdHJ1ZTtcbiAgc3R5bCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgcmV0dXJuICEhIHN0eWwudHJhbnNpdGlvbjtcbn1cblxuLyoqXG4gKiBTdHlsZS5cbiAqL1xuXG52YXIgc3R5bCA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbi8qKlxuICogRXhwb3J0IHN1cHBvcnQuXG4gKi9cblxudmFyIGJvb2wgPSAndHJhbnNpdGlvbicgaW4gc3R5bFxuICB8fCAnd2Via2l0VHJhbnNpdGlvbicgaW4gc3R5bFxuICB8fCAnTW96VHJhbnNpdGlvbicgaW4gc3R5bFxuICB8fCAnbXNUcmFuc2l0aW9uJyBpbiBzdHlsO1xuIiwiLyoqXG4gKiBNb2R1bGUgRGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50Jyk7XG5cbi8vIENTUyBldmVudHNcblxudmFyIHdhdGNoID0gW1xuICAndHJhbnNpdGlvbmVuZCdcbiwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnXG4sICdvVHJhbnNpdGlvbkVuZCdcbiwgJ01TVHJhbnNpdGlvbkVuZCdcbiwgJ2FuaW1hdGlvbmVuZCdcbiwgJ3dlYmtpdEFuaW1hdGlvbkVuZCdcbiwgJ29BbmltYXRpb25FbmQnXG4sICdNU0FuaW1hdGlvbkVuZCdcbl07XG5cbi8qKlxuICogRXhwb3NlIGBDU1NuZXh0YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ3NzRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBDc3NFbWl0dGVyYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBDc3NFbWl0dGVyKGVsZW1lbnQpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3NzRW1pdHRlcikpIHJldHVybiBuZXcgQ3NzRW1pdHRlcihlbGVtZW50KTtcbiAgdGhpcy5lbCA9IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQmluZCBDU1MgZXZlbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ3NzRW1pdHRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGZuKXtcbiAgZm9yICh2YXIgaT0wOyBpIDwgd2F0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICBldmVudHMuYmluZCh0aGlzLmVsLCB3YXRjaFtpXSwgZm4pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgQ1NTIGV2ZW50c1xuICogXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNzc0VtaXR0ZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGZuKXtcbiAgZm9yICh2YXIgaT0wOyBpIDwgd2F0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICBldmVudHMudW5iaW5kKHRoaXMuZWwsIHdhdGNoW2ldLCBmbik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpcmUgY2FsbGJhY2sgb25seSBvbmNlXG4gKiBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ3NzRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiBvbigpe1xuICAgIHNlbGYudW5iaW5kKG9uKTtcbiAgICBmbi5hcHBseShzZWxmLmVsLCBhcmd1bWVudHMpO1xuICB9XG4gIHNlbGYuYmluZChvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuIiwidmFyIGJpbmQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdhdHRhY2hFdmVudCcsXG4gICAgdW5iaW5kID0gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnLFxuICAgIHByZWZpeCA9IGJpbmQgIT09ICdhZGRFdmVudExpc3RlbmVyJyA/ICdvbicgOiAnJztcblxuLyoqXG4gKiBCaW5kIGBlbGAgZXZlbnQgYHR5cGVgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBlbFtiaW5kXShwcmVmaXggKyB0eXBlLCBmbiwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gIHJldHVybiBmbjtcbn07XG5cbi8qKlxuICogVW5iaW5kIGBlbGAgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudW5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgZWxbdW5iaW5kXShwcmVmaXggKyB0eXBlLCBmbiwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gIHJldHVybiBmbjtcbn07IiwiXG4vKipcbiAqIElkZW50aWZpZXIuXG4gKi9cblxudmFyIG4gPSAwO1xuXG4vKipcbiAqIEdsb2JhbC5cbiAqL1xuXG52YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzIH0pKCk7XG5cbi8qKlxuICogTWFrZSBgZm5gIGNhbGxhYmxlIG9ubHkgb25jZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbisrO1xuXG4gIGZ1bmN0aW9uIG9uY2UoKXtcbiAgICAvLyBubyByZWNlaXZlclxuICAgIGlmICh0aGlzID09IGdsb2JhbCkge1xuICAgICAgaWYgKG9uY2UuY2FsbGVkKSByZXR1cm47XG4gICAgICBvbmNlLmNhbGxlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyByZWNlaXZlclxuICAgIHZhciBrZXkgPSAnX19jYWxsZWRfJyArIGlkICsgJ19fJztcbiAgICBpZiAodGhpc1trZXldKSByZXR1cm47XG4gICAgdGhpc1trZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBvbmNlO1xufTtcbiIsIlxudmFyIHByb3AgPSByZXF1aXJlKCd0cmFuc2Zvcm0tcHJvcGVydHknKTtcblxuLy8gSUUgPD04IGRvZXNuJ3QgaGF2ZSBgZ2V0Q29tcHV0ZWRTdHlsZWBcbmlmICghcHJvcCB8fCAhd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxufSBlbHNlIHtcbiAgdmFyIG1hcCA9IHtcbiAgICB3ZWJraXRUcmFuc2Zvcm06ICctd2Via2l0LXRyYW5zZm9ybScsXG4gICAgT1RyYW5zZm9ybTogJy1vLXRyYW5zZm9ybScsXG4gICAgbXNUcmFuc2Zvcm06ICctbXMtdHJhbnNmb3JtJyxcbiAgICBNb3pUcmFuc2Zvcm06ICctbW96LXRyYW5zZm9ybScsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJ1xuICB9O1xuXG4gIC8vIGZyb206IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2xvcmVuem9wb2xpZG9yaS8zNzk0MjI2XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5zdHlsZVtwcm9wXSA9ICd0cmFuc2xhdGUzZCgxcHgsMXB4LDFweCknO1xuICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gIHZhciB2YWwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKG1hcFtwcm9wXSk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICBtb2R1bGUuZXhwb3J0cyA9IG51bGwgIT0gdmFsICYmIHZhbC5sZW5ndGggJiYgJ25vbmUnICE9IHZhbDtcbn1cbiIsIlxudmFyIHN0eWxlcyA9IFtcbiAgJ3dlYmtpdFRyYW5zZm9ybScsXG4gICdNb3pUcmFuc2Zvcm0nLFxuICAnbXNUcmFuc2Zvcm0nLFxuICAnT1RyYW5zZm9ybScsXG4gICd0cmFuc2Zvcm0nXG5dO1xuXG52YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG52YXIgc3R5bGU7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gIHN0eWxlID0gc3R5bGVzW2ldO1xuICBpZiAobnVsbCAhPSBlbC5zdHlsZVtzdHlsZV0pIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlO1xuICAgIGJyZWFrO1xuICB9XG59XG4iLCJcbi8qKlxuICogQ1NTIEVhc2luZyBmdW5jdGlvbnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnaW4nOiAgICAgICAgICAgICAgICAnZWFzZS1pbidcbiAgLCAnb3V0JzogICAgICAgICAgICAgICAnZWFzZS1vdXQnXG4gICwgJ2luLW91dCc6ICAgICAgICAgICAgJ2Vhc2UtaW4tb3V0J1xuICAsICdzbmFwJzogICAgICAgICAgICAgICdjdWJpYy1iZXppZXIoMCwxLC41LDEpJ1xuICAsICdsaW5lYXInOiAgICAgICAgICAgICdjdWJpYy1iZXppZXIoMC4yNTAsIDAuMjUwLCAwLjc1MCwgMC43NTApJ1xuICAsICdlYXNlLWluLXF1YWQnOiAgICAgICdjdWJpYy1iZXppZXIoMC41NTAsIDAuMDg1LCAwLjY4MCwgMC41MzApJ1xuICAsICdlYXNlLWluLWN1YmljJzogICAgICdjdWJpYy1iZXppZXIoMC41NTAsIDAuMDU1LCAwLjY3NSwgMC4xOTApJ1xuICAsICdlYXNlLWluLXF1YXJ0JzogICAgICdjdWJpYy1iZXppZXIoMC44OTUsIDAuMDMwLCAwLjY4NSwgMC4yMjApJ1xuICAsICdlYXNlLWluLXF1aW50JzogICAgICdjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUwLCAwLjg1NSwgMC4wNjApJ1xuICAsICdlYXNlLWluLXNpbmUnOiAgICAgICdjdWJpYy1iZXppZXIoMC40NzAsIDAuMDAwLCAwLjc0NSwgMC43MTUpJ1xuICAsICdlYXNlLWluLWV4cG8nOiAgICAgICdjdWJpYy1iZXppZXIoMC45NTAsIDAuMDUwLCAwLjc5NSwgMC4wMzUpJ1xuICAsICdlYXNlLWluLWNpcmMnOiAgICAgICdjdWJpYy1iZXppZXIoMC42MDAsIDAuMDQwLCAwLjk4MCwgMC4zMzUpJ1xuICAsICdlYXNlLWluLWJhY2snOiAgICAgICdjdWJpYy1iZXppZXIoMC42MDAsIC0wLjI4MCwgMC43MzUsIDAuMDQ1KSdcbiAgLCAnZWFzZS1vdXQtcXVhZCc6ICAgICAnY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSdcbiAgLCAnZWFzZS1vdXQtY3ViaWMnOiAgICAnY3ViaWMtYmV6aWVyKDAuMjE1LCAwLjYxMCwgMC4zNTUsIDEuMDAwKSdcbiAgLCAnZWFzZS1vdXQtcXVhcnQnOiAgICAnY3ViaWMtYmV6aWVyKDAuMTY1LCAwLjg0MCwgMC40NDAsIDEuMDAwKSdcbiAgLCAnZWFzZS1vdXQtcXVpbnQnOiAgICAnY3ViaWMtYmV6aWVyKDAuMjMwLCAxLjAwMCwgMC4zMjAsIDEuMDAwKSdcbiAgLCAnZWFzZS1vdXQtc2luZSc6ICAgICAnY3ViaWMtYmV6aWVyKDAuMzkwLCAwLjU3NSwgMC41NjUsIDEuMDAwKSdcbiAgLCAnZWFzZS1vdXQtZXhwbyc6ICAgICAnY3ViaWMtYmV6aWVyKDAuMTkwLCAxLjAwMCwgMC4yMjAsIDEuMDAwKSdcbiAgLCAnZWFzZS1vdXQtY2lyYyc6ICAgICAnY3ViaWMtYmV6aWVyKDAuMDc1LCAwLjgyMCwgMC4xNjUsIDEuMDAwKSdcbiAgLCAnZWFzZS1vdXQtYmFjayc6ICAgICAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMjAsIDEuMjc1KSdcbiAgLCAnZWFzZS1vdXQtcXVhZCc6ICAgICAnY3ViaWMtYmV6aWVyKDAuNDU1LCAwLjAzMCwgMC41MTUsIDAuOTU1KSdcbiAgLCAnZWFzZS1vdXQtY3ViaWMnOiAgICAnY3ViaWMtYmV6aWVyKDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEuMDAwKSdcbiAgLCAnZWFzZS1pbi1vdXQtcXVhcnQnOiAnY3ViaWMtYmV6aWVyKDAuNzcwLCAwLjAwMCwgMC4xNzUsIDEuMDAwKSdcbiAgLCAnZWFzZS1pbi1vdXQtcXVpbnQnOiAnY3ViaWMtYmV6aWVyKDAuODYwLCAwLjAwMCwgMC4wNzAsIDEuMDAwKSdcbiAgLCAnZWFzZS1pbi1vdXQtc2luZSc6ICAnY3ViaWMtYmV6aWVyKDAuNDQ1LCAwLjA1MCwgMC41NTAsIDAuOTUwKSdcbiAgLCAnZWFzZS1pbi1vdXQtZXhwbyc6ICAnY3ViaWMtYmV6aWVyKDEuMDAwLCAwLjAwMCwgMC4wMDAsIDEuMDAwKSdcbiAgLCAnZWFzZS1pbi1vdXQtY2lyYyc6ICAnY3ViaWMtYmV6aWVyKDAuNzg1LCAwLjEzNSwgMC4xNTAsIDAuODYwKSdcbiAgLCAnZWFzZS1pbi1vdXQtYmFjayc6ICAnY3ViaWMtYmV6aWVyKDAuNjgwLCAtMC41NTAsIDAuMjY1LCAxLjU1MCknXG59O1xuIiwiZnVuY3Rpb24gb25lKHNlbGVjdG9yLCBlbCkge1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBlbCl7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG4gIHJldHVybiBvbmUoc2VsZWN0b3IsIGVsKTtcbn07XG5cbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVsKXtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufTtcblxuZXhwb3J0cy5lbmdpbmUgPSBmdW5jdGlvbihvYmope1xuICBpZiAoIW9iai5vbmUpIHRocm93IG5ldyBFcnJvcignLm9uZSBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBpZiAoIW9iai5hbGwpIHRocm93IG5ldyBFcnJvcignLmFsbCBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBvbmUgPSBvYmoub25lO1xuICBleHBvcnRzLmFsbCA9IG9iai5hbGw7XG4gIHJldHVybiBleHBvcnRzO1xufTtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYHBhcnNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG4vKipcbiAqIFRlc3RzIGZvciBicm93c2VyIHN1cHBvcnQuXG4gKi9cblxudmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuLy8gU2V0dXBcbmRpdi5pbm5lckhUTUwgPSAnICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj1cIi9hXCI+YTwvYT48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIvPic7XG4vLyBNYWtlIHN1cmUgdGhhdCBsaW5rIGVsZW1lbnRzIGdldCBzZXJpYWxpemVkIGNvcnJlY3RseSBieSBpbm5lckhUTUxcbi8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcbnZhciBpbm5lckhUTUxCdWcgPSAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJykubGVuZ3RoO1xuZGl2ID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFdyYXAgbWFwIGZyb20ganF1ZXJ5LlxuICovXG5cbnZhciBtYXAgPSB7XG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgLy8gZm9yIHNjcmlwdC9saW5rL3N0eWxlIHRhZ3MgdG8gd29yayBpbiBJRTYtOCwgeW91IGhhdmUgdG8gd3JhcFxuICAvLyBpbiBhIGRpdiB3aXRoIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGluIGZyb250LCBoYSFcbiAgX2RlZmF1bHQ6IGlubmVySFRNTEJ1ZyA/IFsxLCAnWDxkaXY+JywgJzwvZGl2PiddIDogWzAsICcnLCAnJ11cbn07XG5cbm1hcC50ZCA9XG5tYXAudGggPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxubWFwLm9wdGlvbiA9XG5tYXAub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxubWFwLnRoZWFkID1cbm1hcC50Ym9keSA9XG5tYXAuY29sZ3JvdXAgPVxubWFwLmNhcHRpb24gPVxubWFwLnRmb290ID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG5cbm1hcC50ZXh0ID1cbm1hcC5jaXJjbGUgPVxubWFwLmVsbGlwc2UgPVxubWFwLmxpbmUgPVxubWFwLnBhdGggPVxubWFwLnBvbHlnb24gPVxubWFwLnBvbHlsaW5lID1cbm1hcC5yZWN0ID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2ZXJzaW9uPVwiMS4xXCI+JywnPC9zdmc+J107XG5cbi8qKlxuICogUGFyc2UgYGh0bWxgIGFuZCByZXR1cm4gYSBET00gTm9kZSBpbnN0YW5jZSwgd2hpY2ggY291bGQgYmUgYSBUZXh0Tm9kZSxcbiAqIEhUTUwgRE9NIE5vZGUgb2Ygc29tZSBraW5kICg8ZGl2PiBmb3IgZXhhbXBsZSksIG9yIGEgRG9jdW1lbnRGcmFnbWVudFxuICogaW5zdGFuY2UsIGRlcGVuZGluZyBvbiB0aGUgY29udGVudHMgb2YgdGhlIGBodG1sYCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgLSBIVE1MIHN0cmluZyB0byBcImRvbWlmeVwiXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgLSBUaGUgYGRvY3VtZW50YCBpbnN0YW5jZSB0byBjcmVhdGUgdGhlIE5vZGUgZm9yXG4gKiBAcmV0dXJuIHtET01Ob2RlfSB0aGUgVGV4dE5vZGUsIERPTSBOb2RlLCBvciBEb2N1bWVudEZyYWdtZW50IGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShodG1sLCBkb2MpIHtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBodG1sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgZXhwZWN0ZWQnKTtcblxuICAvLyBkZWZhdWx0IHRvIHRoZSBnbG9iYWwgYGRvY3VtZW50YCBvYmplY3RcbiAgaWYgKCFkb2MpIGRvYyA9IGRvY3VtZW50O1xuXG4gIC8vIHRhZyBuYW1lXG4gIHZhciBtID0gLzwoW1xcdzpdKykvLmV4ZWMoaHRtbCk7XG4gIGlmICghbSkgcmV0dXJuIGRvYy5jcmVhdGVUZXh0Tm9kZShodG1sKTtcblxuICBodG1sID0gaHRtbC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7IC8vIFJlbW92ZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcblxuICB2YXIgdGFnID0gbVsxXTtcblxuICAvLyBib2R5IHN1cHBvcnRcbiAgaWYgKHRhZyA9PSAnYm9keScpIHtcbiAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUNoaWxkKGVsLmxhc3RDaGlsZCk7XG4gIH1cblxuICAvLyB3cmFwIG1hcFxuICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5fZGVmYXVsdDtcbiAgdmFyIGRlcHRoID0gd3JhcFswXTtcbiAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gIHZhciBzdWZmaXggPSB3cmFwWzJdO1xuICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsLmlubmVySFRNTCA9IHByZWZpeCArIGh0bWwgKyBzdWZmaXg7XG4gIHdoaWxlIChkZXB0aC0tKSBlbCA9IGVsLmxhc3RDaGlsZDtcblxuICAvLyBvbmUgZWxlbWVudFxuICBpZiAoZWwuZmlyc3RDaGlsZCA9PSBlbC5sYXN0Q2hpbGQpIHtcbiAgICByZXR1cm4gZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cblxuICAvLyBzZXZlcmFsIGVsZW1lbnRzXG4gIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCkpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSAnPGRpdiBjbGFzcz1cIkxpc3RcIj5cXG4gICAgPGgxIGNsYXNzPVwiTGlzdC10aXRsZVwiPjwvaDE+XFxuICAgIDx1bCBjbGFzcz1cIkxpc3QtdG9kb3NcIj48L3VsPlxcbjwvZGl2Pic7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRvbWlmeSA9IHJlcXVpcmUoJ2NvbXBvbmVudC9kb21pZnknKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCdjb21wb25lbnQvZXZlbnQnKTtcbnZhciBkZWxlZ2F0ZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC9kZWxlZ2F0ZScpO1xudmFyIGNsYXNzZXMgPSByZXF1aXJlKCdjb21wb25lbnQvY2xhc3NlcycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZS5odG1sJyk7XG52YXIgVmlldztcblxuLyoqXG4gKiBJbml0aWFsaXplIGBWaWV3YCB3aXRoIGBtb2RlbGBcbiAqIEBwYXJhbSB7VG9kb30gbW9kZWxcbiAqL1xuVmlldyA9IGZ1bmN0aW9uIFZpZXcobW9kZWwpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmlldykpIHJldHVybiBuZXcgVmlldyhtb2RlbCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcblxuICAgIHRoaXMuZWwgPSBkb21pZnkodGVtcGxhdGUpO1xuICAgIHRoaXMudGl0bGVFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLlRvZG8tdGl0bGUnKTtcbiAgICB0aGlzLmNoZWNrYm94RWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWNvbXBsZXRlXScpO1xuICAgIHRoaXMuZGVzdHJveUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuSWNvbi0tZGVsZXRlJyk7XG5cbiAgICB0aGlzLnRpdGxlRWwuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy50aXRsZUVsLmlubmVySFRNTCA9IHRoaXMubW9kZWwudGl0bGU7XG4gICAgdGhpcy5jaGVja2JveEVsLmNoZWNrZWQgPSBtb2RlbC5nZXQoJ2NvbXBsZXRlJyk7XG4gICAgdGhpcy5jaGVja2JveEVsLmlkID0gJ3RvZG8tJyArIHRoaXMubW9kZWwuX2lkO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXModGhpcy5lbCk7XG5cbiAgICBldmVudHMuYmluZCh0aGlzLnRpdGxlRWwsICdibHVyJywgdGhpcy50b2dnbGVFZGl0aW5nLmJpbmQodGhpcykpO1xuICAgIGV2ZW50cy5iaW5kKHRoaXMudGl0bGVFbCwgJ2NsaWNrJywgdGhpcy50b2dnbGVFZGl0aW5nLmJpbmQodGhpcykpO1xuICAgIGV2ZW50cy5iaW5kKHRoaXMuY2hlY2tib3hFbCwgJ2NsaWNrJywgdGhpcy50b2dnbGVDb21wbGV0ZS5iaW5kKHRoaXMpKTtcbiAgICBldmVudHMuYmluZCh0aGlzLmRlc3Ryb3lFbCwgJ2NsaWNrJywgdGhpcy5kZXN0cm95LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpLmh0bWxGb3IgPSAndG9kby0nICsgdGhpcy5tb2RlbC5faWQ7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBlZGl0aW5nIG1vZGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5WaWV3LnByb3RvdHlwZS50b2dnbGVFZGl0aW5nID0gZnVuY3Rpb24gdG9nZ2xlRWRpdGluZyhldmVudCkge1xuICAgIGlmICh0aGlzLnRpdGxlRWwuY29udGVudEVkaXRhYmxlLnRvU3RyaW5nKCkgPT09ICdmYWxzZScpIHtcbiAgICAgICAgdGhpcy50aXRsZUVsLmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMudGl0bGVFbC5mb2N1cygpO1xuICAgICAgICBjbGFzc2VzKHRoaXMudGl0bGVFbCkuYWRkKCdpcy1lZGl0aW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHJldHVybjtcbiAgICB0aGlzLnRpdGxlRWwuYmx1cigpO1xuICAgIGNsYXNzZXModGhpcy50aXRsZUVsKS5yZW1vdmUoJ2lzLWVkaXRpbmcnKTtcbiAgICB0aGlzLnRpdGxlRWwuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBtb2RlbCdzIGBjb21wbGV0ZWAgcHJvcGVydHlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5WaWV3LnByb3RvdHlwZS50b2dnbGVDb21wbGV0ZSA9IGZ1bmN0aW9uIHRvZ2dsZUNvbXBsZXRlKCkge1xuICAgIHZhciBzdGF0dXMgPSB0aGlzLmNoZWNrYm94RWwuY2hlY2tlZDtcbiAgICB0aGlzLm1vZGVsLnNldCh7Y29tcGxldGU6IHN0YXR1c30pO1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY29tcGxldGUnKSkgcmV0dXJuIHRoaXMuY2xhc3Nlcy5hZGQoJ2NvbXBsZXRlJyk7XG4gICAgdGhpcy5jbGFzc2VzLnJlbW92ZSgnY29tcGxldGUnKTtcbn07XG5cbi8qKlxuICogQWRkIGBoaWRkZW5gIGNsYXNzIHRvIGB0aGlzLmVsYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5jbGFzc2VzLmFkZCgndS1oaWRkZW4nKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGBoaWRkZW5gIGNsYXNzIGZyb20gYHRoaXMuZWxgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5WaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmNsYXNzZXMucmVtb3ZlKCd1LWhpZGRlbicpO1xufTtcblxuLyoqXG4gKiBFbWl0IGBkZXN0cm95ZWRgIG9uIG1vZGVsIGFuZCByZW1vdmUgZWxlbWVudFxuICogQGFwaSBwcml2YXRlXG4gKi9cblZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMubW9kZWwuZW1pdCgnZGVzdHJveScpO1xuICAgIHRoaXMuZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldzsiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGNsb3Nlc3QgPSByZXF1aXJlKCdjbG9zZXN0JylcbiAgLCBldmVudCA9IHJlcXVpcmUoJ2V2ZW50Jyk7XG5cbi8qKlxuICogRGVsZWdhdGUgZXZlbnQgYHR5cGVgIHRvIGBzZWxlY3RvcmBcbiAqIGFuZCBpbnZva2UgYGZuKGUpYC4gQSBjYWxsYmFjayBmdW5jdGlvblxuICogaXMgcmV0dXJuZWQgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byBgLnVuYmluZCgpYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5iaW5kID0gZnVuY3Rpb24oZWwsIHNlbGVjdG9yLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIHJldHVybiBldmVudC5iaW5kKGVsLCB0eXBlLCBmdW5jdGlvbihlKXtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IsIHRydWUsIGVsKTtcbiAgICBpZiAoZS5kZWxlZ2F0ZVRhcmdldCkgZm4uY2FsbChlbCwgZSk7XG4gIH0sIGNhcHR1cmUpO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVuYmluZCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGV2ZW50LnVuYmluZChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpO1xufTtcbiIsInZhciBtYXRjaGVzID0gcmVxdWlyZSgnbWF0Y2hlcy1zZWxlY3RvcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yLCBjaGVja1lvU2VsZiwgcm9vdCkge1xuICBlbGVtZW50ID0gY2hlY2tZb1NlbGYgPyB7cGFyZW50Tm9kZTogZWxlbWVudH0gOiBlbGVtZW50XG5cbiAgcm9vdCA9IHJvb3QgfHwgZG9jdW1lbnRcblxuICAvLyBNYWtlIHN1cmUgYGVsZW1lbnQgIT09IGRvY3VtZW50YCBhbmQgYGVsZW1lbnQgIT0gbnVsbGBcbiAgLy8gb3RoZXJ3aXNlIHdlIGdldCBhbiBpbGxlZ2FsIGludm9jYXRpb25cbiAgd2hpbGUgKChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlKSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudCkge1xuICAgIGlmIChtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSlcbiAgICAgIHJldHVybiBlbGVtZW50XG4gICAgLy8gQWZ0ZXIgYG1hdGNoZXNgIG9uIHRoZSBlZGdlIGNhc2UgdGhhdFxuICAgIC8vIHRoZSBzZWxlY3RvciBtYXRjaGVzIHRoZSByb290XG4gICAgLy8gKHdoZW4gdGhlIHJvb3QgaXMgbm90IHRoZSBkb2N1bWVudClcbiAgICBpZiAoZWxlbWVudCA9PT0gcm9vdClcbiAgICAgIHJldHVyblxuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHF1ZXJ5ID0gcmVxdWlyZSgncXVlcnknKTtcblxuLyoqXG4gKiBFbGVtZW50IHByb3RvdHlwZS5cbiAqL1xuXG52YXIgcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBWZW5kb3IgZnVuY3Rpb24uXG4gKi9cblxudmFyIHZlbmRvciA9IHByb3RvLm1hdGNoZXNcbiAgfHwgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1vek1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tc01hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5vTWF0Y2hlc1NlbGVjdG9yO1xuXG4vKipcbiAqIEV4cG9zZSBgbWF0Y2goKWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaDtcblxuLyoqXG4gKiBNYXRjaCBgZWxgIHRvIGBzZWxlY3RvcmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodmVuZG9yKSByZXR1cm4gdmVuZG9yLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgdmFyIG5vZGVzID0gcXVlcnkuYWxsKHNlbGVjdG9yLCBlbC5wYXJlbnROb2RlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChub2Rlc1tpXSA9PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSAnPGxpIGNsYXNzPVwiVG9kb1wiPlxcbiAgICA8aW5wdXQgY2xhc3M9XCJUb2RvLWNoZWNrYm94XCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cIlwiIHZhbHVlPVwiTm9uZVwiIG5hbWU9XCJjb21wbGV0ZVwiLz5cXG4gICAgPGxhYmVsIGZvcj1cIlwiPjwvbGFiZWw+XFxuICAgIDxkaXYgY2xhc3M9XCJUb2RvLXRpdGxlQ29udGFpbmVyXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVwiVG9kby10aXRsZSB1LXNpemVGaWxsXCIgY29udGVudEVkaXRhYmxlPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPHNwYW4gY2xhc3M9XCJUb2RvLWljb25cIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiSWNvbiBJY29uLS1kZWxldGVcIj5cXG4gICAgICAgICAgICA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJpc28tODg1OS0xXCI/PlxcbiAgICAgICAgICAgIDwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT5cXG4gICAgICAgICAgICA8IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIj5cXG4gICAgICAgICAgICA8c3ZnIHZlcnNpb249XCIxLjFcIiBjbGFzcz1cIkljb24tLWRlbGV0ZVNWR1wiIGlkPVwiQ2FwYV8xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCJcXG4gICAgICAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiBzdHlsZT1cImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzIgMzI7XCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0eWxlPVwiZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7XCIgZD1cIk0yMS45ODcsMTEuNDRjLTAuMDE1LTAuMzYzLTAuMTUtMC43MjMtMC40MjgtMVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMtMC4yNzctMC4yNzctMC42MzctMC40MTMtMS0wLjQyOGMtMC40MDQtMC4wMTctMC44MTMsMC4xMTktMS4xMjEsMC40MjhMMTYsMTMuODc5bC0zLjQzOC0zLjQzOVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMtMC4zMDktMC4zMDktMC43MTctMC40NDQtMS4xMjEtMC40MjhjLTAuMzYzLDAuMDE1LTAuNzIzLDAuMTUtMSwwLjQyOGMtMC4yNzcsMC4yNzctMC40MTMsMC42MzctMC40MjgsMVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMtMC4wMTcsMC40MDQsMC4xMTksMC44MTIsMC40MjgsMS4xMjFMMTMuODc5LDE2bC0zLjQzOCwzLjQzOGMtMC4zMDksMC4zMDktMC40NDQsMC43MTctMC40MjgsMS4xMjFcXG4gICAgICAgICAgICAgICAgICAgICAgICBjMC4wMTUsMC4zNjMsMC4xNSwwLjcyMywwLjQyOCwxYzAuMjc3LDAuMjc3LDAuNjM3LDAuNDEzLDEsMC40MjhjMC40MDQsMC4wMTcsMC44MTItMC4xMTksMS4xMjEtMC40MjhMMTYsMTguMTIxbDMuNDM5LDMuNDM5XFxuICAgICAgICAgICAgICAgICAgICAgICAgYzAuMzA5LDAuMzA5LDAuNzE3LDAuNDQ0LDEuMTIxLDAuNDI4YzAuMzYzLTAuMDE1LDAuNzIzLTAuMTUsMS0wLjQyOGMwLjI3Ny0wLjI3NywwLjQxMy0wLjYzNywwLjQyOC0xXFxuICAgICAgICAgICAgICAgICAgICAgICAgYzAuMDE3LTAuNDA0LTAuMTE5LTAuODEyLTAuNDI4LTEuMTIxTDE4LjEyMSwxNmwzLjQzOC0zLjQzOEMyMS44NjgsMTIuMjUzLDIyLjAwNCwxMS44NDUsMjEuOTg3LDExLjQ0eiBNMTYsMFxcbiAgICAgICAgICAgICAgICAgICAgICAgIEM3LjE2NCwwLDAsNy4xNjQsMCwxNmMwLDguODM2LDcuMTY0LDE2LDE2LDE2YzguODM2LDAsMTYtNy4xNjQsMTYtMTZDMzIsNy4xNjQsMjQuODM2LDAsMTYsMHogTTE2LDI5QzguODMyLDI5LDMsMjMuMTY4LDMsMTZcXG4gICAgICAgICAgICAgICAgICAgICAgICBDMyw4LjgzMiw4LjgzMiwzLDE2LDNzMTMsNS44MzIsMTMsMTNDMjksMjMuMTY4LDIzLjE2OCwyOSwxNiwyOXpcIi8+XFxuICAgICAgICAgICAgPC9zdmc+XFxuICAgICAgICA8L3NwYW4+XFxuICAgIDwvc3Bhbj5cXG48L2xpPic7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2NvbXBvbmVudC9hc3NlcnQnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnL2xpYi9saXN0LXZpZXcvbGliL3RvZG8tdmlldycpO1xudmFyIFRvZG8gPSByZXF1aXJlKCcvbGliL2xpc3QvbGliL3RvZG8nKTtcblxuZGVzY3JpYmUoJ1RvZG9WaWV3JywgZnVuY3Rpb24gKCkge1xuICAgIGl0KCdyZXR1cm5zIGEgbmV3IHZpZXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbygpO1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcodG9kbyk7XG4gICAgICAgIGFzc2VydCh2aWV3ICE9PSBWaWV3KHRvZG8pKTtcbiAgICB9KTtcbiAgICBpdCgnY3JlYXRlcyB0b2RvIGVsZW1lbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbyh7dGl0bGU6ICdGb28nfSk7XG4gICAgICAgIHZhciB2aWV3ID0gVmlldyh0b2RvKTtcbiAgICAgICAgdmFyIHRpdGxlID0gdmlldy5lbC5xdWVyeVNlbGVjdG9yKCcuVG9kby10aXRsZScpLmlubmVySFRNTDtcbiAgICAgICAgdmFyIGNoZWNrYm94SWQgPSB2aWV3LmVsLnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWNvbXBsZXRlXScpLmlkO1xuICAgICAgICB2YXIgbGFiZWxGb3IgPSB2aWV3LmVsLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJykuaHRtbEZvcjtcbiAgICAgICAgYXNzZXJ0KHRpdGxlID09PSAnRm9vJyk7XG4gICAgICAgIGFzc2VydChjaGVja2JveElkID09PSAndG9kby0nICsgdG9kby5faWQpO1xuICAgICAgICBhc3NlcnQobGFiZWxGb3IgPT09ICd0b2RvLScgKyB0b2RvLl9pZCk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ1RvZG9WaWV3I3RvZ2dsZUVkaXRpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3NldHMgY29udGVudGVkaXRhYmxlIHRvIHRydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbygpO1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcodG9kbyk7XG4gICAgICAgIGFzc2VydCh2aWV3LnRpdGxlRWwuY29udGVudEVkaXRhYmxlID09PSAnZmFsc2UnKTtcbiAgICAgICAgdmlldy50b2dnbGVFZGl0aW5nKCk7XG4gICAgICAgIGFzc2VydCh2aWV3LnRpdGxlRWwuY29udGVudEVkaXRhYmxlLnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgfSk7XG4gICAgaXQoJ2FkZHMgYGlzLWVkaXRpbmdgIGNsYXNzIHRvIHRvZG8gZWxlbWVudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvZG8gPSBUb2RvKCk7XG4gICAgICAgIHZhciB2aWV3ID0gVmlldyh0b2RvKTtcbiAgICAgICAgYXNzZXJ0KCEodmlldy50aXRsZUVsLmNsYXNzTGlzdC5jb250YWlucygnaXMtZWRpdGluZycpKSk7XG4gICAgICAgIHZpZXcudG9nZ2xlRWRpdGluZygpO1xuICAgICAgICBhc3NlcnQodmlldy50aXRsZUVsLmNsYXNzTGlzdC5jb250YWlucygnaXMtZWRpdGluZycpKTtcbiAgICB9KTtcbiAgICBpdCgncmVtb3ZlcyBgaXMtZWRpdGluZ2AgY2xhc3MgZnJvbSB0b2RvIGVsZW1lbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbygpO1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcodG9kbyk7XG4gICAgICAgIGFzc2VydCghKHZpZXcudGl0bGVFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2lzLWVkaXRpbmcnKSkpO1xuICAgICAgICB2aWV3LnRvZ2dsZUVkaXRpbmcoKTtcbiAgICAgICAgYXNzZXJ0KHZpZXcudGl0bGVFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2lzLWVkaXRpbmcnKSk7XG4gICAgICAgIHZpZXcudG9nZ2xlRWRpdGluZygpO1xuICAgICAgICBhc3NlcnQoISh2aWV3LnRpdGxlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdpcy1lZGl0aW5nJykpKTtcbiAgICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnVG9kb1ZpZXcjdG9nZ2xlQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3RvZ2dsZXMgbW9kZWxcXCdzIGBjb21wbGV0ZWAgcHJvcGVydHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbygpO1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcodG9kbyk7XG4gICAgICAgIGFzc2VydCh2aWV3Lm1vZGVsLmdldCgnY29tcGxldGUnKSA9PT0gZmFsc2UpO1xuICAgICAgICB2aWV3LmNoZWNrYm94RWwuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHZpZXcudG9nZ2xlQ29tcGxldGUoKTtcbiAgICAgICAgYXNzZXJ0KHZpZXcubW9kZWwuZ2V0KCdjb21wbGV0ZScpID09PSB0cnVlKTtcbiAgICB9KTtcbiAgICBpdCgnYWRkcyBgY29tcGxldGVgIGNsYXNzIHRvIGVsZW1lbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbygpO1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcodG9kbyk7XG4gICAgICAgIGFzc2VydCghKHZpZXcuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb21wbGV0ZScpKSk7XG4gICAgICAgIHZpZXcuY2hlY2tib3hFbC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgdmlldy50b2dnbGVDb21wbGV0ZSgpO1xuICAgICAgICBhc3NlcnQodmlldy5lbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbXBsZXRlJykpO1xuICAgIH0pO1xuICAgIGl0KCdyZW1vdmVzIGBjb21wbGV0ZWAgY2xhc3MgZnJvbSBlbGVtZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9kbyA9IFRvZG8oKTtcbiAgICAgICAgdmFyIHZpZXcgPSBWaWV3KHRvZG8pO1xuICAgICAgICBhc3NlcnQoISh2aWV3LmVsLmNsYXNzTGlzdC5jb250YWlucygnY29tcGxldGUnKSkpO1xuICAgICAgICB2aWV3LmNoZWNrYm94RWwuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHZpZXcudG9nZ2xlQ29tcGxldGUoKTtcbiAgICAgICAgYXNzZXJ0KHZpZXcuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb21wbGV0ZScpKTtcbiAgICAgICAgdmlldy5jaGVja2JveEVsLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdmlldy50b2dnbGVDb21wbGV0ZSgpO1xuICAgICAgICBhc3NlcnQoISh2aWV3LmVsLmNsYXNzTGlzdC5jb250YWlucygnY29tcGxldGUnKSkpO1xuICAgIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdUb2RvVmlldyNoaWRlJywgZnVuY3Rpb24gKCkge1xuICAgIGl0KCdhZGRzIGB1LWhpZGRlbmAgY2xhc3MgdG8gdG9kbyBlbGVtZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9kbyA9IFRvZG8oKTtcbiAgICAgICAgdmFyIHZpZXcgPSBWaWV3KHRvZG8pO1xuICAgICAgICBhc3NlcnQoISh2aWV3LmVsLmNsYXNzTGlzdC5jb250YWlucygndS1oaWRkZW4nKSkpO1xuICAgICAgICB2aWV3LmhpZGUoKTtcbiAgICAgICAgYXNzZXJ0KHZpZXcuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd1LWhpZGRlbicpKTtcbiAgICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnVG9kb1ZpZXcjc2hvdycsIGZ1bmN0aW9uICgpIHtcbiAgICBpdCgncmVtb3ZlcyBgdS1oaWRkZW5gIGNsYXNzIGZyb20gdG9kbyBlbGVtZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9kbyA9IFRvZG8oKTtcbiAgICAgICAgdmFyIHZpZXcgPSBWaWV3KHRvZG8pO1xuICAgICAgICBhc3NlcnQoISh2aWV3LmVsLmNsYXNzTGlzdC5jb250YWlucygndS1oaWRkZW4nKSkpO1xuICAgICAgICB2aWV3LmhpZGUoKTtcbiAgICAgICAgYXNzZXJ0KHZpZXcuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd1LWhpZGRlbicpKTtcbiAgICAgICAgdmlldy5zaG93KCk7XG4gICAgICAgIGFzc2VydCghKHZpZXcuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd1LWhpZGRlbicpKSk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ1RvZG9WaWV3I2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ2NhdXNlcyBtb2RlbCB0byBlbWl0IGBkZXN0cm95YCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIHZhciB0b2RvID0gVG9kbygpO1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcodG9kbyk7XG4gICAgICAgIHRvZG8ub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQodHJ1ZSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBpdCgncmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBwYWdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIHRvZG8gPSBUb2RvKCk7XG4gICAgICAgIHZhciB2aWV3ID0gVmlldyh0b2RvKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodmlldy5lbCk7XG4gICAgICAgIGFzc2VydChlbC5jaGlsZHJlbi5sZW5ndGggPT09IDEpO1xuICAgICAgICBhc3NlcnQoZWwuY2hpbGRyZW5bMF0gPT09IHZpZXcuZWwpO1xuICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgYXNzZXJ0KCFlbC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH0pO1xufSk7Il19